"use strict";
cc._RF.push(module, 'f772dTuhJVOqIdOgjNeFhPX', 'matchvs.all');
// matchvs.all.js

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* ================ protobuf.js ================= */
/*!
 * protobuf.js v6.8.4 (c) 2016, daniel wirtz
 * compiled thu, 04 jan 2018 21:51:39 utc
 * licensed under the bsd-3-clause license
 * see: https://github.com/dcodeio/protobuf.js for details
 */
(function (global, undefined) {
    "use strict";
    (function prelude(modules, cache, entries) {

        // This is the prelude used to bundle protobuf.js for the browser. Wraps up the CommonJS
        // sources through a conflict-free _require shim and is again wrapped within an iife that
        // provides a unified `global` and a minification-friendly `undefined` var plus a global
        // "use strict" directive so that minification can remove the directives of each module.

        function $_require(name) {
            var $module = cache[name];
            if (!$module) modules[name][0].call($module = cache[name] = { exports: {} }, $_require, $module, $module.exports);
            return $module.exports;
        }

        // Expose globally
        var protobuf = global.protobuf = $_require(entries[0]);

        // Be nice to AMD
        if (typeof define === "function" && define.amd) define(["long"], function (Long) {
            if (Long && Long.isLong) {
                protobuf.util.Long = Long;
                protobuf.configure();
            }
            return protobuf;
        });

        // Be nice to CommonJS
        if ((typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && module && module.exports) module.exports = protobuf;
    })( /* end of prelude */{ 1: [function (_require, module, exports) {
            "use strict";

            module.exports = asPromise;

            /**
             * Callback as used by {@link util.asPromise}.
             * @typedef asPromiseCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {...*} params Additional arguments
             * @returns {undefined}
             */

            /**
             * Returns a promise from a node-style callback function.
             * @memberof util
             * @param {asPromiseCallback} fn Function to call
             * @param {*} ctx Function context
             * @param {...*} params Function arguments
             * @returns {Promise<*>} Promisified function
             */
            function asPromise(fn, ctx /*, varargs */) {
                var params = new Array(arguments.length - 1),
                    offset = 0,
                    index = 2,
                    pending = true;
                while (index < arguments.length) {
                    params[offset++] = arguments[index++];
                }return new Promise(function executor(resolve, reject) {
                    params[offset] = function callback(err /*, varargs */) {
                        if (pending) {
                            pending = false;
                            if (err) reject(err);else {
                                var params = new Array(arguments.length - 1),
                                    offset = 0;
                                while (offset < params.length) {
                                    params[offset++] = arguments[offset];
                                }resolve.apply(null, params);
                            }
                        }
                    };
                    try {
                        fn.apply(ctx || null, params);
                    } catch (err) {
                        if (pending) {
                            pending = false;
                            reject(err);
                        }
                    }
                });
            }
        }, {}], 2: [function (_require, module, exports) {
            "use strict";

            /**
             * A minimal base64 implementation for number arrays.
             * @memberof util
             * @namespace
             */

            var base64 = exports;

            /**
             * Calculates the byte length of a base64 encoded string.
             * @param {string} string Base64 encoded string
             * @returns {number} Byte length
             */
            base64.length = function length(string) {
                var p = string.length;
                if (!p) return 0;
                var n = 0;
                while (--p % 4 > 1 && string.charAt(p) === "=") {
                    ++n;
                }return Math.ceil(string.length * 3) / 4 - n;
            };

            // Base64 encoding table
            var b64 = new Array(64);

            // Base64 decoding table
            var s64 = new Array(123);

            // 65..90, 97..122, 48..57, 43, 47
            for (var i = 0; i < 64;) {
                s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
            } /**
               * Encodes a buffer to a base64 encoded string.
               * @param {Uint8Array} buffer Source buffer
               * @param {number} start Source start
               * @param {number} end Source end
               * @returns {string} Base64 encoded string
               */
            base64.encode = function encode(buffer, start, end) {
                var parts = null,
                    chunk = [];
                var i = 0,
                    // output index
                j = 0,
                    // goto index
                t; // temporary
                while (start < end) {
                    var b = buffer[start++];
                    switch (j) {
                        case 0:
                            chunk[i++] = b64[b >> 2];
                            t = (b & 3) << 4;
                            j = 1;
                            break;
                        case 1:
                            chunk[i++] = b64[t | b >> 4];
                            t = (b & 15) << 2;
                            j = 2;
                            break;
                        case 2:
                            chunk[i++] = b64[t | b >> 6];
                            chunk[i++] = b64[b & 63];
                            j = 0;
                            break;
                    }
                    if (i > 8191) {
                        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
                        i = 0;
                    }
                }
                if (j) {
                    chunk[i++] = b64[t];
                    chunk[i++] = 61;
                    if (j === 1) chunk[i++] = 61;
                }
                if (parts) {
                    if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
                    return parts.join("");
                }
                return String.fromCharCode.apply(String, chunk.slice(0, i));
            };

            var invalidEncoding = "invalid encoding";

            /**
             * Decodes a base64 encoded string to a buffer.
             * @param {string} string Source string
             * @param {Uint8Array} buffer Destination buffer
             * @param {number} offset Destination offset
             * @returns {number} Number of bytes written
             * @throws {Error} If encoding is invalid
             */
            base64.decode = function decode(string, buffer, offset) {
                var start = offset;
                var j = 0,
                    // goto index
                t; // temporary
                for (var i = 0; i < string.length;) {
                    var c = string.charCodeAt(i++);
                    if (c === 61 && j > 1) break;
                    if ((c = s64[c]) === undefined) throw Error(invalidEncoding);
                    switch (j) {
                        case 0:
                            t = c;
                            j = 1;
                            break;
                        case 1:
                            buffer[offset++] = t << 2 | (c & 48) >> 4;
                            t = c;
                            j = 2;
                            break;
                        case 2:
                            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                            t = c;
                            j = 3;
                            break;
                        case 3:
                            buffer[offset++] = (t & 3) << 6 | c;
                            j = 0;
                            break;
                    }
                }
                if (j === 1) throw Error(invalidEncoding);
                return offset - start;
            };

            /**
             * Tests if the specified string appears to be base64 encoded.
             * @param {string} string String to test
             * @returns {boolean} `true` if probably base64 encoded, otherwise false
             */
            base64.test = function test(string) {
                return (/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string)
                );
            };
        }, {}], 3: [function (_require, module, exports) {
            "use strict";

            module.exports = codegen;

            /**
             * Begins generating a function.
             * @memberof util
             * @param {string[]} functionParams Function parameter names
             * @param {string} [functionName] Function name if not anonymous
             * @returns {Codegen} Appender that appends code to the function's body
             */
            function codegen(functionParams, functionName) {

                /* istanbul ignore if */
                if (typeof functionParams === "string") {
                    functionName = functionParams;
                    functionParams = undefined;
                }

                var body = [];

                /**
                 * Appends code to the function's body or finishes generation.
                 * @typedef Codegen
                 * @type {function}
                 * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any
                 * @param {...*} [formatParams] Format parameters
                 * @returns {Codegen|Function} Itself or the generated function if finished
                 * @throws {Error} If format parameter counts do not match
                 */

                function Codegen(formatStringOrScope) {
                    // note that explicit array handling below makes this ~50% faster

                    // finish the function
                    if (typeof formatStringOrScope !== "string") {
                        var source = toString();
                        if (codegen.verbose) console.log("codegen: " + source); // eslint-disable-line no-console
                        source = "return " + source;
                        if (formatStringOrScope) {
                            var scopeKeys = Object.keys(formatStringOrScope),
                                scopeParams = new Array(scopeKeys.length + 1),
                                scopeValues = new Array(scopeKeys.length),
                                scopeOffset = 0;
                            while (scopeOffset < scopeKeys.length) {
                                scopeParams[scopeOffset] = scopeKeys[scopeOffset];
                                scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
                            }
                            scopeParams[scopeOffset] = source;
                            return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func
                        }
                        return Function(source)(); // eslint-disable-line no-new-func
                    }

                    // otherwise append to body
                    var formatParams = new Array(arguments.length - 1),
                        formatOffset = 0;
                    while (formatOffset < formatParams.length) {
                        formatParams[formatOffset] = arguments[++formatOffset];
                    }formatOffset = 0;
                    formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
                        var value = formatParams[formatOffset++];
                        switch ($1) {
                            case "d":case "f":
                                return String(Number(value));
                            case "i":
                                return String(Math.floor(value));
                            case "j":
                                return JSON.stringify(value);
                            case "s":
                                return String(value);
                        }
                        return "%";
                    });
                    if (formatOffset !== formatParams.length) throw Error("parameter count mismatch");
                    body.push(formatStringOrScope);
                    return Codegen;
                }

                function toString(functionNameOverride) {
                    return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
                }

                Codegen.toString = toString;
                return Codegen;
            }

            /**
             * Begins generating a function.
             * @memberof util
             * @function codegen
             * @param {string} [functionName] Function name if not anonymous
             * @returns {Codegen} Appender that appends code to the function's body
             * @variation 2
             */

            /**
             * When set to `true`, codegen will log generated code to console. Useful for debugging.
             * @name util.codegen.verbose
             * @type {boolean}
             */
            codegen.verbose = false;
        }, {}], 4: [function (_require, module, exports) {
            "use strict";

            module.exports = EventEmitter;

            /**
             * Constructs a new event emitter instance.
             * @classdesc A minimal event emitter.
             * @memberof util
             * @constructor
             */
            function EventEmitter() {

                /**
                 * Registered listeners.
                 * @type {Object.<string,*>}
                 * @private
                 */
                this._listeners = {};
            }

            /**
             * Registers an event listener.
             * @param {string} evt Event name
             * @param {function} fn Listener
             * @param {*} [ctx] Listener context
             * @returns {util.EventEmitter} `this`
             */
            EventEmitter.prototype.on = function on(evt, fn, ctx) {
                (this._listeners[evt] || (this._listeners[evt] = [])).push({
                    fn: fn,
                    ctx: ctx || this
                });
                return this;
            };

            /**
             * Removes an event listener or any matching listeners if arguments are omitted.
             * @param {string} [evt] Event name. Removes all listeners if omitted.
             * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
             * @returns {util.EventEmitter} `this`
             */
            EventEmitter.prototype.off = function off(evt, fn) {
                if (evt === undefined) this._listeners = {};else {
                    if (fn === undefined) this._listeners[evt] = [];else {
                        var listeners = this._listeners[evt];
                        for (var i = 0; i < listeners.length;) {
                            if (listeners[i].fn === fn) listeners.splice(i, 1);else ++i;
                        }
                    }
                }
                return this;
            };

            /**
             * Emits an event by calling its listeners with the specified arguments.
             * @param {string} evt Event name
             * @param {...*} args Arguments
             * @returns {util.EventEmitter} `this`
             */
            EventEmitter.prototype.emit = function emit(evt) {
                var listeners = this._listeners[evt];
                if (listeners) {
                    var args = [],
                        i = 1;
                    for (; i < arguments.length;) {
                        args.push(arguments[i++]);
                    }for (i = 0; i < listeners.length;) {
                        listeners[i].fn.apply(listeners[i++].ctx, args);
                    }
                }
                return this;
            };
        }, {}], 5: [function (_require, module, exports) {
            "use strict";

            module.exports = fetch;

            var asPromise = _require(1),
                inquire = _require(7);

            var fs = inquire("fs");

            /**
             * Node-style callback as used by {@link util.fetch}.
             * @typedef FetchCallback
             * @type {function}
             * @param {?Error} error Error, if any, otherwise `null`
             * @param {string} [contents] File contents, if there hasn't been an error
             * @returns {undefined}
             */

            /**
             * Options as used by {@link util.fetch}.
             * @typedef FetchOptions
             * @type {Object}
             * @property {boolean} [binary=false] Whether expecting a binary response
             * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest
             */

            /**
             * Fetches the contents of a file.
             * @memberof util
             * @param {string} filename File path or url
             * @param {FetchOptions} options Fetch options
             * @param {FetchCallback} callback Callback function
             * @returns {undefined}
             */
            function fetch(filename, options, callback) {

                if (typeof options === "function") {
                    callback = options;
                    options = {};
                } else if (!options) {
                    options = {};
                }
                if (filename.startsWith("syntax =")) {
                    callback(null, filename);
                    return;
                }
                if (!callback) return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this

                // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.
                if (!options.xhr && fs && fs.readFile) return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
                    return err && typeof XMLHttpRequest !== "undefined" ? fetch.xhr(filename, options, callback) : err ? callback(err) : callback(null, options.binary ? contents : contents.toString("utf8"));
                });

                // use the XHR version otherwise.
                return fetch.xhr(filename, options, callback);
            }

            /**
             * Fetches the contents of a file.
             * @name util.fetch
             * @function
             * @param {string} path File path or url
             * @param {FetchCallback} callback Callback function
             * @returns {undefined}
             * @variation 2
             */

            /**
             * Fetches the contents of a file.
             * @name util.fetch
             * @function
             * @param {string} path File path or url
             * @param {FetchOptions} [options] Fetch options
             * @returns {Promise<string|Uint8Array>} Promise
             * @variation 3
             */

            /**/
            fetch.xhr = function fetch_xhr(filename, options, callback) {
                var xhr = new XMLHttpRequest();
                xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {

                    if (xhr.readyState !== 4) return undefined;

                    // local cors security errors return status 0 / empty string, too. afaik this cannot be
                    // reliably distinguished from an actually empty file for security reasons. feel free
                    // to send a pull request if you are aware of a solution.
                    if (xhr.status !== 0 && xhr.status !== 200) return callback(Error("status " + xhr.status));

                    // if binary data is expected, make sure that some sort of array is returned, even if
                    // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.
                    if (options.binary) {
                        var buffer = xhr.response;
                        if (!buffer) {
                            buffer = [];
                            for (var i = 0; i < xhr.responseText.length; ++i) {
                                buffer.push(xhr.responseText.charCodeAt(i) & 255);
                            }
                        }
                        return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
                    }
                    return callback(null, xhr.responseText);
                };

                if (options.binary) {
                    // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers
                    if ("overrideMimeType" in xhr) xhr.overrideMimeType("text/plain; charset=x-user-defined");
                    xhr.responseType = "arraybuffer";
                }

                xhr.open("GET", filename);
                xhr.send();
            };
        }, { "1": 1, "7": 7 }], 6: [function (_require, module, exports) {
            "use strict";

            module.exports = factory(factory);

            /**
             * Reads / writes floats / doubles from / to buffers.
             * @name util.float
             * @namespace
             */

            /**
             * Writes a 32 bit float to a buffer using little endian byte order.
             * @name util.float.writeFloatLE
             * @function
             * @param {number} val Value to write
             * @param {Uint8Array} buf Target buffer
             * @param {number} pos Target buffer offset
             * @returns {undefined}
             */

            /**
             * Writes a 32 bit float to a buffer using big endian byte order.
             * @name util.float.writeFloatBE
             * @function
             * @param {number} val Value to write
             * @param {Uint8Array} buf Target buffer
             * @param {number} pos Target buffer offset
             * @returns {undefined}
             */

            /**
             * Reads a 32 bit float from a buffer using little endian byte order.
             * @name util.float.readFloatLE
             * @function
             * @param {Uint8Array} buf Source buffer
             * @param {number} pos Source buffer offset
             * @returns {number} Value read
             */

            /**
             * Reads a 32 bit float from a buffer using big endian byte order.
             * @name util.float.readFloatBE
             * @function
             * @param {Uint8Array} buf Source buffer
             * @param {number} pos Source buffer offset
             * @returns {number} Value read
             */

            /**
             * Writes a 64 bit double to a buffer using little endian byte order.
             * @name util.float.writeDoubleLE
             * @function
             * @param {number} val Value to write
             * @param {Uint8Array} buf Target buffer
             * @param {number} pos Target buffer offset
             * @returns {undefined}
             */

            /**
             * Writes a 64 bit double to a buffer using big endian byte order.
             * @name util.float.writeDoubleBE
             * @function
             * @param {number} val Value to write
             * @param {Uint8Array} buf Target buffer
             * @param {number} pos Target buffer offset
             * @returns {undefined}
             */

            /**
             * Reads a 64 bit double from a buffer using little endian byte order.
             * @name util.float.readDoubleLE
             * @function
             * @param {Uint8Array} buf Source buffer
             * @param {number} pos Source buffer offset
             * @returns {number} Value read
             */

            /**
             * Reads a 64 bit double from a buffer using big endian byte order.
             * @name util.float.readDoubleBE
             * @function
             * @param {Uint8Array} buf Source buffer
             * @param {number} pos Source buffer offset
             * @returns {number} Value read
             */

            // Factory function for the purpose of node-based testing in modified global environments
            function factory(exports) {

                // float: typed array
                if (typeof Float32Array !== "undefined") (function () {

                    var f32 = new Float32Array([-0]),
                        f8b = new Uint8Array(f32.buffer),
                        le = f8b[3] === 128;

                    function writeFloat_f32_cpy(val, buf, pos) {
                        f32[0] = val;
                        buf[pos] = f8b[0];
                        buf[pos + 1] = f8b[1];
                        buf[pos + 2] = f8b[2];
                        buf[pos + 3] = f8b[3];
                    }

                    function writeFloat_f32_rev(val, buf, pos) {
                        f32[0] = val;
                        buf[pos] = f8b[3];
                        buf[pos + 1] = f8b[2];
                        buf[pos + 2] = f8b[1];
                        buf[pos + 3] = f8b[0];
                    }

                    /* istanbul ignore next */
                    exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
                    /* istanbul ignore next */
                    exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

                    function readFloat_f32_cpy(buf, pos) {
                        f8b[0] = buf[pos];
                        f8b[1] = buf[pos + 1];
                        f8b[2] = buf[pos + 2];
                        f8b[3] = buf[pos + 3];
                        return f32[0];
                    }

                    function readFloat_f32_rev(buf, pos) {
                        f8b[3] = buf[pos];
                        f8b[2] = buf[pos + 1];
                        f8b[1] = buf[pos + 2];
                        f8b[0] = buf[pos + 3];
                        return f32[0];
                    }

                    /* istanbul ignore next */
                    exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
                    /* istanbul ignore next */
                    exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

                    // float: ieee754
                })();else (function () {

                    function writeFloat_ieee754(writeUint, val, buf, pos) {
                        var sign = val < 0 ? 1 : 0;
                        if (sign) val = -val;
                        if (val === 0) writeUint(1 / val > 0 ? /* positive */0 : /* negative 0 */2147483648, buf, pos);else if (isNaN(val)) writeUint(2143289344, buf, pos);else if (val > 3.4028234663852886e+38) // +-Infinity
                            writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);else if (val < 1.1754943508222875e-38) // denormal
                            writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);else {
                            var exponent = Math.floor(Math.log(val) / Math.LN2),
                                mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
                        }
                    }

                    exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
                    exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

                    function readFloat_ieee754(readUint, buf, pos) {
                        var uint = readUint(buf, pos),
                            sign = (uint >> 31) * 2 + 1,
                            exponent = uint >>> 23 & 255,
                            mantissa = uint & 8388607;
                        return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 // denormal
                        ? sign * 1.401298464324817e-45 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
                    }

                    exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
                    exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
                })();

                // double: typed array
                if (typeof Float64Array !== "undefined") (function () {

                    var f64 = new Float64Array([-0]),
                        f8b = new Uint8Array(f64.buffer),
                        le = f8b[7] === 128;

                    function writeDouble_f64_cpy(val, buf, pos) {
                        f64[0] = val;
                        buf[pos] = f8b[0];
                        buf[pos + 1] = f8b[1];
                        buf[pos + 2] = f8b[2];
                        buf[pos + 3] = f8b[3];
                        buf[pos + 4] = f8b[4];
                        buf[pos + 5] = f8b[5];
                        buf[pos + 6] = f8b[6];
                        buf[pos + 7] = f8b[7];
                    }

                    function writeDouble_f64_rev(val, buf, pos) {
                        f64[0] = val;
                        buf[pos] = f8b[7];
                        buf[pos + 1] = f8b[6];
                        buf[pos + 2] = f8b[5];
                        buf[pos + 3] = f8b[4];
                        buf[pos + 4] = f8b[3];
                        buf[pos + 5] = f8b[2];
                        buf[pos + 6] = f8b[1];
                        buf[pos + 7] = f8b[0];
                    }

                    /* istanbul ignore next */
                    exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
                    /* istanbul ignore next */
                    exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

                    function readDouble_f64_cpy(buf, pos) {
                        f8b[0] = buf[pos];
                        f8b[1] = buf[pos + 1];
                        f8b[2] = buf[pos + 2];
                        f8b[3] = buf[pos + 3];
                        f8b[4] = buf[pos + 4];
                        f8b[5] = buf[pos + 5];
                        f8b[6] = buf[pos + 6];
                        f8b[7] = buf[pos + 7];
                        return f64[0];
                    }

                    function readDouble_f64_rev(buf, pos) {
                        f8b[7] = buf[pos];
                        f8b[6] = buf[pos + 1];
                        f8b[5] = buf[pos + 2];
                        f8b[4] = buf[pos + 3];
                        f8b[3] = buf[pos + 4];
                        f8b[2] = buf[pos + 5];
                        f8b[1] = buf[pos + 6];
                        f8b[0] = buf[pos + 7];
                        return f64[0];
                    }

                    /* istanbul ignore next */
                    exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
                    /* istanbul ignore next */
                    exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

                    // double: ieee754
                })();else (function () {

                    function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
                        var sign = val < 0 ? 1 : 0;
                        if (sign) val = -val;
                        if (val === 0) {
                            writeUint(0, buf, pos + off0);
                            writeUint(1 / val > 0 ? /* positive */0 : /* negative 0 */2147483648, buf, pos + off1);
                        } else if (isNaN(val)) {
                            writeUint(0, buf, pos + off0);
                            writeUint(2146959360, buf, pos + off1);
                        } else if (val > 1.7976931348623157e+308) {
                            // +-Infinity
                            writeUint(0, buf, pos + off0);
                            writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
                        } else {
                            var mantissa;
                            if (val < 2.2250738585072014e-308) {
                                // denormal
                                mantissa = val / 5e-324;
                                writeUint(mantissa >>> 0, buf, pos + off0);
                                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                            } else {
                                var exponent = Math.floor(Math.log(val) / Math.LN2);
                                if (exponent === 1024) exponent = 1023;
                                mantissa = val * Math.pow(2, -exponent);
                                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                            }
                        }
                    }

                    exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
                    exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

                    function readDouble_ieee754(readUint, off0, off1, buf, pos) {
                        var lo = readUint(buf, pos + off0),
                            hi = readUint(buf, pos + off1);
                        var sign = (hi >> 31) * 2 + 1,
                            exponent = hi >>> 20 & 2047,
                            mantissa = 4294967296 * (hi & 1048575) + lo;
                        return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 // denormal
                        ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
                    }

                    exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
                    exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
                })();

                return exports;
            }

            // uint helpers

            function writeUintLE(val, buf, pos) {
                buf[pos] = val & 255;
                buf[pos + 1] = val >>> 8 & 255;
                buf[pos + 2] = val >>> 16 & 255;
                buf[pos + 3] = val >>> 24;
            }

            function writeUintBE(val, buf, pos) {
                buf[pos] = val >>> 24;
                buf[pos + 1] = val >>> 16 & 255;
                buf[pos + 2] = val >>> 8 & 255;
                buf[pos + 3] = val & 255;
            }

            function readUintLE(buf, pos) {
                return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
            }

            function readUintBE(buf, pos) {
                return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
            }
        }, {}], 7: [function (_require, module, exports) {
            "use strict";

            module.exports = inquire;

            /**
             * _requires a module only if available.
             * @memberof util
             * @param {string} moduleName Module to _require
             * @returns {?Object} _required module if available and not empty, otherwise `null`
             */
            function inquire(moduleName) {
                try {
                    var mod = eval("quire".replace(/^/, "re"))(moduleName); // eslint-disable-line no-eval
                    if (mod && (mod.length || Object.keys(mod).length)) return mod;
                } catch (e) {} // eslint-disable-line no-empty
                return null;
            }
        }, {}], 8: [function (_require, module, exports) {
            "use strict";

            /**
             * A minimal path module to resolve Unix, Windows and URL paths alike.
             * @memberof util
             * @namespace
             */

            var path = exports;

            var isAbsolute =
            /**
             * Tests if the specified path is absolute.
             * @param {string} path Path to test
             * @returns {boolean} `true` if path is absolute
             */
            path.isAbsolute = function isAbsolute(path) {
                return (/^(?:\/|\w+:)/.test(path)
                );
            };

            var normalize =
            /**
             * Normalizes the specified path.
             * @param {string} path Path to normalize
             * @returns {string} Normalized path
             */
            path.normalize = function normalize(path) {
                path = path.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
                var parts = path.split("/"),
                    absolute = isAbsolute(path),
                    prefix = "";
                if (absolute) prefix = parts.shift() + "/";
                for (var i = 0; i < parts.length;) {
                    if (parts[i] === "..") {
                        if (i > 0 && parts[i - 1] !== "..") parts.splice(--i, 2);else if (absolute) parts.splice(i, 1);else ++i;
                    } else if (parts[i] === ".") parts.splice(i, 1);else ++i;
                }
                return prefix + parts.join("/");
            };

            /**
             * Resolves the specified include path against the specified origin path.
             * @param {string} originPath Path to the origin file
             * @param {string} includePath Include path relative to origin path
             * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized
             * @returns {string} Path to the include file
             */
            path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
                if (!alreadyNormalized) includePath = normalize(includePath);
                if (isAbsolute(includePath)) return includePath;
                if (!alreadyNormalized) originPath = normalize(originPath);
                return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
            };
        }, {}], 9: [function (_require, module, exports) {
            "use strict";

            module.exports = pool;

            /**
             * An allocator as used by {@link util.pool}.
             * @typedef PoolAllocator
             * @type {function}
             * @param {number} size Buffer size
             * @returns {Uint8Array} Buffer
             */

            /**
             * A slicer as used by {@link util.pool}.
             * @typedef PoolSlicer
             * @type {function}
             * @param {number} start Start offset
             * @param {number} end End offset
             * @returns {Uint8Array} Buffer slice
             * @this {Uint8Array}
             */

            /**
             * A general purpose buffer pool.
             * @memberof util
             * @function
             * @param {PoolAllocator} alloc Allocator
             * @param {PoolSlicer} slice Slicer
             * @param {number} [size=8192] Slab size
             * @returns {PoolAllocator} Pooled allocator
             */
            function pool(alloc, slice, size) {
                var SIZE = size || 8192;
                var MAX = SIZE >>> 1;
                var slab = null;
                var offset = SIZE;
                return function pool_alloc(size) {
                    if (size < 1 || size > MAX) return alloc(size);
                    if (offset + size > SIZE) {
                        slab = alloc(SIZE);
                        offset = 0;
                    }
                    var buf = slice.call(slab, offset, offset += size);
                    if (offset & 7) // align to 32 bit
                        offset = (offset | 7) + 1;
                    return buf;
                };
            }
        }, {}], 10: [function (_require, module, exports) {
            "use strict";

            /**
             * A minimal UTF8 implementation for number arrays.
             * @memberof util
             * @namespace
             */

            var utf8 = exports;

            /**
             * Calculates the UTF8 byte length of a string.
             * @param {string} string String
             * @returns {number} Byte length
             */
            utf8.length = function utf8_length(string) {
                var len = 0,
                    c = 0;
                for (var i = 0; i < string.length; ++i) {
                    c = string.charCodeAt(i);
                    if (c < 128) len += 1;else if (c < 2048) len += 2;else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
                        ++i;
                        len += 4;
                    } else len += 3;
                }
                return len;
            };

            /**
             * Reads UTF8 bytes as a string.
             * @param {Uint8Array} buffer Source buffer
             * @param {number} start Source start
             * @param {number} end Source end
             * @returns {string} String read
             */
            utf8.read = function utf8_read(buffer, start, end) {
                var len = end - start;
                if (len < 1) return "";
                var parts = null,
                    chunk = [],
                    i = 0,
                    // char offset
                t; // temporary
                while (start < end) {
                    t = buffer[start++];
                    if (t < 128) chunk[i++] = t;else if (t > 191 && t < 224) chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;else if (t > 239 && t < 365) {
                        t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
                        chunk[i++] = 0xD800 + (t >> 10);
                        chunk[i++] = 0xDC00 + (t & 1023);
                    } else chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
                    if (i > 8191) {
                        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
                        i = 0;
                    }
                }
                if (parts) {
                    if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
                    return parts.join("");
                }
                return String.fromCharCode.apply(String, chunk.slice(0, i));
            };

            /**
             * Writes a string as UTF8 bytes.
             * @param {string} string Source string
             * @param {Uint8Array} buffer Destination buffer
             * @param {number} offset Destination offset
             * @returns {number} Bytes written
             */
            utf8.write = function utf8_write(string, buffer, offset) {
                var start = offset,
                    c1,
                    // character 1
                c2; // character 2
                for (var i = 0; i < string.length; ++i) {
                    c1 = string.charCodeAt(i);
                    if (c1 < 128) {
                        buffer[offset++] = c1;
                    } else if (c1 < 2048) {
                        buffer[offset++] = c1 >> 6 | 192;
                        buffer[offset++] = c1 & 63 | 128;
                    } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
                        c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
                        ++i;
                        buffer[offset++] = c1 >> 18 | 240;
                        buffer[offset++] = c1 >> 12 & 63 | 128;
                        buffer[offset++] = c1 >> 6 & 63 | 128;
                        buffer[offset++] = c1 & 63 | 128;
                    } else {
                        buffer[offset++] = c1 >> 12 | 224;
                        buffer[offset++] = c1 >> 6 & 63 | 128;
                        buffer[offset++] = c1 & 63 | 128;
                    }
                }
                return offset - start;
            };
        }, {}], 11: [function (_require, module, exports) {
            "use strict";

            module.exports = common;

            var commonRe = /\/|\./;

            /**
             * Provides common type definitions.
             * Can also be used to provide additional google types or your own custom types.
             * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name
             * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition
             * @returns {undefined}
             * @property {INamespace} google/protobuf/any.proto Any
             * @property {INamespace} google/protobuf/duration.proto Duration
             * @property {INamespace} google/protobuf/empty.proto Empty
             * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue
             * @property {INamespace} google/protobuf/timestamp.proto Timestamp
             * @property {INamespace} google/protobuf/wrappers.proto Wrappers
             * @example
             * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)
             * protobuf.common("descriptor", descriptorJson);
             *
             * // manually provides a custom definition (uses my.foo namespace)
             * protobuf.common("my/foo/bar.proto", myFooBarJson);
             */
            function common(name, json) {
                if (!commonRe.test(name)) {
                    name = "google/protobuf/" + name + ".proto";
                    json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
                }
                common[name] = json;
            }

            // Not provided because of limited use (feel free to discuss or to provide yourself):
            //
            // google/protobuf/descriptor.proto
            // google/protobuf/field_mask.proto
            // google/protobuf/source_context.proto
            // google/protobuf/type.proto
            //
            // Stripped and pre-parsed versions of these non-bundled files are instead available as part of
            // the repository or package within the google/protobuf directory.

            common("any", {

                /**
                 * Properties of a google.protobuf.Any message.
                 * @interface IAny
                 * @type {Object}
                 * @property {string} [typeUrl]
                 * @property {Uint8Array} [bytes]
                 * @memberof common
                 */
                Any: {
                    fields: {
                        type_url: {
                            type: "string",
                            id: 1
                        },
                        value: {
                            type: "bytes",
                            id: 2
                        }
                    }
                }
            });

            var timeType;

            common("duration", {

                /**
                 * Properties of a google.protobuf.Duration message.
                 * @interface IDuration
                 * @type {Object}
                 * @property {number|Long} [seconds]
                 * @property {number} [nanos]
                 * @memberof common
                 */
                Duration: timeType = {
                    fields: {
                        seconds: {
                            type: "int64",
                            id: 1
                        },
                        nanos: {
                            type: "int32",
                            id: 2
                        }
                    }
                }
            });

            common("timestamp", {

                /**
                 * Properties of a google.protobuf.Timestamp message.
                 * @interface ITimestamp
                 * @type {Object}
                 * @property {number|Long} [seconds]
                 * @property {number} [nanos]
                 * @memberof common
                 */
                Timestamp: timeType
            });

            common("empty", {

                /**
                 * Properties of a google.protobuf.Empty message.
                 * @interface IEmpty
                 * @memberof common
                 */
                Empty: {
                    fields: {}
                }
            });

            common("struct", {

                /**
                 * Properties of a google.protobuf.Struct message.
                 * @interface IStruct
                 * @type {Object}
                 * @property {Object.<string,IValue>} [fields]
                 * @memberof common
                 */
                Struct: {
                    fields: {
                        fields: {
                            keyType: "string",
                            type: "Value",
                            id: 1
                        }
                    }
                },

                /**
                 * Properties of a google.protobuf.Value message.
                 * @interface IValue
                 * @type {Object}
                 * @property {string} [kind]
                 * @property {0} [nullValue]
                 * @property {number} [numberValue]
                 * @property {string} [stringValue]
                 * @property {boolean} [boolValue]
                 * @property {IStruct} [structValue]
                 * @property {IListValue} [listValue]
                 * @memberof common
                 */
                Value: {
                    oneofs: {
                        kind: {
                            oneof: ["nullValue", "numberValue", "stringValue", "boolValue", "structValue", "listValue"]
                        }
                    },
                    fields: {
                        nullValue: {
                            type: "NullValue",
                            id: 1
                        },
                        numberValue: {
                            type: "double",
                            id: 2
                        },
                        stringValue: {
                            type: "string",
                            id: 3
                        },
                        boolValue: {
                            type: "bool",
                            id: 4
                        },
                        structValue: {
                            type: "Struct",
                            id: 5
                        },
                        listValue: {
                            type: "ListValue",
                            id: 6
                        }
                    }
                },

                NullValue: {
                    values: {
                        NULL_VALUE: 0
                    }
                },

                /**
                 * Properties of a google.protobuf.ListValue message.
                 * @interface IListValue
                 * @type {Object}
                 * @property {Array.<IValue>} [values]
                 * @memberof common
                 */
                ListValue: {
                    fields: {
                        values: {
                            rule: "repeated",
                            type: "Value",
                            id: 1
                        }
                    }
                }
            });

            common("wrappers", {

                /**
                 * Properties of a google.protobuf.DoubleValue message.
                 * @interface IDoubleValue
                 * @type {Object}
                 * @property {number} [value]
                 * @memberof common
                 */
                DoubleValue: {
                    fields: {
                        value: {
                            type: "double",
                            id: 1
                        }
                    }
                },

                /**
                 * Properties of a google.protobuf.FloatValue message.
                 * @interface IFloatValue
                 * @type {Object}
                 * @property {number} [value]
                 * @memberof common
                 */
                FloatValue: {
                    fields: {
                        value: {
                            type: "float",
                            id: 1
                        }
                    }
                },

                /**
                 * Properties of a google.protobuf.Int64Value message.
                 * @interface IInt64Value
                 * @type {Object}
                 * @property {number|Long} [value]
                 * @memberof common
                 */
                Int64Value: {
                    fields: {
                        value: {
                            type: "int64",
                            id: 1
                        }
                    }
                },

                /**
                 * Properties of a google.protobuf.UInt64Value message.
                 * @interface IUInt64Value
                 * @type {Object}
                 * @property {number|Long} [value]
                 * @memberof common
                 */
                UInt64Value: {
                    fields: {
                        value: {
                            type: "uint64",
                            id: 1
                        }
                    }
                },

                /**
                 * Properties of a google.protobuf.Int32Value message.
                 * @interface IInt32Value
                 * @type {Object}
                 * @property {number} [value]
                 * @memberof common
                 */
                Int32Value: {
                    fields: {
                        value: {
                            type: "int32",
                            id: 1
                        }
                    }
                },

                /**
                 * Properties of a google.protobuf.UInt32Value message.
                 * @interface IUInt32Value
                 * @type {Object}
                 * @property {number} [value]
                 * @memberof common
                 */
                UInt32Value: {
                    fields: {
                        value: {
                            type: "uint32",
                            id: 1
                        }
                    }
                },

                /**
                 * Properties of a google.protobuf.BoolValue message.
                 * @interface IBoolValue
                 * @type {Object}
                 * @property {boolean} [value]
                 * @memberof common
                 */
                BoolValue: {
                    fields: {
                        value: {
                            type: "bool",
                            id: 1
                        }
                    }
                },

                /**
                 * Properties of a google.protobuf.StringValue message.
                 * @interface IStringValue
                 * @type {Object}
                 * @property {string} [value]
                 * @memberof common
                 */
                StringValue: {
                    fields: {
                        value: {
                            type: "string",
                            id: 1
                        }
                    }
                },

                /**
                 * Properties of a google.protobuf.BytesValue message.
                 * @interface IBytesValue
                 * @type {Object}
                 * @property {Uint8Array} [value]
                 * @memberof common
                 */
                BytesValue: {
                    fields: {
                        value: {
                            type: "bytes",
                            id: 1
                        }
                    }
                }
            });

            /**
             * Gets the root definition of the specified common proto file.
             *
             * Bundled definitions are:
             * - google/protobuf/any.proto
             * - google/protobuf/duration.proto
             * - google/protobuf/empty.proto
             * - google/protobuf/struct.proto
             * - google/protobuf/timestamp.proto
             * - google/protobuf/wrappers.proto
             *
             * @param {string} file Proto file name
             * @returns {INamespace|null} Root definition or `null` if not defined
             */
            common.get = function get(file) {
                return common[file] || null;
            };
        }, {}], 12: [function (_require, module, exports) {
            "use strict";
            /**
             * Runtime message from/to plain object converters.
             * @namespace
             */

            var converter = exports;

            var Enum = _require(15),
                util = _require(37);

            /**
             * Generates a partial value fromObject conveter.
             * @param {Codegen} gen Codegen instance
             * @param {Field} field Reflected field
             * @param {number} fieldIndex Field index
             * @param {string} prop Property reference
             * @returns {Codegen} Codegen instance
             * @ignore
             */
            function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
                /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
                if (field.resolvedType) {
                    if (field.resolvedType instanceof Enum) {
                        gen("switch(d%s){", prop);
                        for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
                            if (field.repeated && values[keys[i]] === field.typeDefault) gen("default:");
                            gen("case%j:", keys[i])("case %i:", values[keys[i]])("m%s=%j", prop, values[keys[i]])("break");
                        }gen("}");
                    } else gen("if(typeof d%s!==\"object\")", prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
                } else {
                    var isUnsigned = false;
                    switch (field.type) {
                        case "double":
                        case "float":
                            gen("m%s=Number(d%s)", prop, prop); // also catches "NaN", "Infinity"
                            break;
                        case "uint32":
                        case "fixed32":
                            gen("m%s=d%s>>>0", prop, prop);
                            break;
                        case "int32":
                        case "sint32":
                        case "sfixed32":
                            gen("m%s=d%s|0", prop, prop);
                            break;
                        case "uint64":
                            isUnsigned = true;
                        // eslint-disable-line no-fallthrough
                        case "int64":
                        case "sint64":
                        case "fixed64":
                        case "sfixed64":
                            gen("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)("else if(typeof d%s===\"string\")", prop)("m%s=parseInt(d%s,10)", prop, prop)("else if(typeof d%s===\"number\")", prop)("m%s=d%s", prop, prop)("else if(typeof d%s===\"object\")", prop)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
                            break;
                        case "bytes":
                            gen("if(typeof d%s===\"string\")", prop)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)("else if(d%s.length)", prop)("m%s=d%s", prop, prop);
                            break;
                        case "string":
                            gen("m%s=String(d%s)", prop, prop);
                            break;
                        case "bool":
                            gen("m%s=Boolean(d%s)", prop, prop);
                            break;
                        /* default: gen
                            ("m%s=d%s", prop, prop);
                            break; */
                    }
                }
                return gen;
                /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
            }

            /**
             * Generates a plain object to runtime message converter specific to the specified message type.
             * @param {Type} mtype Message type
             * @returns {Codegen} Codegen instance
             */
            converter.fromObject = function fromObject(mtype) {
                /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
                var fields = mtype.fieldsArray;
                var gen = util.codegen(["d"], mtype.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
                if (!fields.length) return gen("return new this.ctor");
                gen("var m=new this.ctor");
                for (var i = 0; i < fields.length; ++i) {
                    var field = fields[i].resolve(),
                        prop = util.safeProp(field.name);

                    // Map fields
                    if (field.map) {
                        gen("if(d%s){", prop)("if(typeof d%s!==\"object\")", prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s={}", prop)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
                        genValuePartial_fromObject(gen, field, /* not sorted */i, prop + "[ks[i]]")("}")("}");

                        // Repeated fields
                    } else if (field.repeated) {
                        gen("if(d%s){", prop)("if(!Array.isArray(d%s))", prop)("throw TypeError(%j)", field.fullName + ": array expected")("m%s=[]", prop)("for(var i=0;i<d%s.length;++i){", prop);
                        genValuePartial_fromObject(gen, field, /* not sorted */i, prop + "[i]")("}")("}");

                        // Non-repeated fields
                    } else {
                        if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)
                        ("if(d%s!=null){", prop); // !== undefined && !== null
                        genValuePartial_fromObject(gen, field, /* not sorted */i, prop);
                        if (!(field.resolvedType instanceof Enum)) gen("}");
                    }
                }return gen("return m");
                /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
            };

            /**
             * Generates a partial value toObject converter.
             * @param {Codegen} gen Codegen instance
             * @param {Field} field Reflected field
             * @param {number} fieldIndex Field index
             * @param {string} prop Property reference
             * @returns {Codegen} Codegen instance
             * @ignore
             */
            function genValuePartial_toObject(gen, field, fieldIndex, prop) {
                /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
                if (field.resolvedType) {
                    if (field.resolvedType instanceof Enum) gen("d%s=o.enums===String?types[%i].values[m%s]:m%s", prop, fieldIndex, prop, prop);else gen("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
                } else {
                    var isUnsigned = false;
                    switch (field.type) {
                        case "double":
                        case "float":
                            gen("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
                            break;
                        case "uint64":
                            isUnsigned = true;
                        // eslint-disable-line no-fallthrough
                        case "int64":
                        case "sint64":
                        case "fixed64":
                        case "sfixed64":
                            gen("if(typeof m%s===\"number\")", prop)("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)("else") // Long-like
                            ("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true" : "", prop);
                            break;
                        case "bytes":
                            gen("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
                            break;
                        default:
                            gen("d%s=m%s", prop, prop);
                            break;
                    }
                }
                return gen;
                /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
            }

            /**
             * Generates a runtime message to plain object converter specific to the specified message type.
             * @param {Type} mtype Message type
             * @returns {Codegen} Codegen instance
             */
            converter.toObject = function toObject(mtype) {
                /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
                var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
                if (!fields.length) return util.codegen()("return {}");
                var gen = util.codegen(["m", "o"], mtype.name + "$toObject")("if(!o)")("o={}")("var d={}");

                var repeatedFields = [],
                    mapFields = [],
                    normalFields = [],
                    i = 0;
                for (; i < fields.length; ++i) {
                    if (!fields[i].partOf) (fields[i].resolve().repeated ? repeatedFields : fields[i].map ? mapFields : normalFields).push(fields[i]);
                }if (repeatedFields.length) {
                    gen("if(o.arrays||o.defaults){");
                    for (i = 0; i < repeatedFields.length; ++i) {
                        gen("d%s=[]", util.safeProp(repeatedFields[i].name));
                    }gen("}");
                }

                if (mapFields.length) {
                    gen("if(o.objects||o.defaults){");
                    for (i = 0; i < mapFields.length; ++i) {
                        gen("d%s={}", util.safeProp(mapFields[i].name));
                    }gen("}");
                }

                if (normalFields.length) {
                    gen("if(o.defaults){");
                    for (i = 0; i < normalFields.length; ++i) {
                        var field = normalFields[i],
                            prop = util.safeProp(field.name);
                        if (field.resolvedType instanceof Enum) gen("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);else if (field.long) gen("if(util.Long){")("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)("}else")("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());else if (field.bytes) gen("d%s=o.bytes===String?%j:%s", prop, String.fromCharCode.apply(String, field.typeDefault), "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]");else gen("d%s=%j", prop, field.typeDefault); // also messages (=null)
                    }gen("}");
                }
                var hasKs2 = false;
                for (i = 0; i < fields.length; ++i) {
                    var field = fields[i],
                        index = mtype._fieldsArray.indexOf(field),
                        prop = util.safeProp(field.name);
                    if (field.map) {
                        if (!hasKs2) {
                            hasKs2 = true;gen("var ks2");
                        }gen("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)("d%s={}", prop)("for(var j=0;j<ks2.length;++j){");
                        genValuePartial_toObject(gen, field, /* sorted */index, prop + "[ks2[j]]")("}");
                    } else if (field.repeated) {
                        gen("if(m%s&&m%s.length){", prop, prop)("d%s=[]", prop)("for(var j=0;j<m%s.length;++j){", prop);
                        genValuePartial_toObject(gen, field, /* sorted */index, prop + "[j]")("}");
                    } else {
                        gen("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name); // !== undefined && !== null
                        genValuePartial_toObject(gen, field, /* sorted */index, prop);
                        if (field.partOf) gen("if(o.oneofs)")("d%s=%j", util.safeProp(field.partOf.name), field.name);
                    }
                    gen("}");
                }
                return gen("return d");
                /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
            };
        }, { "15": 15, "37": 37 }], 13: [function (_require, module, exports) {
            "use strict";

            module.exports = decoder;

            var Enum = _require(15),
                types = _require(36),
                util = _require(37);

            function missing(field) {
                return "missing _required '" + field.name + "'";
            }

            /**
             * Generates a decoder specific to the specified message type.
             * @param {Type} mtype Message type
             * @returns {Codegen} Codegen instance
             */
            function decoder(mtype) {
                /* eslint-disable no-unexpected-multiline */
                var gen = util.codegen(["r", "l"], mtype.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function (field) {
                    return field.map;
                }).length ? ",k" : ""))("while(r.pos<c){")("var t=r.uint32()");
                if (mtype.group) gen("if((t&7)===4)")("break");
                gen("switch(t>>>3){");

                var i = 0;
                for (; i < /* initializes */mtype.fieldsArray.length; ++i) {
                    var field = mtype._fieldsArray[i].resolve(),
                        type = field.resolvedType instanceof Enum ? "int32" : field.type,
                        ref = "m" + util.safeProp(field.name);gen("case %i:", field.id);

                    // Map fields
                    if (field.map) {
                        gen("r.skip().pos++") // assumes id 1 + key wireType
                        ("if(%s===util.emptyObject)", ref)("%s={}", ref)("k=r.%s()", field.keyType)("r.pos++"); // assumes id 2 + value wireType
                        if (types.long[field.keyType] !== undefined) {
                            if (types.basic[type] === undefined) gen("%s[typeof k===\"object\"?util.longToHash(k):k]=types[%i].decode(r,r.uint32())", ref, i); // can't be groups
                            else gen("%s[typeof k===\"object\"?util.longToHash(k):k]=r.%s()", ref, type);
                        } else {
                            if (types.basic[type] === undefined) gen("%s[k]=types[%i].decode(r,r.uint32())", ref, i); // can't be groups
                            else gen("%s[k]=r.%s()", ref, type);
                        }

                        // Repeated fields
                    } else if (field.repeated) {
                        gen("if(!(%s&&%s.length))", ref, ref)("%s=[]", ref);

                        // Packable (always check for forward and backward compatiblity)
                        if (types.packed[type] !== undefined) gen("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", ref, type)("}else");

                        // Non-packed
                        if (types.basic[type] === undefined) gen(field.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);else gen("%s.push(r.%s())", ref, type);

                        // Non-repeated
                    } else if (types.basic[type] === undefined) gen(field.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", ref, i);else gen("%s=r.%s()", ref, type);
                    gen("break");
                    // Unknown fields
                }gen("default:")("r.skipType(t&7)")("break")("}")("}");

                // Field presence
                for (i = 0; i < mtype._fieldsArray.length; ++i) {
                    var rfield = mtype._fieldsArray[i];
                    if (rfield._required) gen("if(!m.hasOwnProperty(%j))", rfield.name)("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
                }

                return gen("return m");
                /* eslint-enable no-unexpected-multiline */
            }
        }, { "15": 15, "36": 36, "37": 37 }], 14: [function (_require, module, exports) {
            "use strict";

            module.exports = encoder;

            var Enum = _require(15),
                types = _require(36),
                util = _require(37);

            /**
             * Generates a partial message type encoder.
             * @param {Codegen} gen Codegen instance
             * @param {Field} field Reflected field
             * @param {number} fieldIndex Field index
             * @param {string} ref Variable reference
             * @returns {Codegen} Codegen instance
             * @ignore
             */
            function genTypePartial(gen, field, fieldIndex, ref) {
                return field.resolvedType.group ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
            }

            /**
             * Generates an encoder specific to the specified message type.
             * @param {Type} mtype Message type
             * @returns {Codegen} Codegen instance
             */
            function encoder(mtype) {
                /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
                var gen = util.codegen(["m", "w"], mtype.name + "$encode")("if(!w)")("w=Writer.create()");

                var i, ref;

                // "when a message is serialized its known fields should be written sequentially by field number"
                var fields = /* initializes */mtype.fieldsArray.slice().sort(util.compareFieldsById);

                for (var i = 0; i < fields.length; ++i) {
                    var field = fields[i].resolve(),
                        index = mtype._fieldsArray.indexOf(field),
                        type = field.resolvedType instanceof Enum ? "int32" : field.type,
                        wireType = types.basic[type];
                    ref = "m" + util.safeProp(field.name);

                    // Map fields
                    if (field.map) {
                        gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name) // !== undefined && !== null
                        ("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
                        if (wireType === undefined) gen("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref); // can't be groups
                        else gen(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
                        gen("}")("}");

                        // Repeated fields
                    } else if (field.repeated) {
                        gen("if(%s!=null&&%s.length){", ref, ref); // !== undefined && !== null

                        // Packed repeated
                        if (field.packed && types.packed[type] !== undefined) {
                            gen("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", ref)("w.%s(%s[i])", type, ref)("w.ldelim()");

                            // Non-packed
                        } else {
                            gen("for(var i=0;i<%s.length;++i)", ref);
                            if (wireType === undefined) genTypePartial(gen, field, index, ref + "[i]");else gen("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);
                        }gen("}");

                        // Non-repeated
                    } else {
                        if (field.optional) gen("if(%s!=null&&m.hasOwnProperty(%j))", ref, field.name); // !== undefined && !== null

                        if (wireType === undefined) genTypePartial(gen, field, index, ref);else gen("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);
                    }
                }

                return gen("return w");
                /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
            }
        }, { "15": 15, "36": 36, "37": 37 }], 15: [function (_require, module, exports) {
            "use strict";

            module.exports = Enum;

            // extends ReflectionObject
            var ReflectionObject = _require(24);
            ((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";

            var Namespace = _require(23),
                util = _require(37);

            /**
             * Constructs a new enum instance.
             * @classdesc Reflected enum.
             * @extends ReflectionObject
             * @constructor
             * @param {string} name Unique name within its namespace
             * @param {Object.<string,number>} [values] Enum values as an object, by name
             * @param {Object.<string,*>} [options] Declared options
             */
            function Enum(name, values, options) {
                ReflectionObject.call(this, name, options);

                if (values && (typeof values === "undefined" ? "undefined" : _typeof(values)) !== "object") throw TypeError("values must be an object");

                /**
                 * Enum values by id.
                 * @type {Object.<number,string>}
                 */
                this.valuesById = {};

                /**
                 * Enum values by name.
                 * @type {Object.<string,number>}
                 */
                this.values = Object.create(this.valuesById); // toJSON, marker

                /**
                 * Value comment texts, if any.
                 * @type {Object.<string,string>}
                 */
                this.comments = {};

                /**
                 * Reserved ranges, if any.
                 * @type {Array.<number[]|string>}
                 */
                this.reserved = undefined; // toJSON

                // Note that values inherit valuesById on their prototype which makes them a TypeScript-
                // compatible enum. This is used by pbts to write actual enum definitions that work for
                // static and reflection code alike instead of emitting generic object definitions.

                if (values) for (var keys = Object.keys(values), i = 0; i < keys.length; ++i) {
                    if (typeof values[keys[i]] === "number") // use forward entries only
                        this.valuesById[this.values[keys[i]] = values[keys[i]]] = keys[i];
                }
            }

            /**
             * Enum descriptor.
             * @interface IEnum
             * @property {Object.<string,number>} values Enum values
             * @property {Object.<string,*>} [options] Enum options
             */

            /**
             * Constructs an enum from an enum descriptor.
             * @param {string} name Enum name
             * @param {IEnum} json Enum descriptor
             * @returns {Enum} Created enum
             * @throws {TypeError} If arguments are invalid
             */
            Enum.fromJSON = function fromJSON(name, json) {
                var enm = new Enum(name, json.values, json.options);
                enm.reserved = json.reserved;
                return enm;
            };

            /**
             * Converts this enum to an enum descriptor.
             * @returns {IEnum} Enum descriptor
             */
            Enum.prototype.toJSON = function toJSON() {
                return util.toObject(["options", this.options, "values", this.values, "reserved", this.reserved && this.reserved.length ? this.reserved : undefined]);
            };

            /**
             * Adds a value to this enum.
             * @param {string} name Value name
             * @param {number} id Value id
             * @param {string} [comment] Comment, if any
             * @returns {Enum} `this`
             * @throws {TypeError} If arguments are invalid
             * @throws {Error} If there is already a value with this name or id
             */
            Enum.prototype.add = function add(name, id, comment) {
                // utilized by the parser but not by .fromJSON

                if (!util.isString(name)) throw TypeError("name must be a string");

                if (!util.isInteger(id)) throw TypeError("id must be an integer");

                if (this.values[name] !== undefined) throw Error("duplicate name '" + name + "' in " + this);

                if (this.isReservedId(id)) throw Error("id " + id + " is reserved in " + this);

                if (this.isReservedName(name)) throw Error("name '" + name + "' is reserved in " + this);

                if (this.valuesById[id] !== undefined) {
                    if (!(this.options && this.options.allow_alias)) throw Error("duplicate id " + id + " in " + this);
                    this.values[name] = id;
                } else this.valuesById[this.values[name] = id] = name;

                this.comments[name] = comment || null;
                return this;
            };

            /**
             * Removes a value from this enum
             * @param {string} name Value name
             * @returns {Enum} `this`
             * @throws {TypeError} If arguments are invalid
             * @throws {Error} If `name` is not a name of this enum
             */
            Enum.prototype.remove = function remove(name) {

                if (!util.isString(name)) throw TypeError("name must be a string");

                var val = this.values[name];
                if (val == null) throw Error("name '" + name + "' does not exist in " + this);

                delete this.valuesById[val];
                delete this.values[name];
                delete this.comments[name];

                return this;
            };

            /**
             * Tests if the specified id is reserved.
             * @param {number} id Id to test
             * @returns {boolean} `true` if reserved, otherwise `false`
             */
            Enum.prototype.isReservedId = function isReservedId(id) {
                return Namespace.isReservedId(this.reserved, id);
            };

            /**
             * Tests if the specified name is reserved.
             * @param {string} name Name to test
             * @returns {boolean} `true` if reserved, otherwise `false`
             */
            Enum.prototype.isReservedName = function isReservedName(name) {
                return Namespace.isReservedName(this.reserved, name);
            };
        }, { "23": 23, "24": 24, "37": 37 }], 16: [function (_require, module, exports) {
            "use strict";

            module.exports = Field;

            // extends ReflectionObject
            var ReflectionObject = _require(24);
            ((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";

            var Enum = _require(15),
                types = _require(36),
                util = _require(37);

            var Type; // cyclic

            var ruleRe = /^_required|optional|repeated$/;

            /**
             * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
             * @name Field
             * @classdesc Reflected message field.
             * @extends FieldBase
             * @constructor
             * @param {string} name Unique name within its namespace
             * @param {number} id Unique id within its namespace
             * @param {string} type Value type
             * @param {string|Object.<string,*>} [rule="optional"] Field rule
             * @param {string|Object.<string,*>} [extend] Extended type if different from parent
             * @param {Object.<string,*>} [options] Declared options
             */

            /**
             * Constructs a field from a field descriptor.
             * @param {string} name Field name
             * @param {IField} json Field descriptor
             * @returns {Field} Created field
             * @throws {TypeError} If arguments are invalid
             */
            Field.fromJSON = function fromJSON(name, json) {
                return new Field(name, json.id, json.type, json.rule, json.extend, json.options);
            };

            /**
             * Not an actual constructor. Use {@link Field} instead.
             * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
             * @exports FieldBase
             * @extends ReflectionObject
             * @constructor
             * @param {string} name Unique name within its namespace
             * @param {number} id Unique id within its namespace
             * @param {string} type Value type
             * @param {string|Object.<string,*>} [rule="optional"] Field rule
             * @param {string|Object.<string,*>} [extend] Extended type if different from parent
             * @param {Object.<string,*>} [options] Declared options
             */
            function Field(name, id, type, rule, extend, options) {

                if (util.isObject(rule)) {
                    options = rule;
                    rule = extend = undefined;
                } else if (util.isObject(extend)) {
                    options = extend;
                    extend = undefined;
                }

                ReflectionObject.call(this, name, options);

                if (!util.isInteger(id) || id < 0) throw TypeError("id must be a non-negative integer");

                if (!util.isString(type)) throw TypeError("type must be a string");

                if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase())) throw TypeError("rule must be a string rule");

                if (extend !== undefined && !util.isString(extend)) throw TypeError("extend must be a string");

                /**
                 * Field rule, if any.
                 * @type {string|undefined}
                 */
                this.rule = rule && rule !== "optional" ? rule : undefined; // toJSON

                /**
                 * Field type.
                 * @type {string}
                 */
                this.type = type; // toJSON

                /**
                 * Unique field id.
                 * @type {number}
                 */
                this.id = id; // toJSON, marker

                /**
                 * Extended type if different from parent.
                 * @type {string|undefined}
                 */
                this.extend = extend || undefined; // toJSON

                /**
                 * Whether this field is _required.
                 * @type {boolean}
                 */
                this._required = rule === "_required";

                /**
                 * Whether this field is optional.
                 * @type {boolean}
                 */
                this.optional = !this._required;

                /**
                 * Whether this field is repeated.
                 * @type {boolean}
                 */
                this.repeated = rule === "repeated";

                /**
                 * Whether this field is a map or not.
                 * @type {boolean}
                 */
                this.map = false;

                /**
                 * Message this field belongs to.
                 * @type {Type|null}
                 */
                this.message = null;

                /**
                 * OneOf this field belongs to, if any,
                 * @type {OneOf|null}
                 */
                this.partOf = null;

                /**
                 * The field type's default value.
                 * @type {*}
                 */
                this.typeDefault = null;

                /**
                 * The field's default value on prototypes.
                 * @type {*}
                 */
                this.defaultValue = null;

                /**
                 * Whether this field's value should be treated as a long.
                 * @type {boolean}
                 */
                this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */false;

                /**
                 * Whether this field's value is a buffer.
                 * @type {boolean}
                 */
                this.bytes = type === "bytes";

                /**
                 * Resolved type if not a basic type.
                 * @type {Type|Enum|null}
                 */
                this.resolvedType = null;

                /**
                 * Sister-field within the extended type if a declaring extension field.
                 * @type {Field|null}
                 */
                this.extensionField = null;

                /**
                 * Sister-field within the declaring namespace if an extended field.
                 * @type {Field|null}
                 */
                this.declaringField = null;

                /**
                 * Internally remembers whether this field is packed.
                 * @type {boolean|null}
                 * @private
                 */
                this._packed = null;
            }

            /**
             * Determines whether this field is packed. Only relevant when repeated and working with proto2.
             * @name Field#packed
             * @type {boolean}
             * @readonly
             */
            Object.defineProperty(Field.prototype, "packed", {
                get: function get() {
                    // defaults to packed=true if not explicity set to false
                    if (this._packed === null) this._packed = this.getOption("packed") !== false;
                    return this._packed;
                }
            });

            /**
             * @override
             */
            Field.prototype.setOption = function setOption(name, value, ifNotSet) {
                if (name === "packed") // clear cached before setting
                    this._packed = null;
                return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
            };

            /**
             * Field descriptor.
             * @interface IField
             * @property {string} [rule="optional"] Field rule
             * @property {string} type Field type
             * @property {number} id Field id
             * @property {Object.<string,*>} [options] Field options
             */

            /**
             * Extension field descriptor.
             * @interface IExtensionField
             * @extends IField
             * @property {string} extend Extended type
             */

            /**
             * Converts this field to a field descriptor.
             * @returns {IField} Field descriptor
             */
            Field.prototype.toJSON = function toJSON() {
                return util.toObject(["rule", this.rule !== "optional" && this.rule || undefined, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options]);
            };

            /**
             * Resolves this field's type references.
             * @returns {Field} `this`
             * @throws {Error} If any reference cannot be resolved
             */
            Field.prototype.resolve = function resolve() {

                if (this.resolved) return this;

                if ((this.typeDefault = types.defaults[this.type]) === undefined) {
                    // if not a basic type, resolve it
                    this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
                    if (this.resolvedType instanceof Type) this.typeDefault = null;else // instanceof Enum
                        this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined
                }

                // use explicitly set default value if present
                if (this.options && this.options["default"] != null) {
                    this.typeDefault = this.options["default"];
                    if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string") this.typeDefault = this.resolvedType.values[this.typeDefault];
                }

                // remove unnecessary options
                if (this.options) {
                    if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum)) delete this.options.packed;
                    if (!Object.keys(this.options).length) this.options = undefined;
                }

                // convert to internal data type if necesssary
                if (this.long) {
                    this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");

                    /* istanbul ignore else */
                    if (Object.freeze) Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even _requires it)
                } else if (this.bytes && typeof this.typeDefault === "string") {
                    var buf;
                    if (util.base64.test(this.typeDefault)) util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);else util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
                    this.typeDefault = buf;
                }

                // take special care of maps and repeated fields
                if (this.map) this.defaultValue = util.emptyObject;else if (this.repeated) this.defaultValue = util.emptyArray;else this.defaultValue = this.typeDefault;

                // ensure proper value on prototype
                if (this.parent instanceof Type) this.parent.ctor.prototype[this.name] = this.defaultValue;

                return ReflectionObject.prototype.resolve.call(this);
            };

            /**
             * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
             * @typedef FieldDecorator
             * @type {function}
             * @param {Object} prototype Target prototype
             * @param {string} fieldName Field name
             * @returns {undefined}
             */

            /**
             * Field decorator (TypeScript).
             * @name Field.d
             * @function
             * @param {number} fieldId Field id
             * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|Object} fieldType Field type
             * @param {"optional"|"_required"|"repeated"} [fieldRule="optional"] Field rule
             * @param {T} [defaultValue] Default value
             * @returns {FieldDecorator} Decorator function
             * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]
             */
            Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {

                // submessage: decorate the submessage and use its name as the type
                if (typeof fieldType === "function") fieldType = util.decorateType(fieldType).name;

                // enum reference: create a reflected copy of the enum and keep reuseing it
                else if (fieldType && (typeof fieldType === "undefined" ? "undefined" : _typeof(fieldType)) === "object") fieldType = util.decorateEnum(fieldType).name;

                return function fieldDecorator(prototype, fieldName) {
                    util.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
                };
            };

            /**
             * Field decorator (TypeScript).
             * @name Field.d
             * @function
             * @param {number} fieldId Field id
             * @param {Constructor<T>|string} fieldType Field type
             * @param {"optional"|"_required"|"repeated"} [fieldRule="optional"] Field rule
             * @returns {FieldDecorator} Decorator function
             * @template T extends Message<T>
             * @variation 2
             */
            // like Field.d but without a default value

            Field._configure = function configure(Type_) {
                Type = Type_;
            };
        }, { "15": 15, "24": 24, "36": 36, "37": 37 }], 17: [function (_require, module, exports) {
            "use strict";

            var protobuf = module.exports = _require(18);

            protobuf.build = "light";

            /**
             * A node-style callback as used by {@link load} and {@link Root#load}.
             * @typedef LoadCallback
             * @type {function}
             * @param {Error|null} error Error, if any, otherwise `null`
             * @param {Root} [root] Root, if there hasn't been an error
             * @returns {undefined}
             */

            /**
             * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
             * @param {string|string[]} filename One or multiple files to load
             * @param {Root} root Root namespace, defaults to create a new one if omitted.
             * @param {LoadCallback} callback Callback function
             * @returns {undefined}
             * @see {@link Root#load}
             */
            function load(filename, root, callback) {
                if (typeof root === "function") {
                    callback = root;
                    root = new protobuf.Root();
                } else if (!root) root = new protobuf.Root();
                return root.load(filename, callback);
            }

            /**
             * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
             * @name load
             * @function
             * @param {string|string[]} filename One or multiple files to load
             * @param {LoadCallback} callback Callback function
             * @returns {undefined}
             * @see {@link Root#load}
             * @variation 2
             */
            // function load(filename:string, callback:LoadCallback):undefined

            /**
             * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
             * @name load
             * @function
             * @param {string|string[]} filename One or multiple files to load
             * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
             * @returns {Promise<Root>} Promise
             * @see {@link Root#load}
             * @variation 3
             */
            // function load(filename:string, [root:Root]):Promise<Root>

            protobuf.load = load;

            /**
             * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
             * @param {string|string[]} filename One or multiple files to load
             * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
             * @returns {Root} Root namespace
             * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
             * @see {@link Root#loadSync}
             */
            function loadSync(filename, root) {
                if (!root) root = new protobuf.Root();
                return root.loadSync(filename);
            }

            protobuf.loadSync = loadSync;

            // Serialization
            protobuf.encoder = _require(14);
            protobuf.decoder = _require(13);
            protobuf.verifier = _require(40);
            protobuf.converter = _require(12);

            // Reflection
            protobuf.ReflectionObject = _require(24);
            protobuf.Namespace = _require(23);
            protobuf.Root = _require(29);
            protobuf.Enum = _require(15);
            protobuf.Type = _require(35);
            protobuf.Field = _require(16);
            protobuf.OneOf = _require(25);
            protobuf.MapField = _require(20);
            protobuf.Service = _require(33);
            protobuf.Method = _require(22);

            // Runtime
            protobuf.Message = _require(21);
            protobuf.wrappers = _require(41);

            // Utility
            protobuf.types = _require(36);
            protobuf.util = _require(37);

            // Configure reflection
            protobuf.ReflectionObject._configure(protobuf.Root);
            protobuf.Namespace._configure(protobuf.Type, protobuf.Service);
            protobuf.Root._configure(protobuf.Type);
            protobuf.Field._configure(protobuf.Type);
        }, { "12": 12, "13": 13, "14": 14, "15": 15, "16": 16, "18": 18, "20": 20, "21": 21, "22": 22, "23": 23, "24": 24, "25": 25, "29": 29, "33": 33, "35": 35, "36": 36, "37": 37, "40": 40, "41": 41 }], 18: [function (_require, module, exports) {
            "use strict";

            var protobuf = exports;

            /**
             * Build type, one of `"full"`, `"light"` or `"minimal"`.
             * @name build
             * @type {string}
             * @const
             */
            protobuf.build = "minimal";

            // Serialization
            protobuf.Writer = _require(42);
            protobuf.BufferWriter = _require(43);
            protobuf.Reader = _require(27);
            protobuf.BufferReader = _require(28);

            // Utility
            protobuf.util = _require(39);
            protobuf.rpc = _require(31);
            protobuf.roots = _require(30);
            protobuf.configure = configure;

            /* istanbul ignore next */
            /**
             * Reconfigures the library according to the environment.
             * @returns {undefined}
             */
            function configure() {
                protobuf.Reader._configure(protobuf.BufferReader);
                protobuf.util._configure();
            }

            // Configure serialization
            protobuf.Writer._configure(protobuf.BufferWriter);
            configure();
        }, { "27": 27, "28": 28, "30": 30, "31": 31, "39": 39, "42": 42, "43": 43 }], 19: [function (_require, module, exports) {
            "use strict";

            var protobuf = module.exports = _require(17);

            protobuf.build = "full";

            // Parser
            protobuf.tokenize = _require(34);
            protobuf.parse = _require(26);
            protobuf.common = _require(11);

            // Configure parser
            protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);
        }, { "11": 11, "17": 17, "26": 26, "34": 34 }], 20: [function (_require, module, exports) {
            "use strict";

            module.exports = MapField;

            // extends Field
            var Field = _require(16);
            ((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";

            var types = _require(36),
                util = _require(37);

            /**
             * Constructs a new map field instance.
             * @classdesc Reflected map field.
             * @extends FieldBase
             * @constructor
             * @param {string} name Unique name within its namespace
             * @param {number} id Unique id within its namespace
             * @param {string} keyType Key type
             * @param {string} type Value type
             * @param {Object.<string,*>} [options] Declared options
             */
            function MapField(name, id, keyType, type, options) {
                Field.call(this, name, id, type, options);

                /* istanbul ignore if */
                if (!util.isString(keyType)) throw TypeError("keyType must be a string");

                /**
                 * Key type.
                 * @type {string}
                 */
                this.keyType = keyType; // toJSON, marker

                /**
                 * Resolved key type if not a basic type.
                 * @type {ReflectionObject|null}
                 */
                this.resolvedKeyType = null;

                // Overrides Field#map
                this.map = true;
            }

            /**
             * Map field descriptor.
             * @interface IMapField
             * @extends {IField}
             * @property {string} keyType Key type
             */

            /**
             * Extension map field descriptor.
             * @interface IExtensionMapField
             * @extends IMapField
             * @property {string} extend Extended type
             */

            /**
             * Constructs a map field from a map field descriptor.
             * @param {string} name Field name
             * @param {IMapField} json Map field descriptor
             * @returns {MapField} Created map field
             * @throws {TypeError} If arguments are invalid
             */
            MapField.fromJSON = function fromJSON(name, json) {
                return new MapField(name, json.id, json.keyType, json.type, json.options);
            };

            /**
             * Converts this map field to a map field descriptor.
             * @returns {IMapField} Map field descriptor
             */
            MapField.prototype.toJSON = function toJSON() {
                return util.toObject(["keyType", this.keyType, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options]);
            };

            /**
             * @override
             */
            MapField.prototype.resolve = function resolve() {
                if (this.resolved) return this;

                // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"
                if (types.mapKey[this.keyType] === undefined) throw Error("invalid key type: " + this.keyType);

                return Field.prototype.resolve.call(this);
            };

            /**
             * Map field decorator (TypeScript).
             * @name MapField.d
             * @function
             * @param {number} fieldId Field id
             * @param {"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"} fieldKeyType Field key type
             * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|Object|Constructor<{}>} fieldValueType Field value type
             * @returns {FieldDecorator} Decorator function
             * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }
             */
            MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {

                // submessage value: decorate the submessage and use its name as the type
                if (typeof fieldValueType === "function") fieldValueType = util.decorateType(fieldValueType).name;

                // enum reference value: create a reflected copy of the enum and keep reuseing it
                else if (fieldValueType && (typeof fieldValueType === "undefined" ? "undefined" : _typeof(fieldValueType)) === "object") fieldValueType = util.decorateEnum(fieldValueType).name;

                return function mapFieldDecorator(prototype, fieldName) {
                    util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
                };
            };
        }, { "16": 16, "36": 36, "37": 37 }], 21: [function (_require, module, exports) {
            "use strict";

            module.exports = Message;

            var util = _require(39);

            /**
             * Constructs a new message instance.
             * @classdesc Abstract runtime message.
             * @constructor
             * @param {Properties<T>} [properties] Properties to set
             * @template T extends object
             */
            function Message(properties) {
                // not used internally
                if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
                    this[keys[i]] = properties[keys[i]];
                }
            }

            /**
             * Reference to the reflected type.
             * @name Message.$type
             * @type {Type}
             * @readonly
             */

            /**
             * Reference to the reflected type.
             * @name Message#$type
             * @type {Type}
             * @readonly
             */

            /*eslint-disable valid-jsdoc*/

            /**
             * Creates a new message of this type using the specified properties.
             * @param {Object.<string,*>} [properties] Properties to set
             * @returns {Message<T>} Message instance
             * @template T extends Message<T>
             * @this Constructor<T>
             */
            Message.create = function create(properties) {
                return this.$type.create(properties);
            };

            /**
             * Encodes a message of this type.
             * @param {T|Object.<string,*>} message Message to encode
             * @param {Writer} [writer] Writer to use
             * @returns {Writer} Writer
             * @template T extends Message<T>
             * @this Constructor<T>
             */
            Message.encode = function encode(message, writer) {
                return this.$type.encode(message, writer);
            };

            /**
             * Encodes a message of this type preceeded by its length as a varint.
             * @param {T|Object.<string,*>} message Message to encode
             * @param {Writer} [writer] Writer to use
             * @returns {Writer} Writer
             * @template T extends Message<T>
             * @this Constructor<T>
             */
            Message.encodeDelimited = function encodeDelimited(message, writer) {
                return this.$type.encodeDelimited(message, writer);
            };

            /**
             * Decodes a message of this type.
             * @name Message.decode
             * @function
             * @param {Reader|Uint8Array} reader Reader or buffer to decode
             * @returns {T} Decoded message
             * @template T extends Message<T>
             * @this Constructor<T>
             */
            Message.decode = function decode(reader) {
                return this.$type.decode(reader);
            };

            /**
             * Decodes a message of this type preceeded by its length as a varint.
             * @name Message.decodeDelimited
             * @function
             * @param {Reader|Uint8Array} reader Reader or buffer to decode
             * @returns {T} Decoded message
             * @template T extends Message<T>
             * @this Constructor<T>
             */
            Message.decodeDelimited = function decodeDelimited(reader) {
                return this.$type.decodeDelimited(reader);
            };

            /**
             * Verifies a message of this type.
             * @name Message.verify
             * @function
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Message.verify = function verify(message) {
                return this.$type.verify(message);
            };

            /**
             * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object
             * @returns {T} Message instance
             * @template T extends Message<T>
             * @this Constructor<T>
             */
            Message.fromObject = function fromObject(object) {
                return this.$type.fromObject(object);
            };

            /**
             * Creates a plain object from a message of this type. Also converts values to other types if specified.
             * @param {T} message Message instance
             * @param {IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             * @template T extends Message<T>
             * @this Constructor<T>
             */
            Message.toObject = function toObject(message, options) {
                return this.$type.toObject(message, options);
            };

            /**
             * Converts this message to JSON.
             * @returns {Object.<string,*>} JSON object
             */
            Message.prototype.toJSON = function toJSON() {
                return this.$type.toObject(this, util.toJSONOptions);
            };

            /*eslint-enable valid-jsdoc*/
        }, { "39": 39 }], 22: [function (_require, module, exports) {
            "use strict";

            module.exports = Method;

            // extends ReflectionObject
            var ReflectionObject = _require(24);
            ((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";

            var util = _require(37);

            /**
             * Constructs a new service method instance.
             * @classdesc Reflected service method.
             * @extends ReflectionObject
             * @constructor
             * @param {string} name Method name
             * @param {string|undefined} type Method type, usually `"rpc"`
             * @param {string} requestType Request message type
             * @param {string} responseType Response message type
             * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed
             * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed
             * @param {Object.<string,*>} [options] Declared options
             */
            function Method(name, type, requestType, responseType, requestStream, responseStream, options) {

                /* istanbul ignore next */
                if (util.isObject(requestStream)) {
                    options = requestStream;
                    requestStream = responseStream = undefined;
                } else if (util.isObject(responseStream)) {
                    options = responseStream;
                    responseStream = undefined;
                }

                /* istanbul ignore if */
                if (!(type === undefined || util.isString(type))) throw TypeError("type must be a string");

                /* istanbul ignore if */
                if (!util.isString(requestType)) throw TypeError("requestType must be a string");

                /* istanbul ignore if */
                if (!util.isString(responseType)) throw TypeError("responseType must be a string");

                ReflectionObject.call(this, name, options);

                /**
                 * Method type.
                 * @type {string}
                 */
                this.type = type || "rpc"; // toJSON

                /**
                 * Request type.
                 * @type {string}
                 */
                this.requestType = requestType; // toJSON, marker

                /**
                 * Whether requests are streamed or not.
                 * @type {boolean|undefined}
                 */
                this.requestStream = requestStream ? true : undefined; // toJSON

                /**
                 * Response type.
                 * @type {string}
                 */
                this.responseType = responseType; // toJSON

                /**
                 * Whether responses are streamed or not.
                 * @type {boolean|undefined}
                 */
                this.responseStream = responseStream ? true : undefined; // toJSON

                /**
                 * Resolved request type.
                 * @type {Type|null}
                 */
                this.resolvedRequestType = null;

                /**
                 * Resolved response type.
                 * @type {Type|null}
                 */
                this.resolvedResponseType = null;
            }

            /**
             * Method descriptor.
             * @interface IMethod
             * @property {string} [type="rpc"] Method type
             * @property {string} requestType Request type
             * @property {string} responseType Response type
             * @property {boolean} [requestStream=false] Whether requests are streamed
             * @property {boolean} [responseStream=false] Whether responses are streamed
             * @property {Object.<string,*>} [options] Method options
             */

            /**
             * Constructs a method from a method descriptor.
             * @param {string} name Method name
             * @param {IMethod} json Method descriptor
             * @returns {Method} Created method
             * @throws {TypeError} If arguments are invalid
             */
            Method.fromJSON = function fromJSON(name, json) {
                return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options);
            };

            /**
             * Converts this method to a method descriptor.
             * @returns {IMethod} Method descriptor
             */
            Method.prototype.toJSON = function toJSON() {
                return util.toObject(["type", this.type !== "rpc" && /* istanbul ignore next */this.type || undefined, "requestType", this.requestType, "requestStream", this.requestStream, "responseType", this.responseType, "responseStream", this.responseStream, "options", this.options]);
            };

            /**
             * @override
             */
            Method.prototype.resolve = function resolve() {

                /* istanbul ignore if */
                if (this.resolved) return this;

                this.resolvedRequestType = this.parent.lookupType(this.requestType);
                this.resolvedResponseType = this.parent.lookupType(this.responseType);

                return ReflectionObject.prototype.resolve.call(this);
            };
        }, { "24": 24, "37": 37 }], 23: [function (_require, module, exports) {
            "use strict";

            module.exports = Namespace;

            // extends ReflectionObject
            var ReflectionObject = _require(24);
            ((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";

            var Enum = _require(15),
                Field = _require(16),
                util = _require(37);

            var Type, // cyclic
            Service; // "

            /**
             * Constructs a new namespace instance.
             * @name Namespace
             * @classdesc Reflected namespace.
             * @extends NamespaceBase
             * @constructor
             * @param {string} name Namespace name
             * @param {Object.<string,*>} [options] Declared options
             */

            /**
             * Constructs a namespace from JSON.
             * @memberof Namespace
             * @function
             * @param {string} name Namespace name
             * @param {Object.<string,*>} json JSON object
             * @returns {Namespace} Created namespace
             * @throws {TypeError} If arguments are invalid
             */
            Namespace.fromJSON = function fromJSON(name, json) {
                return new Namespace(name, json.options).addJSON(json.nested);
            };

            /**
             * Converts an array of reflection objects to JSON.
             * @memberof Namespace
             * @param {ReflectionObject[]} array Object array
             * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty
             */
            function arrayToJSON(array) {
                if (!(array && array.length)) return undefined;
                var obj = {};
                for (var i = 0; i < array.length; ++i) {
                    obj[array[i].name] = array[i].toJSON();
                }return obj;
            }

            Namespace.arrayToJSON = arrayToJSON;

            /**
             * Tests if the specified id is reserved.
             * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
             * @param {number} id Id to test
             * @returns {boolean} `true` if reserved, otherwise `false`
             */
            Namespace.isReservedId = function isReservedId(reserved, id) {
                if (reserved) for (var i = 0; i < reserved.length; ++i) {
                    if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] >= id) return true;
                }return false;
            };

            /**
             * Tests if the specified name is reserved.
             * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
             * @param {string} name Name to test
             * @returns {boolean} `true` if reserved, otherwise `false`
             */
            Namespace.isReservedName = function isReservedName(reserved, name) {
                if (reserved) for (var i = 0; i < reserved.length; ++i) {
                    if (reserved[i] === name) return true;
                }return false;
            };

            /**
             * Not an actual constructor. Use {@link Namespace} instead.
             * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.
             * @exports NamespaceBase
             * @extends ReflectionObject
             * @abstract
             * @constructor
             * @param {string} name Namespace name
             * @param {Object.<string,*>} [options] Declared options
             * @see {@link Namespace}
             */
            function Namespace(name, options) {
                ReflectionObject.call(this, name, options);

                /**
                 * Nested objects by name.
                 * @type {Object.<string,ReflectionObject>|undefined}
                 */
                this.nested = undefined; // toJSON

                /**
                 * Cached nested objects as an array.
                 * @type {ReflectionObject[]|null}
                 * @private
                 */
                this._nestedArray = null;
            }

            function clearCache(namespace) {
                namespace._nestedArray = null;
                return namespace;
            }

            /**
             * Nested objects of this namespace as an array for iteration.
             * @name NamespaceBase#nestedArray
             * @type {ReflectionObject[]}
             * @readonly
             */
            Object.defineProperty(Namespace.prototype, "nestedArray", {
                get: function get() {
                    return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
                }
            });

            /**
             * Namespace descriptor.
             * @interface INamespace
             * @property {Object.<string,*>} [options] Namespace options
             * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors
             */

            /**
             * Any extension field descriptor.
             * @typedef AnyExtensionField
             * @type {IExtensionField|IExtensionMapField}
             */

            /**
             * Any nested object descriptor.
             * @typedef AnyNestedObject
             * @type {IEnum|IType|IService|AnyExtensionField|INamespace}
             */
            // ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)

            /**
             * Converts this namespace to a namespace descriptor.
             * @returns {INamespace} Namespace descriptor
             */
            Namespace.prototype.toJSON = function toJSON() {
                return util.toObject(["options", this.options, "nested", arrayToJSON(this.nestedArray)]);
            };

            /**
             * Adds nested objects to this namespace from nested object descriptors.
             * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors
             * @returns {Namespace} `this`
             */
            Namespace.prototype.addJSON = function addJSON(nestedJson) {
                var ns = this;
                /* istanbul ignore else */
                if (nestedJson) {
                    for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
                        nested = nestedJson[names[i]];
                        ns.add( // most to least likely
                        (nested.fields !== undefined ? Type.fromJSON : nested.values !== undefined ? Enum.fromJSON : nested.methods !== undefined ? Service.fromJSON : nested.id !== undefined ? Field.fromJSON : Namespace.fromJSON)(names[i], nested));
                    }
                }
                return this;
            };

            /**
             * Gets the nested object of the specified name.
             * @param {string} name Nested object name
             * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist
             */
            Namespace.prototype.get = function get(name) {
                return this.nested && this.nested[name] || null;
            };

            /**
             * Gets the values of the nested {@link Enum|enum} of the specified name.
             * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
             * @param {string} name Nested enum name
             * @returns {Object.<string,number>} Enum values
             * @throws {Error} If there is no such enum
             */
            Namespace.prototype.getEnum = function getEnum(name) {
                if (this.nested && this.nested[name] instanceof Enum) return this.nested[name].values;
                throw Error("no such enum");
            };

            /**
             * Adds a nested object to this namespace.
             * @param {ReflectionObject} object Nested object to add
             * @returns {Namespace} `this`
             * @throws {TypeError} If arguments are invalid
             * @throws {Error} If there is already a nested object with this name
             */
            Namespace.prototype.add = function add(object) {

                if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace)) throw TypeError("object must be a valid nested object");

                if (!this.nested) this.nested = {};else {
                    var prev = this.get(object.name);
                    if (prev) {
                        if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
                            // replace plain namespace but keep existing nested elements and options
                            var nested = prev.nestedArray;
                            for (var i = 0; i < nested.length; ++i) {
                                object.add(nested[i]);
                            }this.remove(prev);
                            if (!this.nested) this.nested = {};
                            object.setOptions(prev.options, true);
                        } else throw Error("duplicate name '" + object.name + "' in " + this);
                    }
                }
                this.nested[object.name] = object;
                object.onAdd(this);
                return clearCache(this);
            };

            /**
             * Removes a nested object from this namespace.
             * @param {ReflectionObject} object Nested object to remove
             * @returns {Namespace} `this`
             * @throws {TypeError} If arguments are invalid
             * @throws {Error} If `object` is not a member of this namespace
             */
            Namespace.prototype.remove = function remove(object) {

                if (!(object instanceof ReflectionObject)) throw TypeError("object must be a ReflectionObject");
                if (object.parent !== this) throw Error(object + " is not a member of " + this);

                delete this.nested[object.name];
                if (!Object.keys(this.nested).length) this.nested = undefined;

                object.onRemove(this);
                return clearCache(this);
            };

            /**
             * Defines additial namespaces within this one if not yet existing.
             * @param {string|string[]} path Path to create
             * @param {*} [json] Nested types to create from JSON
             * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty
             */
            Namespace.prototype.define = function define(path, json) {

                if (util.isString(path)) path = path.split(".");else if (!Array.isArray(path)) throw TypeError("illegal path");
                if (path && path.length && path[0] === "") throw Error("path must be relative");

                var ptr = this;
                while (path.length > 0) {
                    var part = path.shift();
                    if (ptr.nested && ptr.nested[part]) {
                        ptr = ptr.nested[part];
                        if (!(ptr instanceof Namespace)) throw Error("path conflicts with non-namespace objects");
                    } else ptr.add(ptr = new Namespace(part));
                }
                if (json) ptr.addJSON(json);
                return ptr;
            };

            /**
             * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
             * @returns {Namespace} `this`
             */
            Namespace.prototype.resolveAll = function resolveAll() {
                var nested = this.nestedArray,
                    i = 0;
                while (i < nested.length) {
                    if (nested[i] instanceof Namespace) nested[i++].resolveAll();else nested[i++].resolve();
                }return this.resolve();
            };

            /**
             * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
             * @param {string|string[]} path Path to look up
             * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
             * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked
             * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
             */
            Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {

                /* istanbul ignore next */
                if (typeof filterTypes === "boolean") {
                    parentAlreadyChecked = filterTypes;
                    filterTypes = undefined;
                } else if (filterTypes && !Array.isArray(filterTypes)) filterTypes = [filterTypes];

                if (util.isString(path) && path.length) {
                    if (path === ".") return this.root;
                    path = path.split(".");
                } else if (!path.length) return this;

                // Start at root if path is absolute
                if (path[0] === "") return this.root.lookup(path.slice(1), filterTypes);

                // Test if the first part matches any nested object, and if so, traverse if path contains more
                var found = this.get(path[0]);
                if (found) {
                    if (path.length === 1) {
                        if (!filterTypes || filterTypes.indexOf(found.constructor) > -1) return found;
                    } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true))) return found;

                    // Otherwise try each nested namespace
                } else for (var i = 0; i < this.nestedArray.length; ++i) {
                    if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true))) return found;
                } // If there hasn't been a match, try again at the parent
                if (this.parent === null || parentAlreadyChecked) return null;
                return this.parent.lookup(path, filterTypes);
            };

            /**
             * Looks up the reflection object at the specified path, relative to this namespace.
             * @name NamespaceBase#lookup
             * @function
             * @param {string|string[]} path Path to look up
             * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked
             * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
             * @variation 2
             */
            // lookup(path: string, [parentAlreadyChecked: boolean])

            /**
             * Looks up the {@link Type|type} at the specified path, relative to this namespace.
             * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
             * @param {string|string[]} path Path to look up
             * @returns {Type} Looked up type
             * @throws {Error} If `path` does not point to a type
             */
            Namespace.prototype.lookupType = function lookupType(path) {
                var found = this.lookup(path, [Type]);
                if (!found) throw Error("no such type");
                return found;
            };

            /**
             * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
             * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
             * @param {string|string[]} path Path to look up
             * @returns {Enum} Looked up enum
             * @throws {Error} If `path` does not point to an enum
             */
            Namespace.prototype.lookupEnum = function lookupEnum(path) {
                var found = this.lookup(path, [Enum]);
                if (!found) throw Error("no such Enum '" + path + "' in " + this);
                return found;
            };

            /**
             * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
             * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
             * @param {string|string[]} path Path to look up
             * @returns {Type} Looked up type or enum
             * @throws {Error} If `path` does not point to a type or enum
             */
            Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
                var found = this.lookup(path, [Type, Enum]);
                if (!found) throw Error("no such Type or Enum '" + path + "' in " + this);
                return found;
            };

            /**
             * Looks up the {@link Service|service} at the specified path, relative to this namespace.
             * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
             * @param {string|string[]} path Path to look up
             * @returns {Service} Looked up service
             * @throws {Error} If `path` does not point to a service
             */
            Namespace.prototype.lookupService = function lookupService(path) {
                var found = this.lookup(path, [Service]);
                if (!found) throw Error("no such Service '" + path + "' in " + this);
                return found;
            };

            Namespace._configure = function (Type_, Service_) {
                Type = Type_;
                Service = Service_;
            };
        }, { "15": 15, "16": 16, "24": 24, "37": 37 }], 24: [function (_require, module, exports) {
            "use strict";

            module.exports = ReflectionObject;

            ReflectionObject.className = "ReflectionObject";

            var util = _require(37);

            var Root; // cyclic

            /**
             * Constructs a new reflection object instance.
             * @classdesc Base class of all reflection objects.
             * @constructor
             * @param {string} name Object name
             * @param {Object.<string,*>} [options] Declared options
             * @abstract
             */
            function ReflectionObject(name, options) {

                if (!util.isString(name)) throw TypeError("name must be a string");

                if (options && !util.isObject(options)) throw TypeError("options must be an object");

                /**
                 * Options.
                 * @type {Object.<string,*>|undefined}
                 */
                this.options = options; // toJSON

                /**
                 * Unique name within its namespace.
                 * @type {string}
                 */
                this.name = name;

                /**
                 * Parent namespace.
                 * @type {Namespace|null}
                 */
                this.parent = null;

                /**
                 * Whether already resolved or not.
                 * @type {boolean}
                 */
                this.resolved = false;

                /**
                 * Comment text, if any.
                 * @type {string|null}
                 */
                this.comment = null;

                /**
                 * Defining file name.
                 * @type {string|null}
                 */
                this.filename = null;
            }

            Object.defineProperties(ReflectionObject.prototype, {

                /**
                 * Reference to the root namespace.
                 * @name ReflectionObject#root
                 * @type {Root}
                 * @readonly
                 */
                root: {
                    get: function get() {
                        var ptr = this;
                        while (ptr.parent !== null) {
                            ptr = ptr.parent;
                        }return ptr;
                    }
                },

                /**
                 * Full name including leading dot.
                 * @name ReflectionObject#fullName
                 * @type {string}
                 * @readonly
                 */
                fullName: {
                    get: function get() {
                        var path = [this.name],
                            ptr = this.parent;
                        while (ptr) {
                            path.unshift(ptr.name);
                            ptr = ptr.parent;
                        }
                        return path.join(".");
                    }
                }
            });

            /**
             * Converts this reflection object to its descriptor representation.
             * @returns {Object.<string,*>} Descriptor
             * @abstract
             */
            ReflectionObject.prototype.toJSON = /* istanbul ignore next */function toJSON() {
                throw Error(); // not implemented, shouldn't happen
            };

            /**
             * Called when this object is added to a parent.
             * @param {ReflectionObject} parent Parent added to
             * @returns {undefined}
             */
            ReflectionObject.prototype.onAdd = function onAdd(parent) {
                if (this.parent && this.parent !== parent) this.parent.remove(this);
                this.parent = parent;
                this.resolved = false;
                var root = parent.root;
                if (root instanceof Root) root._handleAdd(this);
            };

            /**
             * Called when this object is removed from a parent.
             * @param {ReflectionObject} parent Parent removed from
             * @returns {undefined}
             */
            ReflectionObject.prototype.onRemove = function onRemove(parent) {
                var root = parent.root;
                if (root instanceof Root) root._handleRemove(this);
                this.parent = null;
                this.resolved = false;
            };

            /**
             * Resolves this objects type references.
             * @returns {ReflectionObject} `this`
             */
            ReflectionObject.prototype.resolve = function resolve() {
                if (this.resolved) return this;
                if (this.root instanceof Root) this.resolved = true; // only if part of a root
                return this;
            };

            /**
             * Gets an option value.
             * @param {string} name Option name
             * @returns {*} Option value or `undefined` if not set
             */
            ReflectionObject.prototype.getOption = function getOption(name) {
                if (this.options) return this.options[name];
                return undefined;
            };

            /**
             * Sets an option.
             * @param {string} name Option name
             * @param {*} value Option value
             * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set
             * @returns {ReflectionObject} `this`
             */
            ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
                if (!ifNotSet || !this.options || this.options[name] === undefined) (this.options || (this.options = {}))[name] = value;
                return this;
            };

            /**
             * Sets multiple options.
             * @param {Object.<string,*>} options Options to set
             * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set
             * @returns {ReflectionObject} `this`
             */
            ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
                if (options) for (var keys = Object.keys(options), i = 0; i < keys.length; ++i) {
                    this.setOption(keys[i], options[keys[i]], ifNotSet);
                }return this;
            };

            /**
             * Converts this instance to its string representation.
             * @returns {string} Class name[, space, full name]
             */
            ReflectionObject.prototype.toString = function toString() {
                var className = this.constructor.className,
                    fullName = this.fullName;
                if (fullName.length) return className + " " + fullName;
                return className;
            };

            ReflectionObject._configure = function (Root_) {
                Root = Root_;
            };
        }, { "37": 37 }], 25: [function (_require, module, exports) {
            "use strict";

            module.exports = OneOf;

            // extends ReflectionObject
            var ReflectionObject = _require(24);
            ((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";

            var Field = _require(16),
                util = _require(37);

            /**
             * Constructs a new oneof instance.
             * @classdesc Reflected oneof.
             * @extends ReflectionObject
             * @constructor
             * @param {string} name Oneof name
             * @param {string[]|Object.<string,*>} [fieldNames] Field names
             * @param {Object.<string,*>} [options] Declared options
             */
            function OneOf(name, fieldNames, options) {
                if (!Array.isArray(fieldNames)) {
                    options = fieldNames;
                    fieldNames = undefined;
                }
                ReflectionObject.call(this, name, options);

                /* istanbul ignore if */
                if (!(fieldNames === undefined || Array.isArray(fieldNames))) throw TypeError("fieldNames must be an Array");

                /**
                 * Field names that belong to this oneof.
                 * @type {string[]}
                 */
                this.oneof = fieldNames || []; // toJSON, marker

                /**
                 * Fields that belong to this oneof as an array for iteration.
                 * @type {Field[]}
                 * @readonly
                 */
                this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent
            }

            /**
             * Oneof descriptor.
             * @interface IOneOf
             * @property {Array.<string>} oneof Oneof field names
             * @property {Object.<string,*>} [options] Oneof options
             */

            /**
             * Constructs a oneof from a oneof descriptor.
             * @param {string} name Oneof name
             * @param {IOneOf} json Oneof descriptor
             * @returns {OneOf} Created oneof
             * @throws {TypeError} If arguments are invalid
             */
            OneOf.fromJSON = function fromJSON(name, json) {
                return new OneOf(name, json.oneof, json.options);
            };

            /**
             * Converts this oneof to a oneof descriptor.
             * @returns {IOneOf} Oneof descriptor
             */
            OneOf.prototype.toJSON = function toJSON() {
                return util.toObject(["options", this.options, "oneof", this.oneof]);
            };

            /**
             * Adds the fields of the specified oneof to the parent if not already done so.
             * @param {OneOf} oneof The oneof
             * @returns {undefined}
             * @inner
             * @ignore
             */
            function addFieldsToParent(oneof) {
                if (oneof.parent) for (var i = 0; i < oneof.fieldsArray.length; ++i) {
                    if (!oneof.fieldsArray[i].parent) oneof.parent.add(oneof.fieldsArray[i]);
                }
            }

            /**
             * Adds a field to this oneof and removes it from its current parent, if any.
             * @param {Field} field Field to add
             * @returns {OneOf} `this`
             */
            OneOf.prototype.add = function add(field) {

                /* istanbul ignore if */
                if (!(field instanceof Field)) throw TypeError("field must be a Field");

                if (field.parent && field.parent !== this.parent) field.parent.remove(field);
                this.oneof.push(field.name);
                this.fieldsArray.push(field);
                field.partOf = this; // field.parent remains null
                addFieldsToParent(this);
                return this;
            };

            /**
             * Removes a field from this oneof and puts it back to the oneof's parent.
             * @param {Field} field Field to remove
             * @returns {OneOf} `this`
             */
            OneOf.prototype.remove = function remove(field) {

                /* istanbul ignore if */
                if (!(field instanceof Field)) throw TypeError("field must be a Field");

                var index = this.fieldsArray.indexOf(field);

                /* istanbul ignore if */
                if (index < 0) throw Error(field + " is not a member of " + this);

                this.fieldsArray.splice(index, 1);
                index = this.oneof.indexOf(field.name);

                /* istanbul ignore else */
                if (index > -1) // theoretical
                    this.oneof.splice(index, 1);

                field.partOf = null;
                return this;
            };

            /**
             * @override
             */
            OneOf.prototype.onAdd = function onAdd(parent) {
                ReflectionObject.prototype.onAdd.call(this, parent);
                var self = this;
                // Collect present fields
                for (var i = 0; i < this.oneof.length; ++i) {
                    var field = parent.get(this.oneof[i]);
                    if (field && !field.partOf) {
                        field.partOf = self;
                        self.fieldsArray.push(field);
                    }
                }
                // Add not yet present fields
                addFieldsToParent(this);
            };

            /**
             * @override
             */
            OneOf.prototype.onRemove = function onRemove(parent) {
                for (var i = 0, field; i < this.fieldsArray.length; ++i) {
                    if ((field = this.fieldsArray[i]).parent) field.parent.remove(field);
                }ReflectionObject.prototype.onRemove.call(this, parent);
            };

            /**
             * Decorator function as returned by {@link OneOf.d} (TypeScript).
             * @typedef OneOfDecorator
             * @type {function}
             * @param {Object} prototype Target prototype
             * @param {string} oneofName OneOf name
             * @returns {undefined}
             */

            /**
             * OneOf decorator (TypeScript).
             * @function
             * @param {...string} fieldNames Field names
             * @returns {OneOfDecorator} Decorator function
             * @template T extends string
             */
            OneOf.d = function decorateOneOf() {
                var fieldNames = new Array(arguments.length),
                    index = 0;
                while (index < arguments.length) {
                    fieldNames[index] = arguments[index++];
                }return function oneOfDecorator(prototype, oneofName) {
                    util.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));
                    Object.defineProperty(prototype, oneofName, {
                        get: util.oneOfGetter(fieldNames),
                        set: util.oneOfSetter(fieldNames)
                    });
                };
            };
        }, { "16": 16, "24": 24, "37": 37 }], 26: [function (_require, module, exports) {
            "use strict";

            module.exports = parse;

            parse.filename = null;
            parse.defaults = { keepCase: false };

            var tokenize = _require(34),
                Root = _require(29),
                Type = _require(35),
                Field = _require(16),
                MapField = _require(20),
                OneOf = _require(25),
                Enum = _require(15),
                Service = _require(33),
                Method = _require(22),
                types = _require(36),
                util = _require(37);

            var base10Re = /^[1-9][0-9]*$/,
                base10NegRe = /^-?[1-9][0-9]*$/,
                base16Re = /^0[x][0-9a-fA-F]+$/,
                base16NegRe = /^-?0[x][0-9a-fA-F]+$/,
                base8Re = /^0[0-7]+$/,
                base8NegRe = /^-?0[0-7]+$/,
                numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
                nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
                typeRefRe = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)+$/,
                fqTypeRefRe = /^(?:\.[a-zA-Z][a-zA-Z_0-9]*)+$/;

            /**
             * Result object returned from {@link parse}.
             * @interface IParserResult
             * @property {string|undefined} package Package name, if declared
             * @property {string[]|undefined} imports Imports, if any
             * @property {string[]|undefined} weakImports Weak imports, if any
             * @property {string|undefined} syntax Syntax, if specified (either `"proto2"` or `"proto3"`)
             * @property {Root} root Populated root instance
             */

            /**
             * Options modifying the behavior of {@link parse}.
             * @interface IParseOptions
             * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case
             */

            /**
             * Parses the given .proto source and returns an object with the parsed contents.
             * @param {string} source Source contents
             * @param {Root} root Root to populate
             * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
             * @returns {IParserResult} Parser result
             * @property {string} filename=null Currently processing file name for error reporting, if known
             * @property {IParseOptions} defaults Default {@link IParseOptions}
             */
            function parse(source, root, options) {
                /* eslint-disable callback-return */
                if (!(root instanceof Root)) {
                    options = root;
                    root = new Root();
                }
                if (!options) options = parse.defaults;

                var tn = tokenize(source),
                    next = tn.next,
                    push = tn.push,
                    peek = tn.peek,
                    skip = tn.skip,
                    cmnt = tn.cmnt;

                var head = true,
                    pkg,
                    imports,
                    weakImports,
                    syntax,
                    isProto3 = false;

                var ptr = root;

                var applyCase = options.keepCase ? function (name) {
                    return name;
                } : util.camelCase;

                /* istanbul ignore next */
                function illegal(token, name, insideTryCatch) {
                    var filename = parse.filename;
                    if (!insideTryCatch) parse.filename = null;
                    return Error("illegal " + (name || "token") + " '" + token + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
                }

                function readString() {
                    var values = [],
                        token;
                    do {
                        /* istanbul ignore if */
                        if ((token = next()) !== "\"" && token !== "'") throw illegal(token);

                        values.push(next());
                        skip(token);
                        token = peek();
                    } while (token === "\"" || token === "'");
                    return values.join("");
                }

                function readValue(acceptTypeRef) {
                    var token = next();
                    switch (token) {
                        case "'":
                        case "\"":
                            push(token);
                            return readString();
                        case "true":case "TRUE":
                            return true;
                        case "false":case "FALSE":
                            return false;
                    }
                    try {
                        return parseNumber(token, /* insideTryCatch */true);
                    } catch (e) {

                        /* istanbul ignore else */
                        if (acceptTypeRef && typeRefRe.test(token)) return token;

                        /* istanbul ignore next */
                        throw illegal(token, "value");
                    }
                }

                function readRanges(target, acceptStrings) {
                    var token, start;
                    do {
                        if (acceptStrings && ((token = peek()) === "\"" || token === "'")) target.push(readString());else target.push([start = parseId(next()), skip("to", true) ? parseId(next()) : start]);
                    } while (skip(",", true));
                    skip(";");
                }

                function parseNumber(token, insideTryCatch) {
                    var sign = 1;
                    if (token.charAt(0) === "-") {
                        sign = -1;
                        token = token.substring(1);
                    }
                    switch (token) {
                        case "inf":case "INF":case "Inf":
                            return sign * Infinity;
                        case "nan":case "NAN":case "Nan":case "NaN":
                            return NaN;
                        case "0":
                            return 0;
                    }
                    if (base10Re.test(token)) return sign * parseInt(token, 10);
                    if (base16Re.test(token)) return sign * parseInt(token, 16);
                    if (base8Re.test(token)) return sign * parseInt(token, 8);

                    /* istanbul ignore else */
                    if (numberRe.test(token)) return sign * parseFloat(token);

                    /* istanbul ignore next */
                    throw illegal(token, "number", insideTryCatch);
                }

                function parseId(token, acceptNegative) {
                    switch (token) {
                        case "max":case "MAX":case "Max":
                            return 536870911;
                        case "0":
                            return 0;
                    }

                    /* istanbul ignore if */
                    if (!acceptNegative && token.charAt(0) === "-") throw illegal(token, "id");

                    if (base10NegRe.test(token)) return parseInt(token, 10);
                    if (base16NegRe.test(token)) return parseInt(token, 16);

                    /* istanbul ignore else */
                    if (base8NegRe.test(token)) return parseInt(token, 8);

                    /* istanbul ignore next */
                    throw illegal(token, "id");
                }

                function parsePackage() {

                    /* istanbul ignore if */
                    if (pkg !== undefined) throw illegal("package");

                    pkg = next();

                    /* istanbul ignore if */
                    if (!typeRefRe.test(pkg)) throw illegal(pkg, "name");

                    ptr = ptr.define(pkg);
                    skip(";");
                }

                function parseImport() {
                    var token = peek();
                    var whichImports;
                    switch (token) {
                        case "weak":
                            whichImports = weakImports || (weakImports = []);
                            next();
                            break;
                        case "public":
                            next();
                        // eslint-disable-line no-fallthrough
                        default:
                            whichImports = imports || (imports = []);
                            break;
                    }
                    token = readString();
                    skip(";");
                    whichImports.push(token);
                }

                function parseSyntax() {
                    skip("=");
                    syntax = readString();
                    isProto3 = syntax === "proto3";

                    /* istanbul ignore if */
                    if (!isProto3 && syntax !== "proto2") throw illegal(syntax, "syntax");

                    skip(";");
                }

                function parseCommon(parent, token) {
                    switch (token) {

                        case "option":
                            parseOption(parent, token);
                            skip(";");
                            return true;

                        case "message":
                            parseType(parent, token);
                            return true;

                        case "enum":
                            parseEnum(parent, token);
                            return true;

                        case "service":
                            parseService(parent, token);
                            return true;

                        case "extend":
                            parseExtension(parent, token);
                            return true;
                    }
                    return false;
                }

                function ifBlock(obj, fnIf, fnElse) {
                    var trailingLine = tn.line;
                    if (obj) {
                        obj.comment = cmnt(); // try block-type comment
                        obj.filename = parse.filename;
                    }
                    if (skip("{", true)) {
                        var token;
                        while ((token = next()) !== "}") {
                            fnIf(token);
                        }skip(";", true);
                    } else {
                        if (fnElse) fnElse();
                        skip(";");
                        if (obj && typeof obj.comment !== "string") obj.comment = cmnt(trailingLine); // try line-type comment if no block
                    }
                }

                function parseType(parent, token) {

                    /* istanbul ignore if */
                    if (!nameRe.test(token = next())) throw illegal(token, "type name");

                    var type = new Type(token);
                    ifBlock(type, function parseType_block(token) {
                        if (parseCommon(type, token)) return;

                        switch (token) {

                            case "map":
                                parseMapField(type, token);
                                break;

                            case "_required":
                            case "optional":
                            case "repeated":
                                parseField(type, token);
                                break;

                            case "oneof":
                                parseOneOf(type, token);
                                break;

                            case "extensions":
                                readRanges(type.extensions || (type.extensions = []));
                                break;

                            case "reserved":
                                readRanges(type.reserved || (type.reserved = []), true);
                                break;

                            default:
                                /* istanbul ignore if */
                                if (!isProto3 || !typeRefRe.test(token)) throw illegal(token);

                                push(token);
                                parseField(type, "optional");
                                break;
                        }
                    });
                    parent.add(type);
                }

                function parseField(parent, rule, extend) {
                    var type = next();
                    if (type === "group") {
                        parseGroup(parent, rule);
                        return;
                    }

                    /* istanbul ignore if */
                    if (!typeRefRe.test(type)) throw illegal(type, "type");

                    var name = next();

                    /* istanbul ignore if */
                    if (!nameRe.test(name)) throw illegal(name, "name");

                    name = applyCase(name);
                    skip("=");

                    var field = new Field(name, parseId(next()), type, rule, extend);
                    ifBlock(field, function parseField_block(token) {

                        /* istanbul ignore else */
                        if (token === "option") {
                            parseOption(field, token);
                            skip(";");
                        } else throw illegal(token);
                    }, function parseField_line() {
                        parseInlineOptions(field);
                    });
                    parent.add(field);

                    // JSON defaults to packed=true if not set so we have to set packed=false explicity when
                    // parsing proto2 descriptors without the option, where applicable. This must be done for
                    // all known packable types and anything that could be an enum (= is not a basic type).
                    if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined)) field.setOption("packed", false, /* ifNotSet */true);
                }

                function parseGroup(parent, rule) {
                    var name = next();

                    /* istanbul ignore if */
                    if (!nameRe.test(name)) throw illegal(name, "name");

                    var fieldName = util.lcFirst(name);
                    if (name === fieldName) name = util.ucFirst(name);
                    skip("=");
                    var id = parseId(next());
                    var type = new Type(name);
                    type.group = true;
                    var field = new Field(fieldName, id, name, rule);
                    field.filename = parse.filename;
                    ifBlock(type, function parseGroup_block(token) {
                        switch (token) {

                            case "option":
                                parseOption(type, token);
                                skip(";");
                                break;

                            case "_required":
                            case "optional":
                            case "repeated":
                                parseField(type, token);
                                break;

                            /* istanbul ignore next */
                            default:
                                throw illegal(token); // there are no groups with proto3 semantics
                        }
                    });
                    parent.add(type).add(field);
                }

                function parseMapField(parent) {
                    skip("<");
                    var keyType = next();

                    /* istanbul ignore if */
                    if (types.mapKey[keyType] === undefined) throw illegal(keyType, "type");

                    skip(",");
                    var valueType = next();

                    /* istanbul ignore if */
                    if (!typeRefRe.test(valueType)) throw illegal(valueType, "type");

                    skip(">");
                    var name = next();

                    /* istanbul ignore if */
                    if (!nameRe.test(name)) throw illegal(name, "name");

                    skip("=");
                    var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
                    ifBlock(field, function parseMapField_block(token) {

                        /* istanbul ignore else */
                        if (token === "option") {
                            parseOption(field, token);
                            skip(";");
                        } else throw illegal(token);
                    }, function parseMapField_line() {
                        parseInlineOptions(field);
                    });
                    parent.add(field);
                }

                function parseOneOf(parent, token) {

                    /* istanbul ignore if */
                    if (!nameRe.test(token = next())) throw illegal(token, "name");

                    var oneof = new OneOf(applyCase(token));
                    ifBlock(oneof, function parseOneOf_block(token) {
                        if (token === "option") {
                            parseOption(oneof, token);
                            skip(";");
                        } else {
                            push(token);
                            parseField(oneof, "optional");
                        }
                    });
                    parent.add(oneof);
                }

                function parseEnum(parent, token) {

                    /* istanbul ignore if */
                    if (!nameRe.test(token = next())) throw illegal(token, "name");

                    var enm = new Enum(token);
                    ifBlock(enm, function parseEnum_block(token) {
                        switch (token) {
                            case "option":
                                parseOption(enm, token);
                                skip(";");
                                break;

                            case "reserved":
                                readRanges(enm.reserved || (enm.reserved = []), true);
                                break;

                            default:
                                parseEnumValue(enm, token);
                        }
                    });
                    parent.add(enm);
                }

                function parseEnumValue(parent, token) {

                    /* istanbul ignore if */
                    if (!nameRe.test(token)) throw illegal(token, "name");

                    skip("=");
                    var value = parseId(next(), true),
                        dummy = {};
                    ifBlock(dummy, function parseEnumValue_block(token) {

                        /* istanbul ignore else */
                        if (token === "option") {
                            parseOption(dummy, token); // skip
                            skip(";");
                        } else throw illegal(token);
                    }, function parseEnumValue_line() {
                        parseInlineOptions(dummy); // skip
                    });
                    parent.add(token, value, dummy.comment);
                }

                function parseOption(parent, token) {
                    var isCustom = skip("(", true);

                    /* istanbul ignore if */
                    if (!typeRefRe.test(token = next())) throw illegal(token, "name");

                    var name = token;
                    if (isCustom) {
                        skip(")");
                        name = "(" + name + ")";
                        token = peek();
                        if (fqTypeRefRe.test(token)) {
                            name += token;
                            next();
                        }
                    }
                    skip("=");
                    parseOptionValue(parent, name);
                }

                function parseOptionValue(parent, name) {
                    if (skip("{", true)) {
                        // { a: "foo" b { c: "bar" } }
                        do {
                            /* istanbul ignore if */
                            if (!nameRe.test(token = next())) throw illegal(token, "name");

                            if (peek() === "{") parseOptionValue(parent, name + "." + token);else {
                                skip(":");
                                if (peek() === "{") parseOptionValue(parent, name + "." + token);else setOption(parent, name + "." + token, readValue(true));
                            }
                        } while (!skip("}", true));
                    } else setOption(parent, name, readValue(true));
                    // Does not enforce a delimiter to be universal
                }

                function setOption(parent, name, value) {
                    if (parent.setOption) parent.setOption(name, value);
                }

                function parseInlineOptions(parent) {
                    if (skip("[", true)) {
                        do {
                            parseOption(parent, "option");
                        } while (skip(",", true));
                        skip("]");
                    }
                    return parent;
                }

                function parseService(parent, token) {

                    /* istanbul ignore if */
                    if (!nameRe.test(token = next())) throw illegal(token, "service name");

                    var service = new Service(token);
                    ifBlock(service, function parseService_block(token) {
                        if (parseCommon(service, token)) return;

                        /* istanbul ignore else */
                        if (token === "rpc") parseMethod(service, token);else throw illegal(token);
                    });
                    parent.add(service);
                }

                function parseMethod(parent, token) {
                    var type = token;

                    /* istanbul ignore if */
                    if (!nameRe.test(token = next())) throw illegal(token, "name");

                    var name = token,
                        requestType,
                        requestStream,
                        responseType,
                        responseStream;

                    skip("(");
                    if (skip("stream", true)) requestStream = true;

                    /* istanbul ignore if */
                    if (!typeRefRe.test(token = next())) throw illegal(token);

                    requestType = token;
                    skip(")");skip("returns");skip("(");
                    if (skip("stream", true)) responseStream = true;

                    /* istanbul ignore if */
                    if (!typeRefRe.test(token = next())) throw illegal(token);

                    responseType = token;
                    skip(")");

                    var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
                    ifBlock(method, function parseMethod_block(token) {

                        /* istanbul ignore else */
                        if (token === "option") {
                            parseOption(method, token);
                            skip(";");
                        } else throw illegal(token);
                    });
                    parent.add(method);
                }

                function parseExtension(parent, token) {

                    /* istanbul ignore if */
                    if (!typeRefRe.test(token = next())) throw illegal(token, "reference");

                    var reference = token;
                    ifBlock(null, function parseExtension_block(token) {
                        switch (token) {

                            case "_required":
                            case "repeated":
                            case "optional":
                                parseField(parent, token, reference);
                                break;

                            default:
                                /* istanbul ignore if */
                                if (!isProto3 || !typeRefRe.test(token)) throw illegal(token);
                                push(token);
                                parseField(parent, "optional", reference);
                                break;
                        }
                    });
                }

                var token;
                while ((token = next()) !== null) {
                    switch (token) {

                        case "package":

                            /* istanbul ignore if */
                            if (!head) throw illegal(token);

                            parsePackage();
                            break;

                        case "import":

                            /* istanbul ignore if */
                            if (!head) throw illegal(token);

                            parseImport();
                            break;

                        case "syntax":

                            /* istanbul ignore if */
                            if (!head) throw illegal(token);

                            parseSyntax();
                            break;

                        case "option":

                            /* istanbul ignore if */
                            if (!head) throw illegal(token);

                            parseOption(ptr, token);
                            skip(";");
                            break;

                        default:

                            /* istanbul ignore else */
                            if (parseCommon(ptr, token)) {
                                head = false;
                                continue;
                            }

                            /* istanbul ignore next */
                            throw illegal(token);
                    }
                }

                parse.filename = null;
                return {
                    "package": pkg,
                    "imports": imports,
                    weakImports: weakImports,
                    syntax: syntax,
                    root: root
                };
            }

            /**
             * Parses the given .proto source and returns an object with the parsed contents.
             * @name parse
             * @function
             * @param {string} source Source contents
             * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
             * @returns {IParserResult} Parser result
             * @property {string} filename=null Currently processing file name for error reporting, if known
             * @property {IParseOptions} defaults Default {@link IParseOptions}
             * @variation 2
             */
        }, { "15": 15, "16": 16, "20": 20, "22": 22, "25": 25, "29": 29, "33": 33, "34": 34, "35": 35, "36": 36, "37": 37 }], 27: [function (_require, module, exports) {
            "use strict";

            module.exports = Reader;

            var util = _require(39);

            var BufferReader; // cyclic

            var LongBits = util.LongBits,
                utf8 = util.utf8;

            /* istanbul ignore next */
            function indexOutOfRange(reader, writeLength) {
                return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
            }

            /**
             * Constructs a new reader instance using the specified buffer.
             * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
             * @constructor
             * @param {Uint8Array} buffer Buffer to read from
             */
            function Reader(buffer) {

                /**
                 * Read buffer.
                 * @type {Uint8Array}
                 */
                this.buf = buffer;

                /**
                 * Read buffer position.
                 * @type {number}
                 */
                this.pos = 0;

                /**
                 * Read buffer length.
                 * @type {number}
                 */
                this.len = buffer.length;
            }

            var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
                if (buffer instanceof Uint8Array || Array.isArray(buffer)) return new Reader(buffer);
                throw Error("illegal buffer");
            }
            /* istanbul ignore next */
            : function create_array(buffer) {
                if (Array.isArray(buffer)) return new Reader(buffer);
                throw Error("illegal buffer");
            };

            /**
             * Creates a new reader using the specified buffer.
             * @function
             * @param {Uint8Array|Buffer} buffer Buffer to read from
             * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
             * @throws {Error} If `buffer` is not a valid buffer
             */
            Reader.create = util.Buffer ? function create_buffer_setup(buffer) {
                return (Reader.create = function create_buffer(buffer) {
                    return util.Buffer.isBuffer(buffer) ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
                })(buffer);
            }
            /* istanbul ignore next */
            : create_array;

            Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */util.Array.prototype.slice;

            /**
             * Reads a varint as an unsigned 32 bit value.
             * @function
             * @returns {number} Value read
             */
            Reader.prototype.uint32 = function read_uint32_setup() {
                var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
                return function read_uint32() {
                    value = (this.buf[this.pos] & 127) >>> 0;if (this.buf[this.pos++] < 128) return value;
                    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;if (this.buf[this.pos++] < 128) return value;
                    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;if (this.buf[this.pos++] < 128) return value;
                    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;if (this.buf[this.pos++] < 128) return value;
                    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;if (this.buf[this.pos++] < 128) return value;

                    /* istanbul ignore if */
                    if ((this.pos += 5) > this.len) {
                        this.pos = this.len;
                        throw indexOutOfRange(this, 10);
                    }
                    return value;
                };
            }();

            /**
             * Reads a varint as a signed 32 bit value.
             * @returns {number} Value read
             */
            Reader.prototype.int32 = function read_int32() {
                return this.uint32() | 0;
            };

            /**
             * Reads a zig-zag encoded varint as a signed 32 bit value.
             * @returns {number} Value read
             */
            Reader.prototype.sint32 = function read_sint32() {
                var value = this.uint32();
                return value >>> 1 ^ -(value & 1) | 0;
            };

            /* eslint-disable no-invalid-this */

            function readLongVarint() {
                // tends to deopt with local vars for octet etc.
                var bits = new LongBits(0, 0);
                var i = 0;
                if (this.len - this.pos > 4) {
                    // fast route (lo)
                    for (; i < 4; ++i) {
                        // 1st..4th
                        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
                        if (this.buf[this.pos++] < 128) return bits;
                    }
                    // 5th
                    bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
                    bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
                    if (this.buf[this.pos++] < 128) return bits;
                    i = 0;
                } else {
                    for (; i < 3; ++i) {
                        /* istanbul ignore if */
                        if (this.pos >= this.len) throw indexOutOfRange(this);
                        // 1st..3th
                        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
                        if (this.buf[this.pos++] < 128) return bits;
                    }
                    // 4th
                    bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
                    return bits;
                }
                if (this.len - this.pos > 4) {
                    // fast route (hi)
                    for (; i < 5; ++i) {
                        // 6th..10th
                        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
                        if (this.buf[this.pos++] < 128) return bits;
                    }
                } else {
                    for (; i < 5; ++i) {
                        /* istanbul ignore if */
                        if (this.pos >= this.len) throw indexOutOfRange(this);
                        // 6th..10th
                        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
                        if (this.buf[this.pos++] < 128) return bits;
                    }
                }
                /* istanbul ignore next */
                throw Error("invalid varint encoding");
            }

            /* eslint-enable no-invalid-this */

            /**
             * Reads a varint as a signed 64 bit value.
             * @name Reader#int64
             * @function
             * @returns {Long} Value read
             */

            /**
             * Reads a varint as an unsigned 64 bit value.
             * @name Reader#uint64
             * @function
             * @returns {Long} Value read
             */

            /**
             * Reads a zig-zag encoded varint as a signed 64 bit value.
             * @name Reader#sint64
             * @function
             * @returns {Long} Value read
             */

            /**
             * Reads a varint as a boolean.
             * @returns {boolean} Value read
             */
            Reader.prototype.bool = function read_bool() {
                return this.uint32() !== 0;
            };

            function readFixed32_end(buf, end) {
                // note that this uses `end`, not `pos`
                return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
            }

            /**
             * Reads fixed 32 bits as an unsigned 32 bit integer.
             * @returns {number} Value read
             */
            Reader.prototype.fixed32 = function read_fixed32() {

                /* istanbul ignore if */
                if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);

                return readFixed32_end(this.buf, this.pos += 4);
            };

            /**
             * Reads fixed 32 bits as a signed 32 bit integer.
             * @returns {number} Value read
             */
            Reader.prototype.sfixed32 = function read_sfixed32() {

                /* istanbul ignore if */
                if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);

                return readFixed32_end(this.buf, this.pos += 4) | 0;
            };

            /* eslint-disable no-invalid-this */

            function readFixed64() /* this: Reader */{

                /* istanbul ignore if */
                if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);

                return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
            }

            /* eslint-enable no-invalid-this */

            /**
             * Reads fixed 64 bits.
             * @name Reader#fixed64
             * @function
             * @returns {Long} Value read
             */

            /**
             * Reads zig-zag encoded fixed 64 bits.
             * @name Reader#sfixed64
             * @function
             * @returns {Long} Value read
             */

            /**
             * Reads a float (32 bit) as a number.
             * @function
             * @returns {number} Value read
             */
            Reader.prototype.float = function read_float() {

                /* istanbul ignore if */
                if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);

                var value = util.float.readFloatLE(this.buf, this.pos);
                this.pos += 4;
                return value;
            };

            /**
             * Reads a double (64 bit float) as a number.
             * @function
             * @returns {number} Value read
             */
            Reader.prototype.double = function read_double() {

                /* istanbul ignore if */
                if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);

                var value = util.float.readDoubleLE(this.buf, this.pos);
                this.pos += 8;
                return value;
            };

            /**
             * Reads a sequence of bytes preceeded by its length as a varint.
             * @returns {Uint8Array} Value read
             */
            Reader.prototype.bytes = function read_bytes() {
                var length = this.uint32(),
                    start = this.pos,
                    end = this.pos + length;

                /* istanbul ignore if */
                if (end > this.len) throw indexOutOfRange(this, length);

                this.pos += length;
                if (Array.isArray(this.buf)) // plain array
                    return this.buf.slice(start, end);
                return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
                ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
            };

            /**
             * Reads a string preceeded by its byte length as a varint.
             * @returns {string} Value read
             */
            Reader.prototype.string = function read_string() {
                var bytes = this.bytes();
                return utf8.read(bytes, 0, bytes.length);
            };

            /**
             * Skips the specified number of bytes if specified, otherwise skips a varint.
             * @param {number} [length] Length if known, otherwise a varint is assumed
             * @returns {Reader} `this`
             */
            Reader.prototype.skip = function skip(length) {
                if (typeof length === "number") {
                    /* istanbul ignore if */
                    if (this.pos + length > this.len) throw indexOutOfRange(this, length);
                    this.pos += length;
                } else {
                    do {
                        /* istanbul ignore if */
                        if (this.pos >= this.len) throw indexOutOfRange(this);
                    } while (this.buf[this.pos++] & 128);
                }
                return this;
            };

            /**
             * Skips the next element of the specified wire type.
             * @param {number} wireType Wire type received
             * @returns {Reader} `this`
             */
            Reader.prototype.skipType = function (wireType) {
                switch (wireType) {
                    case 0:
                        this.skip();
                        break;
                    case 1:
                        this.skip(8);
                        break;
                    case 2:
                        this.skip(this.uint32());
                        break;
                    case 3:
                        do {
                            // eslint-disable-line no-constant-condition
                            if ((wireType = this.uint32() & 7) === 4) break;
                            this.skipType(wireType);
                        } while (true);
                        break;
                    case 5:
                        this.skip(4);
                        break;

                    /* istanbul ignore next */
                    default:
                        throw Error("invalid wire type " + wireType + " at offset " + this.pos);
                }
                return this;
            };

            Reader._configure = function (BufferReader_) {
                BufferReader = BufferReader_;

                var fn = util.Long ? "toLong" : /* istanbul ignore next */"toNumber";
                util.merge(Reader.prototype, {

                    int64: function read_int64() {
                        return readLongVarint.call(this)[fn](false);
                    },

                    uint64: function read_uint64() {
                        return readLongVarint.call(this)[fn](true);
                    },

                    sint64: function read_sint64() {
                        return readLongVarint.call(this).zzDecode()[fn](false);
                    },

                    fixed64: function read_fixed64() {
                        return readFixed64.call(this)[fn](true);
                    },

                    sfixed64: function read_sfixed64() {
                        return readFixed64.call(this)[fn](false);
                    }

                });
            };
        }, { "39": 39 }], 28: [function (_require, module, exports) {
            "use strict";

            module.exports = BufferReader;

            // extends Reader
            var Reader = _require(27);
            (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

            var util = _require(39);

            /**
             * Constructs a new buffer reader instance.
             * @classdesc Wire format reader using node buffers.
             * @extends Reader
             * @constructor
             * @param {Buffer} buffer Buffer to read from
             */
            function BufferReader(buffer) {
                Reader.call(this, buffer);

                /**
                 * Read buffer.
                 * @name BufferReader#buf
                 * @type {Buffer}
                 */
            }

            /* istanbul ignore else */
            if (util.Buffer) BufferReader.prototype._slice = util.Buffer.prototype.slice;

            /**
             * @override
             */
            BufferReader.prototype.string = function read_string_buffer() {
                var len = this.uint32(); // modifies pos
                return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
            };

            /**
             * Reads a sequence of bytes preceeded by its length as a varint.
             * @name BufferReader#bytes
             * @function
             * @returns {Buffer} Value read
             */
        }, { "27": 27, "39": 39 }], 29: [function (_require, module, exports) {
            "use strict";

            module.exports = Root;

            // extends Namespace
            var Namespace = _require(23);
            ((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";

            var Field = _require(16),
                Enum = _require(15),
                OneOf = _require(25),
                util = _require(37);

            var Type, // cyclic
            parse, // might be excluded
            common; // "

            /**
             * Constructs a new root namespace instance.
             * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
             * @extends NamespaceBase
             * @constructor
             * @param {Object.<string,*>} [options] Top level options
             */
            function Root(options) {
                Namespace.call(this, "", options);

                /**
                 * Deferred extension fields.
                 * @type {Field[]}
                 */
                this.deferred = [];

                /**
                 * Resolved file names of loaded files.
                 * @type {string[]}
                 */
                this.files = [];
            }

            /**
             * Loads a namespace descriptor into a root namespace.
             * @param {INamespace} json Nameespace descriptor
             * @param {Root} [root] Root namespace, defaults to create a new one if omitted
             * @returns {Root} Root namespace
             */
            Root.fromJSON = function fromJSON(json, root) {
                if (!root) root = new Root();
                if (json.options) root.setOptions(json.options);
                return root.addJSON(json.nested);
            };

            /**
             * Resolves the path of an imported file, relative to the importing origin.
             * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
             * @function
             * @param {string} origin The file name of the importing file
             * @param {string} target The file name being imported
             * @returns {string|null} Resolved path to `target` or `null` to skip the file
             */
            Root.prototype.resolvePath = util.path.resolve;

            // A symbol-like function to safely signal synchronous loading
            /* istanbul ignore next */
            function SYNC() {} // eslint-disable-line no-empty-function

            /**
             * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
             * @param {string|string[]} filename Names of one or multiple files to load
             * @param {IParseOptions} options Parse options
             * @param {LoadCallback} callback Callback function
             * @returns {undefined}
             */
            Root.prototype.load = function load(filename, options, callback) {
                if (typeof options === "function") {
                    callback = options;
                    options = undefined;
                }
                var self = this;
                if (!callback) return util.asPromise(load, self, filename, options);

                var sync = callback === SYNC; // undocumented

                // Finishes loading by calling the callback (exactly once)
                function finish(err, root) {
                    /* istanbul ignore if */
                    if (!callback) return;
                    var cb = callback;
                    callback = null;
                    if (sync) throw err;
                    cb(err, root);
                }

                // Processes a single file
                function process(filename, source) {
                    try {
                        if (util.isString(source) && source.charAt(0) === "{") source = JSON.parse(source);
                        if (!util.isString(source)) self.setOptions(source.options).addJSON(source.nested);else {
                            parse.filename = filename;
                            var parsed = parse(source, self, options),
                                resolved,
                                i = 0;
                            if (parsed.imports) for (; i < parsed.imports.length; ++i) {
                                if (resolved = self.resolvePath(filename, parsed.imports[i])) fetch(resolved);
                            }if (parsed.weakImports) for (i = 0; i < parsed.weakImports.length; ++i) {
                                if (resolved = self.resolvePath(filename, parsed.weakImports[i])) fetch(resolved, true);
                            }
                        }
                    } catch (err) {
                        finish(err);
                    }
                    if (!sync && !queued) finish(null, self); // only once anyway
                }

                // Fetches a single file
                function fetch(filename, weak) {

                    // Strip path if this file references a bundled definition
                    var idx = filename.lastIndexOf("google/protobuf/");
                    if (idx > -1) {
                        var altname = filename.substring(idx);
                        if (altname in common) filename = altname;
                    }

                    // Skip if already loaded / attempted
                    if (self.files.indexOf(filename) > -1) return;
                    self.files.push(filename);

                    // Shortcut bundled definitions
                    if (filename in common) {
                        if (sync) process(filename, common[filename]);else {
                            ++queued;
                            setTimeout(function () {
                                --queued;
                                process(filename, common[filename]);
                            });
                        }
                        return;
                    }

                    // Otherwise fetch from disk or network
                    if (sync) {
                        var source;
                        try {
                            if (filename.startsWith("syntax =")) {
                                source = filename;
                            } else {
                                source = util.fs.readFileSync(filename).toString("utf8");
                            }
                        } catch (err) {
                            if (!weak) finish(err);
                            return;
                        }
                        process(filename, source);
                    } else {
                        ++queued;
                        util.fetch(filename, function (err, source) {
                            --queued;
                            /* istanbul ignore if */
                            if (!callback) return; // terminated meanwhile
                            if (err) {
                                /* istanbul ignore else */
                                if (!weak) finish(err);else if (!queued) // can't be covered reliably
                                    finish(null, self);
                                return;
                            }
                            process(filename, source);
                        });
                    }
                }
                var queued = 0;

                // Assembling the root namespace doesn't _require working type
                // references anymore, so we can load everything in parallel
                if (util.isString(filename)) filename = [filename];
                for (var i = 0, resolved; i < filename.length; ++i) {
                    if (resolved = self.resolvePath("", filename[i])) fetch(resolved);
                }if (sync) return self;
                if (!queued) finish(null, self);
                return undefined;
            };
            // function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined

            /**
             * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
             * @function Root#load
             * @param {string|string[]} filename Names of one or multiple files to load
             * @param {LoadCallback} callback Callback function
             * @returns {undefined}
             * @variation 2
             */
            // function load(filename:string, callback:LoadCallback):undefined

            /**
             * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
             * @function Root#load
             * @param {string|string[]} filename Names of one or multiple files to load
             * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
             * @returns {Promise<Root>} Promise
             * @variation 3
             */
            // function load(filename:string, [options:IParseOptions]):Promise<Root>

            /**
             * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
             * @function Root#loadSync
             * @param {string|string[]} filename Names of one or multiple files to load
             * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
             * @returns {Root} Root namespace
             * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
             */
            Root.prototype.loadSync = function loadSync(filename, options) {
                if (!util.isNode) throw Error("not supported");
                return this.load(filename, options, SYNC);
            };

            /**
             * @override
             */
            Root.prototype.resolveAll = function resolveAll() {
                if (this.deferred.length) throw Error("unresolvable extensions: " + this.deferred.map(function (field) {
                    return "'extend " + field.extend + "' in " + field.parent.fullName;
                }).join(", "));
                return Namespace.prototype.resolveAll.call(this);
            };

            // only uppercased (and thus conflict-free) children are exposed, see below
            var exposeRe = /^[A-Z]/;

            /**
             * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.
             * @param {Root} root Root instance
             * @param {Field} field Declaring extension field witin the declaring type
             * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise
             * @inner
             * @ignore
             */
            function tryHandleExtension(root, field) {
                var extendedType = field.parent.lookup(field.extend);
                if (extendedType) {
                    var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);
                    sisterField.declaringField = field;
                    field.extensionField = sisterField;
                    extendedType.add(sisterField);
                    return true;
                }
                return false;
            }

            /**
             * Called when any object is added to this root or its sub-namespaces.
             * @param {ReflectionObject} object Object added
             * @returns {undefined}
             * @private
             */
            Root.prototype._handleAdd = function _handleAdd(object) {
                if (object instanceof Field) {

                    if ( /* an extension field (implies not part of a oneof) */object.extend !== undefined && /* not already handled */!object.extensionField) if (!tryHandleExtension(this, object)) this.deferred.push(object);
                } else if (object instanceof Enum) {

                    if (exposeRe.test(object.name)) object.parent[object.name] = object.values; // expose enum values as property of its parent
                } else if (!(object instanceof OneOf)) /* everything else is a namespace */{

                        if (object instanceof Type) // Try to handle any deferred extensions
                            for (var i = 0; i < this.deferred.length;) {
                                if (tryHandleExtension(this, this.deferred[i])) this.deferred.splice(i, 1);else ++i;
                            }for (var j = 0; j < /* initializes */object.nestedArray.length; ++j) {
                            // recurse into the namespace
                            this._handleAdd(object._nestedArray[j]);
                        }if (exposeRe.test(object.name)) object.parent[object.name] = object; // expose namespace as property of its parent
                    }

                // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
                // properties of namespaces just like static code does. This allows using a .d.ts generated for
                // a static module with reflection-based solutions where the condition is met.
            };

            /**
             * Called when any object is removed from this root or its sub-namespaces.
             * @param {ReflectionObject} object Object removed
             * @returns {undefined}
             * @private
             */
            Root.prototype._handleRemove = function _handleRemove(object) {
                if (object instanceof Field) {

                    if ( /* an extension field */object.extend !== undefined) {
                        if ( /* already handled */object.extensionField) {
                            // remove its sister field
                            object.extensionField.parent.remove(object.extensionField);
                            object.extensionField = null;
                        } else {
                            // cancel the extension
                            var index = this.deferred.indexOf(object);
                            /* istanbul ignore else */
                            if (index > -1) this.deferred.splice(index, 1);
                        }
                    }
                } else if (object instanceof Enum) {

                    if (exposeRe.test(object.name)) delete object.parent[object.name]; // unexpose enum values
                } else if (object instanceof Namespace) {

                    for (var i = 0; i < /* initializes */object.nestedArray.length; ++i) {
                        // recurse into the namespace
                        this._handleRemove(object._nestedArray[i]);
                    }if (exposeRe.test(object.name)) delete object.parent[object.name]; // unexpose namespaces
                }
            };

            Root._configure = function (Type_, parse_, common_) {
                Type = Type_;
                parse = parse_;
                common = common_;
            };
        }, { "15": 15, "16": 16, "23": 23, "25": 25, "37": 37 }], 30: [function (_require, module, exports) {
            "use strict";

            module.exports = {};

            /**
             * Named roots.
             * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
             * Can also be used manually to make roots available accross modules.
             * @name roots
             * @type {Object.<string,Root>}
             * @example
             * // pbjs -r myroot -o compiled.js ...
             *
             * // in another module:
             * _require("./compiled.js");
             *
             * // in any subsequent module:
             * var root = protobuf.roots["myroot"];
             */
        }, {}], 31: [function (_require, module, exports) {
            "use strict";

            /**
             * Streaming RPC helpers.
             * @namespace
             */

            var rpc = exports;

            /**
             * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
             * @typedef RPCImpl
             * @type {function}
             * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
             * @param {Uint8Array} requestData Request data
             * @param {RPCImplCallback} callback Callback function
             * @returns {undefined}
             * @example
             * function rpcImpl(method, requestData, callback) {
             *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
             *         throw Error("no such method");
             *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
             *         callback(err, responseData);
             *     });
             * }
             */

            /**
             * Node-style callback as used by {@link RPCImpl}.
             * @typedef RPCImplCallback
             * @type {function}
             * @param {Error|null} error Error, if any, otherwise `null`
             * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
             * @returns {undefined}
             */

            rpc.Service = _require(32);
        }, { "32": 32 }], 32: [function (_require, module, exports) {
            "use strict";

            module.exports = Service;

            var util = _require(39);

            // Extends EventEmitter
            (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

            /**
             * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
             *
             * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
             * @typedef rpc.ServiceMethodCallback
             * @template TRes extends Message<TRes>
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {TRes} [response] Response message
             * @returns {undefined}
             */

            /**
             * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
             * @typedef rpc.ServiceMethod
             * @template TReq extends Message<TReq>
             * @template TRes extends Message<TRes>
             * @type {function}
             * @param {TReq|Properties<TReq>} request Request message or plain object
             * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
             * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
             */

            /**
             * Constructs a new RPC service instance.
             * @classdesc An RPC service as returned by {@link Service#create}.
             * @exports rpc.Service
             * @extends util.EventEmitter
             * @constructor
             * @param {RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Service(rpcImpl, requestDelimited, responseDelimited) {

                if (typeof rpcImpl !== "function") throw TypeError("rpcImpl must be a function");

                util.EventEmitter.call(this);

                /**
                 * RPC implementation. Becomes `null` once the service is ended.
                 * @type {RPCImpl|null}
                 */
                this.rpcImpl = rpcImpl;

                /**
                 * Whether requests are length-delimited.
                 * @type {boolean}
                 */
                this.requestDelimited = Boolean(requestDelimited);

                /**
                 * Whether responses are length-delimited.
                 * @type {boolean}
                 */
                this.responseDelimited = Boolean(responseDelimited);
            }

            /**
             * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
             * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
             * @param {Constructor<TReq>} requestCtor Request constructor
             * @param {Constructor<TRes>} responseCtor Response constructor
             * @param {TReq|Properties<TReq>} request Request message or plain object
             * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
             * @returns {undefined}
             * @template TReq extends Message<TReq>
             * @template TRes extends Message<TRes>
             */
            Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

                if (!request) throw TypeError("request must be specified");

                var self = this;
                if (!callback) return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

                if (!self.rpcImpl) {
                    setTimeout(function () {
                        callback(Error("already ended"));
                    }, 0);
                    return undefined;
                }

                try {
                    return self.rpcImpl(method, requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {

                        if (err) {
                            self.emit("error", err, method);
                            return callback(err);
                        }

                        if (response === null) {
                            self.end( /* endedByRPC */true);
                            return undefined;
                        }

                        if (!(response instanceof responseCtor)) {
                            try {
                                response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                            } catch (err) {
                                self.emit("error", err, method);
                                return callback(err);
                            }
                        }

                        self.emit("data", response, method);
                        return callback(null, response);
                    });
                } catch (err) {
                    self.emit("error", err, method);
                    setTimeout(function () {
                        callback(err);
                    }, 0);
                    return undefined;
                }
            };

            /**
             * Ends this service and emits the `end` event.
             * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
             * @returns {rpc.Service} `this`
             */
            Service.prototype.end = function end(endedByRPC) {
                if (this.rpcImpl) {
                    if (!endedByRPC) // signal end to rpcImpl
                        this.rpcImpl(null, null, null);
                    this.rpcImpl = null;
                    this.emit("end").off();
                }
                return this;
            };
        }, { "39": 39 }], 33: [function (_require, module, exports) {
            "use strict";

            module.exports = Service;

            // extends Namespace
            var Namespace = _require(23);
            ((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";

            var Method = _require(22),
                util = _require(37),
                rpc = _require(31);

            /**
             * Constructs a new service instance.
             * @classdesc Reflected service.
             * @extends NamespaceBase
             * @constructor
             * @param {string} name Service name
             * @param {Object.<string,*>} [options] Service options
             * @throws {TypeError} If arguments are invalid
             */
            function Service(name, options) {
                Namespace.call(this, name, options);

                /**
                 * Service methods.
                 * @type {Object.<string,Method>}
                 */
                this.methods = {}; // toJSON, marker

                /**
                 * Cached methods as an array.
                 * @type {Method[]|null}
                 * @private
                 */
                this._methodsArray = null;
            }

            /**
             * Service descriptor.
             * @interface IService
             * @extends INamespace
             * @property {Object.<string,IMethod>} methods Method descriptors
             */

            /**
             * Constructs a service from a service descriptor.
             * @param {string} name Service name
             * @param {IService} json Service descriptor
             * @returns {Service} Created service
             * @throws {TypeError} If arguments are invalid
             */
            Service.fromJSON = function fromJSON(name, json) {
                var service = new Service(name, json.options);
                /* istanbul ignore else */
                if (json.methods) for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i) {
                    service.add(Method.fromJSON(names[i], json.methods[names[i]]));
                }if (json.nested) service.addJSON(json.nested);
                return service;
            };

            /**
             * Converts this service to a service descriptor.
             * @returns {IService} Service descriptor
             */
            Service.prototype.toJSON = function toJSON() {
                var inherited = Namespace.prototype.toJSON.call(this);
                return util.toObject(["options", inherited && inherited.options || undefined, "methods", Namespace.arrayToJSON(this.methodsArray) || /* istanbul ignore next */{}, "nested", inherited && inherited.nested || undefined]);
            };

            /**
             * Methods of this service as an array for iteration.
             * @name Service#methodsArray
             * @type {Method[]}
             * @readonly
             */
            Object.defineProperty(Service.prototype, "methodsArray", {
                get: function get() {
                    return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
                }
            });

            function clearCache(service) {
                service._methodsArray = null;
                return service;
            }

            /**
             * @override
             */
            Service.prototype.get = function get(name) {
                return this.methods[name] || Namespace.prototype.get.call(this, name);
            };

            /**
             * @override
             */
            Service.prototype.resolveAll = function resolveAll() {
                var methods = this.methodsArray;
                for (var i = 0; i < methods.length; ++i) {
                    methods[i].resolve();
                }return Namespace.prototype.resolve.call(this);
            };

            /**
             * @override
             */
            Service.prototype.add = function add(object) {

                /* istanbul ignore if */
                if (this.get(object.name)) throw Error("duplicate name '" + object.name + "' in " + this);

                if (object instanceof Method) {
                    this.methods[object.name] = object;
                    object.parent = this;
                    return clearCache(this);
                }
                return Namespace.prototype.add.call(this, object);
            };

            /**
             * @override
             */
            Service.prototype.remove = function remove(object) {
                if (object instanceof Method) {

                    /* istanbul ignore if */
                    if (this.methods[object.name] !== object) throw Error(object + " is not a member of " + this);

                    delete this.methods[object.name];
                    object.parent = null;
                    return clearCache(this);
                }
                return Namespace.prototype.remove.call(this, object);
            };

            /**
             * Creates a runtime service using the specified rpc implementation.
             * @param {RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.
             */
            Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
                for (var i = 0, method; i < /* initializes */this.methodsArray.length; ++i) {
                    var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
                    rpcService[methodName] = util.codegen(["r", "c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
                        m: method,
                        q: method.resolvedRequestType.ctor,
                        s: method.resolvedResponseType.ctor
                    });
                }
                return rpcService;
            };
        }, { "22": 22, "23": 23, "31": 31, "37": 37 }], 34: [function (_require, module, exports) {
            "use strict";

            module.exports = tokenize;

            var delimRe = /[\s{}=;:[\],'"()<>]/g,
                stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
                stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;

            var setCommentRe = /^ *[*/]+ */,
                setCommentSplitRe = /\n/g,
                whitespaceRe = /\s/,
                unescapeRe = /\\(.?)/g;

            var unescapeMap = {
                "0": "\0",
                "r": "\r",
                "n": "\n",
                "t": "\t"
            };

            /**
             * Unescapes a string.
             * @param {string} str String to unescape
             * @returns {string} Unescaped string
             * @property {Object.<string,string>} map Special characters map
             * @memberof tokenize
             */
            function unescape(str) {
                return str.replace(unescapeRe, function ($0, $1) {
                    switch ($1) {
                        case "\\":
                        case "":
                            return $1;
                        default:
                            return unescapeMap[$1] || "";
                    }
                });
            }

            tokenize.unescape = unescape;

            /**
             * Gets the next token and advances.
             * @typedef TokenizerHandleNext
             * @type {function}
             * @returns {string|null} Next token or `null` on eof
             */

            /**
             * Peeks for the next token.
             * @typedef TokenizerHandlePeek
             * @type {function}
             * @returns {string|null} Next token or `null` on eof
             */

            /**
             * Pushes a token back to the stack.
             * @typedef TokenizerHandlePush
             * @type {function}
             * @param {string} token Token
             * @returns {undefined}
             */

            /**
             * Skips the next token.
             * @typedef TokenizerHandleSkip
             * @type {function}
             * @param {string} expected Expected token
             * @param {boolean} [optional=false] If optional
             * @returns {boolean} Whether the token matched
             * @throws {Error} If the token didn't match and is not optional
             */

            /**
             * Gets the comment on the previous line or, alternatively, the line comment on the specified line.
             * @typedef TokenizerHandleCmnt
             * @type {function}
             * @param {number} [line] Line number
             * @returns {string|null} Comment text or `null` if none
             */

            /**
             * Handle object returned from {@link tokenize}.
             * @interface ITokenizerHandle
             * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)
             * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)
             * @property {TokenizerHandlePush} push Pushes a token back to the stack
             * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws
             * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any
             * @property {number} line Current line number
             */

            /**
             * Tokenizes the given .proto source and returns an object with useful utility functions.
             * @param {string} source Source contents
             * @returns {ITokenizerHandle} Tokenizer handle
             */
            function tokenize(source) {
                /* eslint-disable callback-return */
                source = source.toString();

                var offset = 0,
                    length = source.length,
                    line = 1,
                    commentType = null,
                    commentText = null,
                    commentLine = 0,
                    commentLineEmpty = false;

                var stack = [];

                var stringDelim = null;

                /* istanbul ignore next */
                /**
                 * Creates an error for illegal syntax.
                 * @param {string} subject Subject
                 * @returns {Error} Error created
                 * @inner
                 */
                function illegal(subject) {
                    return Error("illegal " + subject + " (line " + line + ")");
                }

                /**
                 * Reads a string till its end.
                 * @returns {string} String read
                 * @inner
                 */
                function readString() {
                    var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
                    re.lastIndex = offset - 1;
                    var match = re.exec(source);
                    if (!match) throw illegal("string");
                    offset = re.lastIndex;
                    push(stringDelim);
                    stringDelim = null;
                    return unescape(match[1]);
                }

                /**
                 * Gets the character at `pos` within the source.
                 * @param {number} pos Position
                 * @returns {string} Character
                 * @inner
                 */
                function charAt(pos) {
                    return source.charAt(pos);
                }

                /**
                 * Sets the current comment text.
                 * @param {number} start Start offset
                 * @param {number} end End offset
                 * @returns {undefined}
                 * @inner
                 */
                function setComment(start, end) {
                    commentType = source.charAt(start++);
                    commentLine = line;
                    commentLineEmpty = false;
                    var offset = start - 3,
                        // "///" or "/**"
                    c;
                    do {
                        if (--offset < 0 || (c = source.charAt(offset)) === "\n") {
                            commentLineEmpty = true;
                            break;
                        }
                    } while (c === " " || c === "\t");
                    var lines = source.substring(start, end).split(setCommentSplitRe);
                    for (var i = 0; i < lines.length; ++i) {
                        lines[i] = lines[i].replace(setCommentRe, "").trim();
                    }commentText = lines.join("\n").trim();
                }

                /**
                 * Obtains the next token.
                 * @returns {string|null} Next token or `null` on eof
                 * @inner
                 */
                function next() {
                    if (stack.length > 0) return stack.shift();
                    if (stringDelim) return readString();
                    var repeat, prev, curr, start, isDoc;
                    do {
                        if (offset === length) return null;
                        repeat = false;
                        while (whitespaceRe.test(curr = charAt(offset))) {
                            if (curr === "\n") ++line;
                            if (++offset === length) return null;
                        }
                        if (charAt(offset) === "/") {
                            if (++offset === length) throw illegal("comment");
                            if (charAt(offset) === "/") {
                                // Line
                                isDoc = charAt(start = offset + 1) === "/";
                                while (charAt(++offset) !== "\n") {
                                    if (offset === length) return null;
                                }++offset;
                                if (isDoc) /// Comment
                                    setComment(start, offset - 1);
                                ++line;
                                repeat = true;
                            } else if ((curr = charAt(offset)) === "*") {
                                /* Block */
                                isDoc = charAt(start = offset + 1) === "*";
                                do {
                                    if (curr === "\n") ++line;
                                    if (++offset === length) throw illegal("comment");
                                    prev = curr;
                                    curr = charAt(offset);
                                } while (prev !== "*" || curr !== "/");
                                ++offset;
                                if (isDoc) /** Comment */
                                    setComment(start, offset - 2);
                                repeat = true;
                            } else return "/";
                        }
                    } while (repeat);

                    // offset !== length if we got here

                    var end = offset;
                    delimRe.lastIndex = 0;
                    var delim = delimRe.test(charAt(end++));
                    if (!delim) while (end < length && !delimRe.test(charAt(end))) {
                        ++end;
                    }var token = source.substring(offset, offset = end);
                    if (token === "\"" || token === "'") stringDelim = token;
                    return token;
                }

                /**
                 * Pushes a token back to the stack.
                 * @param {string} token Token
                 * @returns {undefined}
                 * @inner
                 */
                function push(token) {
                    stack.push(token);
                }

                /**
                 * Peeks for the next token.
                 * @returns {string|null} Token or `null` on eof
                 * @inner
                 */
                function peek() {
                    if (!stack.length) {
                        var token = next();
                        if (token === null) return null;
                        push(token);
                    }
                    return stack[0];
                }

                /**
                 * Skips a token.
                 * @param {string} expected Expected token
                 * @param {boolean} [optional=false] Whether the token is optional
                 * @returns {boolean} `true` when skipped, `false` if not
                 * @throws {Error} When a _required token is not present
                 * @inner
                 */
                function skip(expected, optional) {
                    var actual = peek(),
                        equals = actual === expected;
                    if (equals) {
                        next();
                        return true;
                    }
                    if (!optional) throw illegal("token '" + actual + "', '" + expected + "' expected");
                    return false;
                }

                /**
                 * Gets a comment.
                 * @param {number} [trailingLine] Line number if looking for a trailing comment
                 * @returns {string|null} Comment text
                 * @inner
                 */
                function cmnt(trailingLine) {
                    var ret = null;
                    if (trailingLine === undefined) {
                        if (commentLine === line - 1 && (commentType === "*" || commentLineEmpty)) ret = commentText;
                    } else {
                        /* istanbul ignore else */
                        if (commentLine < trailingLine) peek();
                        if (commentLine === trailingLine && !commentLineEmpty && commentType === "/") ret = commentText;
                    }
                    return ret;
                }

                return Object.defineProperty({
                    next: next,
                    peek: peek,
                    push: push,
                    skip: skip,
                    cmnt: cmnt
                }, "line", {
                    get: function get() {
                        return line;
                    }
                });
                /* eslint-enable callback-return */
            }
        }, {}], 35: [function (_require, module, exports) {
            "use strict";

            module.exports = Type;

            // extends Namespace
            var Namespace = _require(23);
            ((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";

            var Enum = _require(15),
                OneOf = _require(25),
                Field = _require(16),
                MapField = _require(20),
                Service = _require(33),
                Message = _require(21),
                Reader = _require(27),
                Writer = _require(42),
                util = _require(37),
                encoder = _require(14),
                decoder = _require(13),
                verifier = _require(40),
                converter = _require(12),
                wrappers = _require(41);

            /**
             * Constructs a new reflected message type instance.
             * @classdesc Reflected message type.
             * @extends NamespaceBase
             * @constructor
             * @param {string} name Message name
             * @param {Object.<string,*>} [options] Declared options
             */
            function Type(name, options) {
                Namespace.call(this, name, options);

                /**
                 * Message fields.
                 * @type {Object.<string,Field>}
                 */
                this.fields = {}; // toJSON, marker

                /**
                 * Oneofs declared within this namespace, if any.
                 * @type {Object.<string,OneOf>}
                 */
                this.oneofs = undefined; // toJSON

                /**
                 * Extension ranges, if any.
                 * @type {number[][]}
                 */
                this.extensions = undefined; // toJSON

                /**
                 * Reserved ranges, if any.
                 * @type {Array.<number[]|string>}
                 */
                this.reserved = undefined; // toJSON

                /*?
                 * Whether this type is a legacy group.
                 * @type {boolean|undefined}
                 */
                this.group = undefined; // toJSON

                /**
                 * Cached fields by id.
                 * @type {Object.<number,Field>|null}
                 * @private
                 */
                this._fieldsById = null;

                /**
                 * Cached fields as an array.
                 * @type {Field[]|null}
                 * @private
                 */
                this._fieldsArray = null;

                /**
                 * Cached oneofs as an array.
                 * @type {OneOf[]|null}
                 * @private
                 */
                this._oneofsArray = null;

                /**
                 * Cached constructor.
                 * @type {Constructor<{}>}
                 * @private
                 */
                this._ctor = null;
            }

            Object.defineProperties(Type.prototype, {

                /**
                 * Message fields by id.
                 * @name Type#fieldsById
                 * @type {Object.<number,Field>}
                 * @readonly
                 */
                fieldsById: {
                    get: function get() {

                        /* istanbul ignore if */
                        if (this._fieldsById) return this._fieldsById;

                        this._fieldsById = {};
                        for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
                            var field = this.fields[names[i]],
                                id = field.id;

                            /* istanbul ignore if */
                            if (this._fieldsById[id]) throw Error("duplicate id " + id + " in " + this);

                            this._fieldsById[id] = field;
                        }
                        return this._fieldsById;
                    }
                },

                /**
                 * Fields of this message as an array for iteration.
                 * @name Type#fieldsArray
                 * @type {Field[]}
                 * @readonly
                 */
                fieldsArray: {
                    get: function get() {
                        return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
                    }
                },

                /**
                 * Oneofs of this message as an array for iteration.
                 * @name Type#oneofsArray
                 * @type {OneOf[]}
                 * @readonly
                 */
                oneofsArray: {
                    get: function get() {
                        return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
                    }
                },

                /**
                 * The registered constructor, if any registered, otherwise a generic constructor.
                 * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
                 * @name Type#ctor
                 * @type {Constructor<{}>}
                 */
                ctor: {
                    get: function get() {
                        return this._ctor || (this.ctor = Type.generateConstructor(this)());
                    },
                    set: function set(ctor) {

                        // Ensure proper prototype
                        var prototype = ctor.prototype;
                        if (!(prototype instanceof Message)) {
                            (ctor.prototype = new Message()).constructor = ctor;
                            util.merge(ctor.prototype, prototype);
                        }

                        // Classes and messages reference their reflected type
                        ctor.$type = ctor.prototype.$type = this;

                        // Mix in static methods
                        util.merge(ctor, Message, true);

                        this._ctor = ctor;

                        // Messages have non-enumerable default values on their prototype
                        var i = 0;
                        for (; i < /* initializes */this.fieldsArray.length; ++i) {
                            this._fieldsArray[i].resolve();
                        } // ensures a proper value

                        // Messages have non-enumerable getters and setters for each virtual oneof field
                        var ctorProperties = {};
                        for (i = 0; i < /* initializes */this.oneofsArray.length; ++i) {
                            ctorProperties[this._oneofsArray[i].resolve().name] = {
                                get: util.oneOfGetter(this._oneofsArray[i].oneof),
                                set: util.oneOfSetter(this._oneofsArray[i].oneof)
                            };
                        }if (i) Object.defineProperties(ctor.prototype, ctorProperties);
                    }
                }
            });

            /**
             * Generates a constructor function for the specified type.
             * @param {Type} mtype Message type
             * @returns {Codegen} Codegen instance
             */
            Type.generateConstructor = function generateConstructor(mtype) {
                /* eslint-disable no-unexpected-multiline */
                var gen = util.codegen(["p"], mtype.name);
                // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype
                for (var i = 0, field; i < mtype.fieldsArray.length; ++i) {
                    if ((field = mtype._fieldsArray[i]).map) gen("this%s={}", util.safeProp(field.name));else if (field.repeated) gen("this%s=[]", util.safeProp(field.name));
                }return gen("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)") // omit undefined or null
                ("this[ks[i]]=p[ks[i]]");
                /* eslint-enable no-unexpected-multiline */
            };

            function clearCache(type) {
                type._fieldsById = type._fieldsArray = type._oneofsArray = null;
                delete type.encode;
                delete type.decode;
                delete type.verify;
                return type;
            }

            /**
             * Message type descriptor.
             * @interface IType
             * @extends INamespace
             * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors
             * @property {Object.<string,IField>} fields Field descriptors
             * @property {number[][]} [extensions] Extension ranges
             * @property {number[][]} [reserved] Reserved ranges
             * @property {boolean} [group=false] Whether a legacy group or not
             */

            /**
             * Creates a message type from a message type descriptor.
             * @param {string} name Message name
             * @param {IType} json Message type descriptor
             * @returns {Type} Created message type
             */
            Type.fromJSON = function fromJSON(name, json) {
                var type = new Type(name, json.options);
                type.extensions = json.extensions;
                type.reserved = json.reserved;
                var names = Object.keys(json.fields),
                    i = 0;
                for (; i < names.length; ++i) {
                    type.add((typeof json.fields[names[i]].keyType !== "undefined" ? MapField.fromJSON : Field.fromJSON)(names[i], json.fields[names[i]]));
                }if (json.oneofs) for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i) {
                    type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
                }if (json.nested) for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
                    var nested = json.nested[names[i]];
                    type.add( // most to least likely
                    (nested.id !== undefined ? Field.fromJSON : nested.fields !== undefined ? Type.fromJSON : nested.values !== undefined ? Enum.fromJSON : nested.methods !== undefined ? Service.fromJSON : Namespace.fromJSON)(names[i], nested));
                }
                if (json.extensions && json.extensions.length) type.extensions = json.extensions;
                if (json.reserved && json.reserved.length) type.reserved = json.reserved;
                if (json.group) type.group = true;
                return type;
            };

            /**
             * Converts this message type to a message type descriptor.
             * @returns {IType} Message type descriptor
             */
            Type.prototype.toJSON = function toJSON() {
                var inherited = Namespace.prototype.toJSON.call(this);
                return util.toObject(["options", inherited && inherited.options || undefined, "oneofs", Namespace.arrayToJSON(this.oneofsArray), "fields", Namespace.arrayToJSON(this.fieldsArray.filter(function (obj) {
                    return !obj.declaringField;
                })) || {}, "extensions", this.extensions && this.extensions.length ? this.extensions : undefined, "reserved", this.reserved && this.reserved.length ? this.reserved : undefined, "group", this.group || undefined, "nested", inherited && inherited.nested || undefined]);
            };

            /**
             * @override
             */
            Type.prototype.resolveAll = function resolveAll() {
                var fields = this.fieldsArray,
                    i = 0;
                while (i < fields.length) {
                    fields[i++].resolve();
                }var oneofs = this.oneofsArray;i = 0;
                while (i < oneofs.length) {
                    oneofs[i++].resolve();
                }return Namespace.prototype.resolveAll.call(this);
            };

            /**
             * @override
             */
            Type.prototype.get = function get(name) {
                return this.fields[name] || this.oneofs && this.oneofs[name] || this.nested && this.nested[name] || null;
            };

            /**
             * Adds a nested object to this type.
             * @param {ReflectionObject} object Nested object to add
             * @returns {Type} `this`
             * @throws {TypeError} If arguments are invalid
             * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
             */
            Type.prototype.add = function add(object) {

                if (this.get(object.name)) throw Error("duplicate name '" + object.name + "' in " + this);

                if (object instanceof Field && object.extend === undefined) {
                    // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
                    // The root object takes care of adding distinct sister-fields to the respective extended
                    // type instead.

                    // avoids calling the getter if not absolutely necessary because it's called quite frequently
                    if (this._fieldsById ? /* istanbul ignore next */this._fieldsById[object.id] : this.fieldsById[object.id]) throw Error("duplicate id " + object.id + " in " + this);
                    if (this.isReservedId(object.id)) throw Error("id " + object.id + " is reserved in " + this);
                    if (this.isReservedName(object.name)) throw Error("name '" + object.name + "' is reserved in " + this);

                    if (object.parent) object.parent.remove(object);
                    this.fields[object.name] = object;
                    object.message = this;
                    object.onAdd(this);
                    return clearCache(this);
                }
                if (object instanceof OneOf) {
                    if (!this.oneofs) this.oneofs = {};
                    this.oneofs[object.name] = object;
                    object.onAdd(this);
                    return clearCache(this);
                }
                return Namespace.prototype.add.call(this, object);
            };

            /**
             * Removes a nested object from this type.
             * @param {ReflectionObject} object Nested object to remove
             * @returns {Type} `this`
             * @throws {TypeError} If arguments are invalid
             * @throws {Error} If `object` is not a member of this type
             */
            Type.prototype.remove = function remove(object) {
                if (object instanceof Field && object.extend === undefined) {
                    // See Type#add for the reason why extension fields are excluded here.

                    /* istanbul ignore if */
                    if (!this.fields || this.fields[object.name] !== object) throw Error(object + " is not a member of " + this);

                    delete this.fields[object.name];
                    object.parent = null;
                    object.onRemove(this);
                    return clearCache(this);
                }
                if (object instanceof OneOf) {

                    /* istanbul ignore if */
                    if (!this.oneofs || this.oneofs[object.name] !== object) throw Error(object + " is not a member of " + this);

                    delete this.oneofs[object.name];
                    object.parent = null;
                    object.onRemove(this);
                    return clearCache(this);
                }
                return Namespace.prototype.remove.call(this, object);
            };

            /**
             * Tests if the specified id is reserved.
             * @param {number} id Id to test
             * @returns {boolean} `true` if reserved, otherwise `false`
             */
            Type.prototype.isReservedId = function isReservedId(id) {
                return Namespace.isReservedId(this.reserved, id);
            };

            /**
             * Tests if the specified name is reserved.
             * @param {string} name Name to test
             * @returns {boolean} `true` if reserved, otherwise `false`
             */
            Type.prototype.isReservedName = function isReservedName(name) {
                return Namespace.isReservedName(this.reserved, name);
            };

            /**
             * Creates a new message of this type using the specified properties.
             * @param {Object.<string,*>} [properties] Properties to set
             * @returns {Message<{}>} Message instance
             */
            Type.prototype.create = function create(properties) {
                return new this.ctor(properties);
            };

            /**
             * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
             * @returns {Type} `this`
             */
            Type.prototype.setup = function setup() {
                // Sets up everything at once so that the prototype chain does not have to be re-evaluated
                // multiple times (V8, soft-deopt prototype-check).

                var fullName = this.fullName,
                    types = [];
                for (var i = 0; i < /* initializes */this.fieldsArray.length; ++i) {
                    types.push(this._fieldsArray[i].resolve().resolvedType);
                } // Replace setup methods with type-specific generated functions
                this.encode = encoder(this)({
                    Writer: Writer,
                    types: types,
                    util: util
                });
                this.decode = decoder(this)({
                    Reader: Reader,
                    types: types,
                    util: util
                });
                this.verify = verifier(this)({
                    types: types,
                    util: util
                });
                this.fromObject = converter.fromObject(this)({
                    types: types,
                    util: util
                });
                this.toObject = converter.toObject(this)({
                    types: types,
                    util: util
                });

                // Inject custom wrappers for common types
                var wrapper = wrappers[fullName];
                if (wrapper) {
                    var originalThis = Object.create(this);
                    // if (wrapper.fromObject) {
                    originalThis.fromObject = this.fromObject;
                    this.fromObject = wrapper.fromObject.bind(originalThis);
                    // }
                    // if (wrapper.toObject) {
                    originalThis.toObject = this.toObject;
                    this.toObject = wrapper.toObject.bind(originalThis);
                    // }
                }

                return this;
            };

            /**
             * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
             * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
             * @param {Writer} [writer] Writer to encode to
             * @returns {Writer} writer
             */
            Type.prototype.encode = function encode_setup(message, writer) {
                return this.setup().encode(message, writer); // overrides this method
            };

            /**
             * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
             * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
             * @param {Writer} [writer] Writer to encode to
             * @returns {Writer} writer
             */
            Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
            };

            /**
             * Decodes a message of this type.
             * @param {Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Length of the message, if known beforehand
             * @returns {Message<{}>} Decoded message
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {util.ProtocolError<{}>} If _required fields are missing
             */
            Type.prototype.decode = function decode_setup(reader, length) {
                return this.setup().decode(reader, length); // overrides this method
            };

            /**
             * Decodes a message of this type preceeded by its byte length as a varint.
             * @param {Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Message<{}>} Decoded message
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {util.ProtocolError} If _required fields are missing
             */
            Type.prototype.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof Reader)) reader = Reader.create(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies that field values are valid and that _required fields are present.
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {null|string} `null` if valid, otherwise the reason why it is not
             */
            Type.prototype.verify = function verify_setup(message) {
                return this.setup().verify(message); // overrides this method
            };

            /**
             * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
             * @param {Object.<string,*>} object Plain object to convert
             * @returns {Message<{}>} Message instance
             */
            Type.prototype.fromObject = function fromObject(object) {
                return this.setup().fromObject(object);
            };

            /**
             * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.
             * @interface IConversionOptions
             * @property {Function} [longs] Long conversion type.
             * Valid values are `String` and `Number` (the global types).
             * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
             * @property {Function} [enums] Enum value conversion type.
             * Only valid value is `String` (the global type).
             * Defaults to copy the present value, which is the numeric id.
             * @property {Function} [bytes] Bytes value conversion type.
             * Valid values are `Array` and (a base64 encoded) `String` (the global types).
             * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
             * @property {boolean} [defaults=false] Also sets default values on the resulting object
             * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`
             * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`
             * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any
             * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
             */

            /**
             * Creates a plain object from a message of this type. Also converts values to other types if specified.
             * @param {Message<{}>} message Message instance
             * @param {IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Type.prototype.toObject = function toObject(message, options) {
                return this.setup().toObject(message, options);
            };

            /**
             * Decorator function as returned by {@link Type.d} (TypeScript).
             * @typedef TypeDecorator
             * @type {function}
             * @param {Constructor<T>} target Target constructor
             * @returns {undefined}
             * @template T extends Message<T>
             */

            /**
             * Type decorator (TypeScript).
             * @param {string} [typeName] Type name, defaults to the constructor's name
             * @returns {TypeDecorator<T>} Decorator function
             * @template T extends Message<T>
             */
            Type.d = function decorateType(typeName) {
                return function typeDecorator(target) {
                    util.decorateType(target, typeName);
                };
            };
        }, { "12": 12, "13": 13, "14": 14, "15": 15, "16": 16, "20": 20, "21": 21, "23": 23, "25": 25, "27": 27, "33": 33, "37": 37, "40": 40, "41": 41, "42": 42 }], 36: [function (_require, module, exports) {
            "use strict";

            /**
             * Common type constants.
             * @namespace
             */

            var types = exports;

            var util = _require(37);

            var s = ["double", // 0
            "float", // 1
            "int32", // 2
            "uint32", // 3
            "sint32", // 4
            "fixed32", // 5
            "sfixed32", // 6
            "int64", // 7
            "uint64", // 8
            "sint64", // 9
            "fixed64", // 10
            "sfixed64", // 11
            "bool", // 12
            "string", // 13
            "bytes" // 14
            ];

            function bake(values, offset) {
                var i = 0,
                    o = {};
                offset |= 0;
                while (i < values.length) {
                    o[s[i + offset]] = values[i++];
                }return o;
            }

            /**
             * Basic type wire types.
             * @type {Object.<string,number>}
             * @const
             * @property {number} double=1 Fixed64 wire type
             * @property {number} float=5 Fixed32 wire type
             * @property {number} int32=0 Varint wire type
             * @property {number} uint32=0 Varint wire type
             * @property {number} sint32=0 Varint wire type
             * @property {number} fixed32=5 Fixed32 wire type
             * @property {number} sfixed32=5 Fixed32 wire type
             * @property {number} int64=0 Varint wire type
             * @property {number} uint64=0 Varint wire type
             * @property {number} sint64=0 Varint wire type
             * @property {number} fixed64=1 Fixed64 wire type
             * @property {number} sfixed64=1 Fixed64 wire type
             * @property {number} bool=0 Varint wire type
             * @property {number} string=2 Ldelim wire type
             * @property {number} bytes=2 Ldelim wire type
             */
            types.basic = bake([
            /* double   */1,
            /* float    */5,
            /* int32    */0,
            /* uint32   */0,
            /* sint32   */0,
            /* fixed32  */5,
            /* sfixed32 */5,
            /* int64    */0,
            /* uint64   */0,
            /* sint64   */0,
            /* fixed64  */1,
            /* sfixed64 */1,
            /* bool     */0,
            /* string   */2,
            /* bytes    */2]);

            /**
             * Basic type defaults.
             * @type {Object.<string,*>}
             * @const
             * @property {number} double=0 Double default
             * @property {number} float=0 Float default
             * @property {number} int32=0 Int32 default
             * @property {number} uint32=0 Uint32 default
             * @property {number} sint32=0 Sint32 default
             * @property {number} fixed32=0 Fixed32 default
             * @property {number} sfixed32=0 Sfixed32 default
             * @property {number} int64=0 Int64 default
             * @property {number} uint64=0 Uint64 default
             * @property {number} sint64=0 Sint32 default
             * @property {number} fixed64=0 Fixed64 default
             * @property {number} sfixed64=0 Sfixed64 default
             * @property {boolean} bool=false Bool default
             * @property {string} string="" String default
             * @property {Array.<number>} bytes=Array(0) Bytes default
             * @property {null} message=null Message default
             */
            types.defaults = bake([
            /* double   */0,
            /* float    */0,
            /* int32    */0,
            /* uint32   */0,
            /* sint32   */0,
            /* fixed32  */0,
            /* sfixed32 */0,
            /* int64    */0,
            /* uint64   */0,
            /* sint64   */0,
            /* fixed64  */0,
            /* sfixed64 */0,
            /* bool     */false,
            /* string   */"",
            /* bytes    */util.emptyArray,
            /* message  */null]);

            /**
             * Basic long type wire types.
             * @type {Object.<string,number>}
             * @const
             * @property {number} int64=0 Varint wire type
             * @property {number} uint64=0 Varint wire type
             * @property {number} sint64=0 Varint wire type
             * @property {number} fixed64=1 Fixed64 wire type
             * @property {number} sfixed64=1 Fixed64 wire type
             */
            types.long = bake([
            /* int64    */0,
            /* uint64   */0,
            /* sint64   */0,
            /* fixed64  */1,
            /* sfixed64 */1], 7);

            /**
             * Allowed types for map keys with their associated wire type.
             * @type {Object.<string,number>}
             * @const
             * @property {number} int32=0 Varint wire type
             * @property {number} uint32=0 Varint wire type
             * @property {number} sint32=0 Varint wire type
             * @property {number} fixed32=5 Fixed32 wire type
             * @property {number} sfixed32=5 Fixed32 wire type
             * @property {number} int64=0 Varint wire type
             * @property {number} uint64=0 Varint wire type
             * @property {number} sint64=0 Varint wire type
             * @property {number} fixed64=1 Fixed64 wire type
             * @property {number} sfixed64=1 Fixed64 wire type
             * @property {number} bool=0 Varint wire type
             * @property {number} string=2 Ldelim wire type
             */
            types.mapKey = bake([
            /* int32    */0,
            /* uint32   */0,
            /* sint32   */0,
            /* fixed32  */5,
            /* sfixed32 */5,
            /* int64    */0,
            /* uint64   */0,
            /* sint64   */0,
            /* fixed64  */1,
            /* sfixed64 */1,
            /* bool     */0,
            /* string   */2], 2);

            /**
             * Allowed types for packed repeated fields with their associated wire type.
             * @type {Object.<string,number>}
             * @const
             * @property {number} double=1 Fixed64 wire type
             * @property {number} float=5 Fixed32 wire type
             * @property {number} int32=0 Varint wire type
             * @property {number} uint32=0 Varint wire type
             * @property {number} sint32=0 Varint wire type
             * @property {number} fixed32=5 Fixed32 wire type
             * @property {number} sfixed32=5 Fixed32 wire type
             * @property {number} int64=0 Varint wire type
             * @property {number} uint64=0 Varint wire type
             * @property {number} sint64=0 Varint wire type
             * @property {number} fixed64=1 Fixed64 wire type
             * @property {number} sfixed64=1 Fixed64 wire type
             * @property {number} bool=0 Varint wire type
             */
            types.packed = bake([
            /* double   */1,
            /* float    */5,
            /* int32    */0,
            /* uint32   */0,
            /* sint32   */0,
            /* fixed32  */5,
            /* sfixed32 */5,
            /* int64    */0,
            /* uint64   */0,
            /* sint64   */0,
            /* fixed64  */1,
            /* sfixed64 */1,
            /* bool     */0]);
        }, { "37": 37 }], 37: [function (_require, module, exports) {
            "use strict";

            /**
             * Various utility functions.
             * @namespace
             */

            var util = module.exports = _require(39);

            var roots = _require(30);

            var Type, // cyclic
            Enum;

            util.codegen = _require(3);
            util.fetch = _require(5);
            util.path = _require(8);

            /**
             * Node's fs module if available.
             * @type {Object.<string,*>}
             */
            util.fs = util.inquire("fs");

            /**
             * Converts an object's values to an array.
             * @param {Object.<string,*>} object Object to convert
             * @returns {Array.<*>} Converted array
             */
            util.toArray = function toArray(object) {
                if (object) {
                    var keys = Object.keys(object),
                        array = new Array(keys.length),
                        index = 0;
                    while (index < keys.length) {
                        array[index] = object[keys[index++]];
                    }return array;
                }
                return [];
            };

            /**
             * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
             * @param {Array.<*>} array Array to convert
             * @returns {Object.<string,*>} Converted object
             */
            util.toObject = function toObject(array) {
                var object = {},
                    index = 0;
                while (index < array.length) {
                    var key = array[index++],
                        val = array[index++];
                    if (val !== undefined) object[key] = val;
                }
                return object;
            };

            var safePropBackslashRe = /\\/g,
                safePropQuoteRe = /"/g;

            /**
             * Tests whether the specified name is a reserved word in JS.
             * @param {string} name Name to test
             * @returns {boolean} `true` if reserved, otherwise `false`
             */
            util.isReserved = function isReserved(name) {
                return (/^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name)
                );
            };

            /**
             * Returns a safe property accessor for the specified property name.
             * @param {string} prop Property name
             * @returns {string} Safe accessor
             */
            util.safeProp = function safeProp(prop) {
                if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop)) return "[\"" + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + "\"]";
                return "." + prop;
            };

            /**
             * Converts the first character of a string to upper case.
             * @param {string} str String to convert
             * @returns {string} Converted string
             */
            util.ucFirst = function ucFirst(str) {
                return str.charAt(0).toUpperCase() + str.substring(1);
            };

            var camelCaseRe = /_([a-z])/g;

            /**
             * Converts a string to camel case.
             * @param {string} str String to convert
             * @returns {string} Converted string
             */
            util.camelCase = function camelCase(str) {
                return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function ($0, $1) {
                    return $1.toUpperCase();
                });
            };

            /**
             * Compares reflected fields by id.
             * @param {Field} a First field
             * @param {Field} b Second field
             * @returns {number} Comparison value
             */
            util.compareFieldsById = function compareFieldsById(a, b) {
                return a.id - b.id;
            };

            /**
             * Decorator helper for types (TypeScript).
             * @param {Constructor<T>} ctor Constructor function
             * @param {string} [typeName] Type name, defaults to the constructor's name
             * @returns {Type} Reflected type
             * @template T extends Message<T>
             * @property {Root} root Decorators root
             */
            util.decorateType = function decorateType(ctor, typeName) {

                /* istanbul ignore if */
                if (ctor.$type) {
                    if (typeName && ctor.$type.name !== typeName) {
                        util.decorateRoot.remove(ctor.$type);
                        ctor.$type.name = typeName;
                        util.decorateRoot.add(ctor.$type);
                    }
                    return ctor.$type;
                }

                /* istanbul ignore next */
                if (!Type) Type = _require(35);

                var type = new Type(typeName || ctor.name);
                util.decorateRoot.add(type);
                type.ctor = ctor; // sets up .encode, .decode etc.
                Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
                Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
                return type;
            };

            var decorateEnumIndex = 0;

            /**
             * Decorator helper for enums (TypeScript).
             * @param {Object} object Enum object
             * @returns {Enum} Reflected enum
             */
            util.decorateEnum = function decorateEnum(object) {

                /* istanbul ignore if */
                if (object.$type) return object.$type;

                /* istanbul ignore next */
                if (!Enum) Enum = _require(15);

                var enm = new Enum("Enum" + decorateEnumIndex++, object);
                util.decorateRoot.add(enm);
                Object.defineProperty(object, "$type", { value: enm, enumerable: false });
                return enm;
            };

            /**
             * Decorator root (TypeScript).
             * @name util.decorateRoot
             * @type {Root}
             * @readonly
             */
            Object.defineProperty(util, "decorateRoot", {
                get: function get() {
                    return roots["decorated"] || (roots["decorated"] = new (_require(29))());
                }
            });
        }, { "15": 15, "29": 29, "3": 3, "30": 30, "35": 35, "39": 39, "5": 5, "8": 8 }], 38: [function (_require, module, exports) {
            "use strict";

            module.exports = LongBits;

            var util = _require(39);

            /**
             * Constructs new long bits.
             * @classdesc Helper class for working with the low and high bits of a 64 bit value.
             * @memberof util
             * @constructor
             * @param {number} lo Low 32 bits, unsigned
             * @param {number} hi High 32 bits, unsigned
             */
            function LongBits(lo, hi) {

                // note that the casts below are theoretically unnecessary as of today, but older statically
                // generated converter code might still call the ctor with signed 32bits. kept for compat.

                /**
                 * Low bits.
                 * @type {number}
                 */
                this.lo = lo >>> 0;

                /**
                 * High bits.
                 * @type {number}
                 */
                this.hi = hi >>> 0;
            }

            /**
             * Zero bits.
             * @memberof util.LongBits
             * @type {util.LongBits}
             */
            var zero = LongBits.zero = new LongBits(0, 0);

            zero.toNumber = function () {
                return 0;
            };
            zero.zzEncode = zero.zzDecode = function () {
                return this;
            };
            zero.length = function () {
                return 1;
            };

            /**
             * Zero hash.
             * @memberof util.LongBits
             * @type {string}
             */
            var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

            /**
             * Constructs new long bits from the specified number.
             * @param {number} value Value
             * @returns {util.LongBits} Instance
             */
            LongBits.fromNumber = function fromNumber(value) {
                if (value === 0) return zero;
                var sign = value < 0;
                if (sign) value = -value;
                var lo = value >>> 0,
                    hi = (value - lo) / 4294967296 >>> 0;
                if (sign) {
                    hi = ~hi >>> 0;
                    lo = ~lo >>> 0;
                    if (++lo > 4294967295) {
                        lo = 0;
                        if (++hi > 4294967295) hi = 0;
                    }
                }
                return new LongBits(lo, hi);
            };

            /**
             * Constructs new long bits from a number, long or string.
             * @param {Long|number|string} value Value
             * @returns {util.LongBits} Instance
             */
            LongBits.from = function from(value) {
                if (typeof value === "number") return LongBits.fromNumber(value);
                if (util.isString(value)) {
                    /* istanbul ignore else */
                    if (util.Long) value = util.Long.fromString(value);else return LongBits.fromNumber(parseInt(value, 10));
                }
                return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
            };

            /**
             * Converts this long bits to a possibly unsafe JavaScript number.
             * @param {boolean} [unsigned=false] Whether unsigned or not
             * @returns {number} Possibly unsafe number
             */
            LongBits.prototype.toNumber = function toNumber(unsigned) {
                if (!unsigned && this.hi >>> 31) {
                    var lo = ~this.lo + 1 >>> 0,
                        hi = ~this.hi >>> 0;
                    if (!lo) hi = hi + 1 >>> 0;
                    return -(lo + hi * 4294967296);
                }
                return this.lo + this.hi * 4294967296;
            };

            /**
             * Converts this long bits to a long.
             * @param {boolean} [unsigned=false] Whether unsigned or not
             * @returns {Long} Long
             */
            LongBits.prototype.toLong = function toLong(unsigned) {
                return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
                /* istanbul ignore next */
                : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
            };

            var charCodeAt = String.prototype.charCodeAt;

            /**
             * Constructs new long bits from the specified 8 characters long hash.
             * @param {string} hash Hash
             * @returns {util.LongBits} Bits
             */
            LongBits.fromHash = function fromHash(hash) {
                if (hash === zeroHash) return zero;
                return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);
            };

            /**
             * Converts this long bits to a 8 characters long hash.
             * @returns {string} Hash
             */
            LongBits.prototype.toHash = function toHash() {
                return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
            };

            /**
             * Zig-zag encodes this long bits.
             * @returns {util.LongBits} `this`
             */
            LongBits.prototype.zzEncode = function zzEncode() {
                var mask = this.hi >> 31;
                this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
                this.lo = (this.lo << 1 ^ mask) >>> 0;
                return this;
            };

            /**
             * Zig-zag decodes this long bits.
             * @returns {util.LongBits} `this`
             */
            LongBits.prototype.zzDecode = function zzDecode() {
                var mask = -(this.lo & 1);
                this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
                this.hi = (this.hi >>> 1 ^ mask) >>> 0;
                return this;
            };

            /**
             * Calculates the length of this longbits when encoded as a varint.
             * @returns {number} Length
             */
            LongBits.prototype.length = function length() {
                var part0 = this.lo,
                    part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
                    part2 = this.hi >>> 24;
                return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
            };
        }, { "39": 39 }], 39: [function (_require, module, exports) {
            "use strict";

            var util = exports;

            // used to return a Promise where callback is omitted
            util.asPromise = _require(1);

            // converts to / from base64 encoded strings
            util.base64 = _require(2);

            // base class of rpc.Service
            util.EventEmitter = _require(4);

            // float handling accross browsers
            util.float = _require(6);

            // _requires modules optionally and hides the call from bundlers
            util.inquire = _require(7);

            // converts to / from utf8 encoded strings
            util.utf8 = _require(10);

            // provides a node-like buffer pool in the browser
            util.pool = _require(9);

            // utility to work with the low and high bits of a 64 bit value
            util.LongBits = _require(38);

            /**
             * An immuable empty array.
             * @memberof util
             * @type {Array.<*>}
             * @const
             */
            util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */[]; // used on prototypes

            /**
             * An immutable empty object.
             * @type {Object}
             * @const
             */
            util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */{}; // used on prototypes

            /**
             * Whether running within node or not.
             * @memberof util
             * @type {boolean}
             * @const
             */
            util.isNode = Boolean(global.process && global.process.versions && global.process.versions.node);

            /**
             * Tests if the specified value is an integer.
             * @function
             * @param {*} value Value to test
             * @returns {boolean} `true` if the value is an integer
             */
            util.isInteger = Number.isInteger || /* istanbul ignore next */function isInteger(value) {
                return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
            };

            /**
             * Tests if the specified value is a string.
             * @param {*} value Value to test
             * @returns {boolean} `true` if the value is a string
             */
            util.isString = function isString(value) {
                return typeof value === "string" || value instanceof String;
            };

            /**
             * Tests if the specified value is a non-null object.
             * @param {*} value Value to test
             * @returns {boolean} `true` if the value is a non-null object
             */
            util.isObject = function isObject(value) {
                return value && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object";
            };

            /**
             * Checks if a property on a message is considered to be present.
             * This is an alias of {@link util.isSet}.
             * @function
             * @param {Object} obj Plain object or message instance
             * @param {string} prop Property name
             * @returns {boolean} `true` if considered to be present, otherwise `false`
             */
            util.isset =

            /**
             * Checks if a property on a message is considered to be present.
             * @param {Object} obj Plain object or message instance
             * @param {string} prop Property name
             * @returns {boolean} `true` if considered to be present, otherwise `false`
             */
            util.isSet = function isSet(obj, prop) {
                var value = obj[prop];
                if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
                    return (typeof value === "undefined" ? "undefined" : _typeof(value)) !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
                return false;
            };

            /**
             * Any compatible Buffer instance.
             * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
             * @interface Buffer
             * @extends Uint8Array
             */

            /**
             * Node's Buffer class if available.
             * @type {Constructor<Buffer>}
             */
            util.Buffer = function () {
                try {
                    var Buffer = util.inquire("buffer").Buffer;
                    // refuse to use non-node buffers if not explicitly assigned (perf reasons):
                    return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */null;
                } catch (e) {
                    /* istanbul ignore next */
                    return null;
                }
            }();

            // Internal alias of or polyfull for Buffer.from.
            util._Buffer_from = null;

            // Internal alias of or polyfill for Buffer.allocUnsafe.
            util._Buffer_allocUnsafe = null;

            /**
             * Creates a new buffer of whatever type supported by the environment.
             * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
             * @returns {Uint8Array|Buffer} Buffer
             */
            util.newBuffer = function newBuffer(sizeOrArray) {
                /* istanbul ignore next */
                return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
            };

            /**
             * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
             * @type {Constructor<Uint8Array>}
             */
            util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

            /**
             * Any compatible Long instance.
             * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
             * @interface Long
             * @property {number} low Low bits
             * @property {number} high High bits
             * @property {boolean} unsigned Whether unsigned or not
             */

            /**
             * Long.js's Long class if available.
             * @type {Constructor<Long>}
             */
            util.Long = /* istanbul ignore next */global.dcodeIO && /* istanbul ignore next */global.dcodeIO.Long;

            /**
             * Regular expression used to verify 2 bit (`bool`) map keys.
             * @type {RegExp}
             * @const
             */
            util.key2Re = /^true|false|0|1$/;

            /**
             * Regular expression used to verify 32 bit (`int32` etc.) map keys.
             * @type {RegExp}
             * @const
             */
            util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

            /**
             * Regular expression used to verify 64 bit (`int64` etc.) map keys.
             * @type {RegExp}
             * @const
             */
            util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

            /**
             * Converts a number or long to an 8 characters long hash string.
             * @param {Long|number} value Value to convert
             * @returns {string} Hash
             */
            util.longToHash = function longToHash(value) {
                return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
            };

            /**
             * Converts an 8 characters long hash string to a long or number.
             * @param {string} hash Hash
             * @param {boolean} [unsigned=false] Whether unsigned or not
             * @returns {Long|number} Original value
             */
            util.longFromHash = function longFromHash(hash, unsigned) {
                var bits = util.LongBits.fromHash(hash);
                if (util.Long) return util.Long.fromBits(bits.lo, bits.hi, unsigned);
                return bits.toNumber(Boolean(unsigned));
            };

            /**
             * Merges the properties of the source object into the destination object.
             * @memberof util
             * @param {Object.<string,*>} dst Destination object
             * @param {Object.<string,*>} src Source object
             * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
             * @returns {Object.<string,*>} Destination object
             */
            function merge(dst, src, ifNotSet) {
                // used by converters
                for (var keys = Object.keys(src), i = 0; i < keys.length; ++i) {
                    if (dst[keys[i]] === undefined || !ifNotSet) dst[keys[i]] = src[keys[i]];
                }return dst;
            }

            util.merge = merge;

            /**
             * Converts the first character of a string to lower case.
             * @param {string} str String to convert
             * @returns {string} Converted string
             */
            util.lcFirst = function lcFirst(str) {
                return str.charAt(0).toLowerCase() + str.substring(1);
            };

            /**
             * Creates a custom error constructor.
             * @memberof util
             * @param {string} name Error name
             * @returns {Constructor<Error>} Custom error constructor
             */
            function newError(name) {

                function CustomError(message, properties) {

                    if (!(this instanceof CustomError)) return new CustomError(message, properties);

                    // Error.call(this, message);
                    // ^ just returns a new error instance because the ctor can be called as a function

                    Object.defineProperty(this, "message", { get: function get() {
                            return message;
                        } });

                    /* istanbul ignore next */
                    if (Error.captureStackTrace) // node
                        Error.captureStackTrace(this, CustomError);else Object.defineProperty(this, "stack", { value: new Error().stack || "" });

                    if (properties) merge(this, properties);
                }

                (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

                Object.defineProperty(CustomError.prototype, "name", { get: function get() {
                        return name;
                    } });

                CustomError.prototype.toString = function toString() {
                    return this.name + ": " + this.message;
                };

                return CustomError;
            }

            util.newError = newError;

            /**
             * Constructs a new protocol error.
             * @classdesc Error subclass indicating a protocol specifc error.
             * @memberof util
             * @extends Error
             * @template T extends Message<T>
             * @constructor
             * @param {string} message Error message
             * @param {Object.<string,*>} [properties] Additional properties
             * @example
             * try {
             *     MyMessage.decode(someBuffer); // throws if _required fields are missing
             * } catch (e) {
             *     if (e instanceof ProtocolError && e.instance)
             *         console.log("decoded so far: " + JSON.stringify(e.instance));
             * }
             */
            util.ProtocolError = newError("ProtocolError");

            /**
             * So far decoded message instance.
             * @name util.ProtocolError#instance
             * @type {Message<T>}
             */

            /**
             * A OneOf getter as returned by {@link util.oneOfGetter}.
             * @typedef OneOfGetter
             * @type {function}
             * @returns {string|undefined} Set field name, if any
             */

            /**
             * Builds a getter for a oneof's present field name.
             * @param {string[]} fieldNames Field names
             * @returns {OneOfGetter} Unbound getter
             */
            util.oneOfGetter = function getOneOf(fieldNames) {
                var fieldMap = {};
                for (var i = 0; i < fieldNames.length; ++i) {
                    fieldMap[fieldNames[i]] = 1;
                } /**
                   * @returns {string|undefined} Set field name, if any
                   * @this Object
                   * @ignore
                   */
                return function () {
                    // eslint-disable-line consistent-return
                    for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i) {
                        if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null) return keys[i];
                    }
                };
            };

            /**
             * A OneOf setter as returned by {@link util.oneOfSetter}.
             * @typedef OneOfSetter
             * @type {function}
             * @param {string|undefined} value Field name
             * @returns {undefined}
             */

            /**
             * Builds a setter for a oneof's present field name.
             * @param {string[]} fieldNames Field names
             * @returns {OneOfSetter} Unbound setter
             */
            util.oneOfSetter = function setOneOf(fieldNames) {

                /**
                 * @param {string} name Field name
                 * @returns {undefined}
                 * @this Object
                 * @ignore
                 */
                return function (name) {
                    for (var i = 0; i < fieldNames.length; ++i) {
                        if (fieldNames[i] !== name) delete this[fieldNames[i]];
                    }
                };
            };

            /**
             * Default conversion options used for {@link Message#toJSON} implementations.
             *
             * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
             *
             * - Longs become strings
             * - Enums become string keys
             * - Bytes become base64 encoded strings
             * - (Sub-)Messages become plain objects
             * - Maps become plain objects with all string keys
             * - Repeated fields become arrays
             * - NaN and Infinity for float and double fields become strings
             *
             * @type {IConversionOptions}
             * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
             */
            util.toJSONOptions = {
                longs: String,
                enums: String,
                bytes: String,
                json: true
            };

            util._configure = function () {
                var Buffer = util.Buffer;
                /* istanbul ignore if */
                if (!Buffer) {
                    util._Buffer_from = util._Buffer_allocUnsafe = null;
                    return;
                }
                // because node 4.x buffers are incompatible & immutable
                // see: https://github.com/dcodeIO/protobuf.js/pull/665
                util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
                /* istanbul ignore next */
                function Buffer_from(value, encoding) {
                    return new Buffer(value, encoding);
                };
                util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
                /* istanbul ignore next */
                function Buffer_allocUnsafe(size) {
                    return new Buffer(size);
                };
            };
        }, { "1": 1, "10": 10, "2": 2, "38": 38, "4": 4, "6": 6, "7": 7, "9": 9 }], 40: [function (_require, module, exports) {
            "use strict";

            module.exports = verifier;

            var Enum = _require(15),
                util = _require(37);

            function invalid(field, expected) {
                return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:" + field.keyType + "}" : "") + " expected";
            }

            /**
             * Generates a partial value verifier.
             * @param {Codegen} gen Codegen instance
             * @param {Field} field Reflected field
             * @param {number} fieldIndex Field index
             * @param {string} ref Variable reference
             * @returns {Codegen} Codegen instance
             * @ignore
             */
            function genVerifyValue(gen, field, fieldIndex, ref) {
                /* eslint-disable no-unexpected-multiline */
                if (field.resolvedType) {
                    if (field.resolvedType instanceof Enum) {
                        gen("switch(%s){", ref)("default:")("return%j", invalid(field, "enum value"));
                        for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) {
                            gen("case %i:", field.resolvedType.values[keys[j]]);
                        }gen("break")("}");
                    } else {
                        gen("{")("var e=types[%i].verify(%s);", fieldIndex, ref)("if(e)")("return%j+e", field.name + ".")("}");
                    }
                } else {
                    switch (field.type) {
                        case "int32":
                        case "uint32":
                        case "sint32":
                        case "fixed32":
                        case "sfixed32":
                            gen("if(!util.isInteger(%s))", ref)("return%j", invalid(field, "integer"));
                            break;
                        case "int64":
                        case "uint64":
                        case "sint64":
                        case "fixed64":
                        case "sfixed64":
                            gen("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)("return%j", invalid(field, "integer|Long"));
                            break;
                        case "float":
                        case "double":
                            gen("if(typeof %s!==\"number\")", ref)("return%j", invalid(field, "number"));
                            break;
                        case "bool":
                            gen("if(typeof %s!==\"boolean\")", ref)("return%j", invalid(field, "boolean"));
                            break;
                        case "string":
                            gen("if(!util.isString(%s))", ref)("return%j", invalid(field, "string"));
                            break;
                        case "bytes":
                            gen("if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))", ref, ref, ref)("return%j", invalid(field, "buffer"));
                            break;
                    }
                }
                return gen;
                /* eslint-enable no-unexpected-multiline */
            }

            /**
             * Generates a partial key verifier.
             * @param {Codegen} gen Codegen instance
             * @param {Field} field Reflected field
             * @param {string} ref Variable reference
             * @returns {Codegen} Codegen instance
             * @ignore
             */
            function genVerifyKey(gen, field, ref) {
                /* eslint-disable no-unexpected-multiline */
                switch (field.keyType) {
                    case "int32":
                    case "uint32":
                    case "sint32":
                    case "fixed32":
                    case "sfixed32":
                        gen("if(!util.key32Re.test(%s))", ref)("return%j", invalid(field, "integer key"));
                        break;
                    case "int64":
                    case "uint64":
                    case "sint64":
                    case "fixed64":
                    case "sfixed64":
                        gen("if(!util.key64Re.test(%s))", ref) // see comment above: x is ok, d is not
                        ("return%j", invalid(field, "integer|Long key"));
                        break;
                    case "bool":
                        gen("if(!util.key2Re.test(%s))", ref)("return%j", invalid(field, "boolean key"));
                        break;
                }
                return gen;
                /* eslint-enable no-unexpected-multiline */
            }

            /**
             * Generates a verifier specific to the specified message type.
             * @param {Type} mtype Message type
             * @returns {Codegen} Codegen instance
             */
            function verifier(mtype) {
                /* eslint-disable no-unexpected-multiline */

                var gen = util.codegen(["m"], mtype.name + "$verify")("if(typeof m!==\"object\"||m===null)")("return%j", "object expected");
                var oneofs = mtype.oneofsArray,
                    seenFirstField = {};
                if (oneofs.length) gen("var p={}");

                for (var i = 0; i < /* initializes */mtype.fieldsArray.length; ++i) {
                    var field = mtype._fieldsArray[i].resolve(),
                        ref = "m" + util.safeProp(field.name);

                    if (field.optional) gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name); // !== undefined && !== null

                    // map fields
                    if (field.map) {
                        gen("if(!util.isObject(%s))", ref)("return%j", invalid(field, "object"))("var k=Object.keys(%s)", ref)("for(var i=0;i<k.length;++i){");
                        genVerifyKey(gen, field, "k[i]");
                        genVerifyValue(gen, field, i, ref + "[k[i]]")("}");

                        // repeated fields
                    } else if (field.repeated) {
                        gen("if(!Array.isArray(%s))", ref)("return%j", invalid(field, "array"))("for(var i=0;i<%s.length;++i){", ref);
                        genVerifyValue(gen, field, i, ref + "[i]")("}");

                        // _required or present fields
                    } else {
                        if (field.partOf) {
                            var oneofProp = util.safeProp(field.partOf.name);
                            if (seenFirstField[field.partOf.name] === 1) gen("if(p%s===1)", oneofProp)("return%j", field.partOf.name + ": multiple values");
                            seenFirstField[field.partOf.name] = 1;
                            gen("p%s=1", oneofProp);
                        }
                        genVerifyValue(gen, field, i, ref);
                    }
                    if (field.optional) gen("}");
                }
                return gen("return null");
                /* eslint-enable no-unexpected-multiline */
            }
        }, { "15": 15, "37": 37 }], 41: [function (_require, module, exports) {
            "use strict";

            /**
             * Wrappers for common types.
             * @type {Object.<string,IWrapper>}
             * @const
             */

            var wrappers = exports;

            var Message = _require(21);

            /**
             * From object converter part of an {@link IWrapper}.
             * @typedef WrapperFromObjectConverter
             * @type {function}
             * @param {Object.<string,*>} object Plain object
             * @returns {Message<{}>} Message instance
             * @this Type
             */

            /**
             * To object converter part of an {@link IWrapper}.
             * @typedef WrapperToObjectConverter
             * @type {function}
             * @param {Message<{}>} message Message instance
             * @param {IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             * @this Type
             */

            /**
             * Common type wrapper part of {@link wrappers}.
             * @interface IWrapper
             * @property {WrapperFromObjectConverter} [fromObject] From object converter
             * @property {WrapperToObjectConverter} [toObject] To object converter
             */

            // Custom wrapper for Any
            wrappers[".google.protobuf.Any"] = {

                fromObject: function fromObject(object) {

                    // unwrap value type if mapped
                    if (object && object["@type"]) {
                        var type = this.lookup(object["@type"]);
                        /* istanbul ignore else */
                        if (type) {
                            // type_url does not accept leading "."
                            var type_url = object["@type"].charAt(0) === "." ? object["@type"].substr(1) : object["@type"];
                            // type_url prefix is optional, but path seperator is _required
                            return this.create({
                                type_url: "/" + type_url,
                                value: type.encode(type.fromObject(object)).finish()
                            });
                        }
                    }

                    return this.fromObject(object);
                },

                toObject: function toObject(message, options) {

                    // decode value if requested and unmapped
                    if (options && options.json && message.type_url && message.value) {
                        // Only use fully qualified type name after the last '/'
                        var name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
                        var type = this.lookup(name);
                        /* istanbul ignore else */
                        if (type) message = type.decode(message.value);
                    }

                    // wrap value if unmapped
                    if (!(message instanceof this.ctor) && message instanceof Message) {
                        var object = message.$type.toObject(message, options);
                        object["@type"] = message.$type.fullName;
                        return object;
                    }

                    return this.toObject(message, options);
                }
            };
        }, { "21": 21 }], 42: [function (_require, module, exports) {
            "use strict";

            module.exports = Writer;

            var util = _require(39);

            var BufferWriter; // cyclic

            var LongBits = util.LongBits,
                base64 = util.base64,
                utf8 = util.utf8;

            /**
             * Constructs a new writer operation instance.
             * @classdesc Scheduled writer operation.
             * @constructor
             * @param {function(*, Uint8Array, number)} fn Function to call
             * @param {number} len Value byte length
             * @param {*} val Value to write
             * @ignore
             */
            function Op(fn, len, val) {

                /**
                 * Function to call.
                 * @type {function(Uint8Array, number, *)}
                 */
                this.fn = fn;

                /**
                 * Value byte length.
                 * @type {number}
                 */
                this.len = len;

                /**
                 * Next operation.
                 * @type {Writer.Op|undefined}
                 */
                this.next = undefined;

                /**
                 * Value to write.
                 * @type {*}
                 */
                this.val = val; // type varies
            }

            /* istanbul ignore next */
            function noop() {} // eslint-disable-line no-empty-function

            /**
             * Constructs a new writer state instance.
             * @classdesc Copied writer state.
             * @memberof Writer
             * @constructor
             * @param {Writer} writer Writer to copy state from
             * @ignore
             */
            function State(writer) {

                /**
                 * Current head.
                 * @type {Writer.Op}
                 */
                this.head = writer.head;

                /**
                 * Current tail.
                 * @type {Writer.Op}
                 */
                this.tail = writer.tail;

                /**
                 * Current buffer length.
                 * @type {number}
                 */
                this.len = writer.len;

                /**
                 * Next state.
                 * @type {State|null}
                 */
                this.next = writer.states;
            }

            /**
             * Constructs a new writer instance.
             * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
             * @constructor
             */
            function Writer() {

                /**
                 * Current length.
                 * @type {number}
                 */
                this.len = 0;

                /**
                 * Operations head.
                 * @type {Object}
                 */
                this.head = new Op(noop, 0, 0);

                /**
                 * Operations tail
                 * @type {Object}
                 */
                this.tail = this.head;

                /**
                 * Linked forked states.
                 * @type {Object|null}
                 */
                this.states = null;

                // When a value is written, the writer calculates its byte length and puts it into a linked
                // list of operations to perform when finish() is called. This both allows us to allocate
                // buffers of the exact _required size and reduces the amount of work we have to do compared
                // to first calculating over objects and then encoding over objects. In our case, the encoding
                // part is just a linked list walk calling operations with already prepared values.
            }

            /**
             * Creates a new writer.
             * @function
             * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
             */
            Writer.create = util.Buffer ? function create_buffer_setup() {
                return (Writer.create = function create_buffer() {
                    return new BufferWriter();
                })();
            }
            /* istanbul ignore next */
            : function create_array() {
                return new Writer();
            };

            /**
             * Allocates a buffer of the specified size.
             * @param {number} size Buffer size
             * @returns {Uint8Array} Buffer
             */
            Writer.alloc = function alloc(size) {
                return new util.Array(size);
            };

            // Use Uint8Array buffer pool in the browser, just like node does with buffers
            /* istanbul ignore else */
            if (util.Array !== Array) Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

            /**
             * Pushes a new operation to the queue.
             * @param {function(Uint8Array, number, *)} fn Function to call
             * @param {number} len Value byte length
             * @param {number} val Value to write
             * @returns {Writer} `this`
             * @private
             */
            Writer.prototype._push = function push(fn, len, val) {
                this.tail = this.tail.next = new Op(fn, len, val);
                this.len += len;
                return this;
            };

            function writeByte(val, buf, pos) {
                buf[pos] = val & 255;
            }

            function writeVarint32(val, buf, pos) {
                while (val > 127) {
                    buf[pos++] = val & 127 | 128;
                    val >>>= 7;
                }
                buf[pos] = val;
            }

            /**
             * Constructs a new varint writer operation instance.
             * @classdesc Scheduled varint writer operation.
             * @extends Op
             * @constructor
             * @param {number} len Value byte length
             * @param {number} val Value to write
             * @ignore
             */
            function VarintOp(len, val) {
                this.len = len;
                this.next = undefined;
                this.val = val;
            }

            VarintOp.prototype = Object.create(Op.prototype);
            VarintOp.prototype.fn = writeVarint32;

            /**
             * Writes an unsigned 32 bit value as a varint.
             * @param {number} value Value to write
             * @returns {Writer} `this`
             */
            Writer.prototype.uint32 = function write_uint32(value) {
                // here, the call to this.push has been inlined and a varint specific Op subclass is used.
                // uint32 is by far the most frequently used operation and benefits significantly from this.
                this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
                return this;
            };

            /**
             * Writes a signed 32 bit value as a varint.
             * @function
             * @param {number} value Value to write
             * @returns {Writer} `this`
             */
            Writer.prototype.int32 = function write_int32(value) {
                return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
                : this.uint32(value);
            };

            /**
             * Writes a 32 bit value as a varint, zig-zag encoded.
             * @param {number} value Value to write
             * @returns {Writer} `this`
             */
            Writer.prototype.sint32 = function write_sint32(value) {
                return this.uint32((value << 1 ^ value >> 31) >>> 0);
            };

            function writeVarint64(val, buf, pos) {
                while (val.hi) {
                    buf[pos++] = val.lo & 127 | 128;
                    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
                    val.hi >>>= 7;
                }
                while (val.lo > 127) {
                    buf[pos++] = val.lo & 127 | 128;
                    val.lo = val.lo >>> 7;
                }
                buf[pos++] = val.lo;
            }

            /**
             * Writes an unsigned 64 bit value as a varint.
             * @param {Long|number|string} value Value to write
             * @returns {Writer} `this`
             * @throws {TypeError} If `value` is a string and no long library is present.
             */
            Writer.prototype.uint64 = function write_uint64(value) {
                var bits = LongBits.from(value);
                return this._push(writeVarint64, bits.length(), bits);
            };

            /**
             * Writes a signed 64 bit value as a varint.
             * @function
             * @param {Long|number|string} value Value to write
             * @returns {Writer} `this`
             * @throws {TypeError} If `value` is a string and no long library is present.
             */
            Writer.prototype.int64 = Writer.prototype.uint64;

            /**
             * Writes a signed 64 bit value as a varint, zig-zag encoded.
             * @param {Long|number|string} value Value to write
             * @returns {Writer} `this`
             * @throws {TypeError} If `value` is a string and no long library is present.
             */
            Writer.prototype.sint64 = function write_sint64(value) {
                var bits = LongBits.from(value).zzEncode();
                return this._push(writeVarint64, bits.length(), bits);
            };

            /**
             * Writes a boolish value as a varint.
             * @param {boolean} value Value to write
             * @returns {Writer} `this`
             */
            Writer.prototype.bool = function write_bool(value) {
                return this._push(writeByte, 1, value ? 1 : 0);
            };

            function writeFixed32(val, buf, pos) {
                buf[pos] = val & 255;
                buf[pos + 1] = val >>> 8 & 255;
                buf[pos + 2] = val >>> 16 & 255;
                buf[pos + 3] = val >>> 24;
            }

            /**
             * Writes an unsigned 32 bit value as fixed 32 bits.
             * @param {number} value Value to write
             * @returns {Writer} `this`
             */
            Writer.prototype.fixed32 = function write_fixed32(value) {
                return this._push(writeFixed32, 4, value >>> 0);
            };

            /**
             * Writes a signed 32 bit value as fixed 32 bits.
             * @function
             * @param {number} value Value to write
             * @returns {Writer} `this`
             */
            Writer.prototype.sfixed32 = Writer.prototype.fixed32;

            /**
             * Writes an unsigned 64 bit value as fixed 64 bits.
             * @param {Long|number|string} value Value to write
             * @returns {Writer} `this`
             * @throws {TypeError} If `value` is a string and no long library is present.
             */
            Writer.prototype.fixed64 = function write_fixed64(value) {
                var bits = LongBits.from(value);
                return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
            };

            /**
             * Writes a signed 64 bit value as fixed 64 bits.
             * @function
             * @param {Long|number|string} value Value to write
             * @returns {Writer} `this`
             * @throws {TypeError} If `value` is a string and no long library is present.
             */
            Writer.prototype.sfixed64 = Writer.prototype.fixed64;

            /**
             * Writes a float (32 bit).
             * @function
             * @param {number} value Value to write
             * @returns {Writer} `this`
             */
            Writer.prototype.float = function write_float(value) {
                return this._push(util.float.writeFloatLE, 4, value);
            };

            /**
             * Writes a double (64 bit float).
             * @function
             * @param {number} value Value to write
             * @returns {Writer} `this`
             */
            Writer.prototype.double = function write_double(value) {
                return this._push(util.float.writeDoubleLE, 8, value);
            };

            var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
                buf.set(val, pos); // also works for plain array values
            }
            /* istanbul ignore next */
            : function writeBytes_for(val, buf, pos) {
                for (var i = 0; i < val.length; ++i) {
                    buf[pos + i] = val[i];
                }
            };

            /**
             * Writes a sequence of bytes.
             * @param {Uint8Array|string} value Buffer or base64 encoded string to write
             * @returns {Writer} `this`
             */
            Writer.prototype.bytes = function write_bytes(value) {
                var len = value.length >>> 0;
                if (!len) return this._push(writeByte, 1, 0);
                if (util.isString(value)) {
                    var buf = Writer.alloc(len = base64.length(value));
                    base64.decode(value, buf, 0);
                    value = buf;
                }
                return this.uint32(len)._push(writeBytes, len, value);
            };

            /**
             * Writes a string.
             * @param {string} value Value to write
             * @returns {Writer} `this`
             */
            Writer.prototype.string = function write_string(value) {
                var len = utf8.length(value);
                return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
            };

            /**
             * Forks this writer's state by pushing it to a stack.
             * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
             * @returns {Writer} `this`
             */
            Writer.prototype.fork = function fork() {
                this.states = new State(this);
                this.head = this.tail = new Op(noop, 0, 0);
                this.len = 0;
                return this;
            };

            /**
             * Resets this instance to the last state.
             * @returns {Writer} `this`
             */
            Writer.prototype.reset = function reset() {
                if (this.states) {
                    this.head = this.states.head;
                    this.tail = this.states.tail;
                    this.len = this.states.len;
                    this.states = this.states.next;
                } else {
                    this.head = this.tail = new Op(noop, 0, 0);
                    this.len = 0;
                }
                return this;
            };

            /**
             * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
             * @returns {Writer} `this`
             */
            Writer.prototype.ldelim = function ldelim() {
                var head = this.head,
                    tail = this.tail,
                    len = this.len;
                this.reset().uint32(len);
                if (len) {
                    this.tail.next = head.next; // skip noop
                    this.tail = tail;
                    this.len += len;
                }
                return this;
            };

            /**
             * Finishes the write operation.
             * @returns {Uint8Array} Finished buffer
             */
            Writer.prototype.finish = function finish() {
                var head = this.head.next,
                    // skip noop
                buf = this.constructor.alloc(this.len),
                    pos = 0;
                while (head) {
                    head.fn(head.val, buf, pos);
                    pos += head.len;
                    head = head.next;
                }
                // this.head = this.tail = null;
                return buf;
            };

            Writer._configure = function (BufferWriter_) {
                BufferWriter = BufferWriter_;
            };
        }, { "39": 39 }], 43: [function (_require, module, exports) {
            "use strict";

            module.exports = BufferWriter;

            // extends Writer
            var Writer = _require(42);
            (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

            var util = _require(39);

            var Buffer = util.Buffer;

            /**
             * Constructs a new buffer writer instance.
             * @classdesc Wire format writer using node buffers.
             * @extends Writer
             * @constructor
             */
            function BufferWriter() {
                Writer.call(this);
            }

            /**
             * Allocates a buffer of the specified size.
             * @param {number} size Buffer size
             * @returns {Buffer} Buffer
             */
            BufferWriter.alloc = function alloc_buffer(size) {
                return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
            };

            var writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
                buf.set(val, pos); // faster than copy (_requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
                // also works for plain array values
            }
            /* istanbul ignore next */
            : function writeBytesBuffer_copy(val, buf, pos) {
                if (val.copy) // Buffer values
                    val.copy(buf, pos, 0, val.length);else for (var i = 0; i < val.length;) {
                    // plain array values
                    buf[pos++] = val[i++];
                }
            };

            /**
             * @override
             */
            BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
                if (util.isString(value)) value = util._Buffer_from(value, "base64");
                var len = value.length >>> 0;
                this.uint32(len);
                if (len) this._push(writeBytesBuffer, len, value);
                return this;
            };

            function writeStringBuffer(val, buf, pos) {
                if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
                    util.utf8.write(val, buf, pos);else buf.utf8Write(val, pos);
            }

            /**
             * @override
             */
            BufferWriter.prototype.string = function write_string_buffer(value) {
                var len = Buffer.byteLength(value);
                this.uint32(len);
                if (len) this._push(writeStringBuffer, len, value);
                return this;
            };

            /**
             * Finishes the write operation.
             * @name BufferWriter#finish
             * @function
             * @returns {Buffer} Finished buffer
             */
        }, { "39": 39, "42": 42 }] }, {}, [19]);
})((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && window || (typeof self === "undefined" ? "undefined" : _typeof(self)) === "object" && self || undefined);
//# sourceMappingURL=protobuf.js.map
/* ================ probufcontent.js ================= */
var err = "syntax = \"proto3\";\npackage stream;\nenum ErrorCode\n{\n\tNoError = 0;\n\tOK = 200;\n\tAccepted = 202;\n\tNoContent = 204;\n\tBadRequest = 400;\n\tUnauthorized = 401;\n\tSignatureFailed = 402;\n\tForbidden = 403;\n\tNotFound = 404;\n\tInternalServerError = 500;\n\tNotImplemented = 501;\n\tBadGateway = 502;\n\tServiceUnavailable = 503;\n}";
var gateWay = "syntax = \"proto3\";\npackage stream;\nenum ErrorCode\n{\n\tNoError = 0;\n\tOK = 200;\n\tAccepted = 202;\n\tNoContent = 204;\n\tBadRequest = 400;\n\tUnauthorized = 401;\n\tSignatureFailed = 402;\n\tForbidden = 403;\n\tNotFound = 404;\n\tInternalServerError = 500;\n\tNotImplemented = 501;\n\tBadGateway = 502;\n\tServiceUnavailable = 503;\n}\nenum CmdId\n{\n\tNoCmd = 0;\n\n\tloginReq = 1101;\n\tloginRsp = 1102;\n\n\tlogoutReq = 1105;\n\tlogoutRsp = 1106;\n\n\theartBeatReq = 1103;\n\n\tnetworkStateReq = 1120;\n\tnetworkStateRsp = 1121;\n\tnoticeNetworkStateReq = 1122;\n\n\tcreateRoomReq = 1203;\n\tcreateRoomRsp = 1204;\n\n\tgetRoomListReq = 1207;\n\tgetRoomListRsp = 1208;\n\n\tjoinRoomReq = 1201;\n\tjoinRoomRsp = 1202;\n\tnoticeUserJoinReq = 1301;\n\n\tleaveRoomReq = 1205;\n\tleaveRoomRsp = 1206;\n\tnoticeUserLeaveReq = 1302;\n\n\tjoinOverReq = 1213;\n\tjoinOverRsp = 1214;\n\n\tdisconnectReq = 1107;\n\tdisconnectRsp = 1108;\n\n\tkickPlayerReq = 1303;\n\tkickPlayerRsp = 1304;\n\tkickPlayerNotify = 1305;\n}\nenum JoinRoomType\n{\n\tNoJoin = 0;\n\tjoinSpecialRoom = 1;\n\tjoinRoomWithProperty = 2;\n\tjoinRandomRoom = 3;\n}\nmessage LoginReq\n{\n\tuint32 gameID = 1;\n\tstring appKey = 2;\n\tstring deviceID = 3;\n\tstring sign = 4;\n}\nmessage LoginRsp\n{\n\tErrorCode status = 1;\n\tuint64 roomID = 2[jstype=JS_STRING];\n}\nmessage HeartbeatReq\n{\n\tuint32 gameID = 1;\n}\nmessage HeartbeatRsp\n{\n\tuint32 gameID = 1;\n\tint32 gsExist = 2;\n}\nmessage DisconnectReq\n{\n\tuint32 userID = 1;\n\tuint32 gameID = 2;\n\tuint64 roomId = 3[jstype=JS_STRING];\n}\nmessage DisconnectRsp\n{\n\tErrorCode status = 1;\n}\nmessage LogoutRsp\n{\n\tErrorCode status = 1;\n}\nmessage keyValue\n{\n\tstring key = 1;\n\tstring value = 2;\n}\nmessage PlayerInfo\n{\n\tuint32 userID = 1;\n\tbytes userProfile = 2;\n}\nmessage BookInfo\n{\n\tstring bookID = 1;\n\tstring bookKey = 2;\n\tstring hotelAddr = 3;\n}\nmessage RoomInfo\n{\n\tuint64 roomID = 1[jstype=JS_STRING];\n\tstring roomName = 2;\n\tuint32 maxPlayer = 3;\n\tint32 mode = 4;\n\tint32 canWatch = 5;\n\tint32 visibility = 6;\n\tbytes roomProperty = 7;\n\tuint32 owner = 8;\n}\nmessage JoinRoomReq\n{\n\tJoinRoomType joinType = 1;\n\tPlayerInfo playerInfo = 2;\n\tuint32 gameID = 3;\n\tRoomInfo roomInfo = 4;\n\trepeated keyValue tags = 5;\n\tbytes cpProto = 6;\n}\nmessage JoinRoomRsp\n{\n\tErrorCode status = 1;\n\trepeated PlayerInfo users = 2;\n\tRoomInfo roomInfo = 3;\n\tBookInfo bookInfo = 4;\n\tbytes cpProto = 5;\n}\nmessage NoticeJoin\n{\n\tPlayerInfo user = 1;\n}\nmessage NoticeLeave\n{\n\tuint32 userID = 1;\n\tuint64 roomID = 2[jstype=JS_STRING];\n\tuint32 owner = 3;\n}\nmessage JoinOverReq\n{\n\tuint64 roomID = 1[jstype=JS_STRING];\n\tuint32 gameID = 2;\n\tbytes cpProto = 3;\n\tuint32 userID = 4;\n}\nmessage JoinOverRsp\n{\n\tErrorCode status = 1;\n\tbytes cpProto = 2;\n}\nmessage LeaveRoomReq\n{\n\tuint32 userID = 1;\n\tuint32 gameID = 2;\n\tuint64 roomID = 3[jstype=JS_STRING];\n\tbytes cpProto = 4;\n}\nmessage LeaveRoomRsp\n{\n\tErrorCode status = 1;\n\tuint64 roomID = 2[jstype=JS_STRING];\n\tuint32 userID = 3;\n\tbytes cpProto = 4;\n}\nmessage TcpProtoHeader\n{\n    uint32 size= 1;\n    uint32 seq = 2;\n    uint32 cmd = 3;\n    uint32 version = 4;\n    uint32 userID = 5;\n}\nmessage ConnDetailV2 {\n    uint32 userID = 1;\n    uint32 gameID = 2;\n    uint32 fieldID = 3;\n    uint64 roomID = 4[jstype=JS_STRING];\n    uint64 heartBeatTime = 5[jstype=JS_STRING];\n    uint32 version = 6;\n}\nmessage UserV2 {\n    uint32 user_id = 1;\n    uint32 game_id = 2;\n    uint32 version_sdk = 3;\n    uint64 connection_id = 4[jstype=JS_STRING];\n    uint32 service_id = 5;\n    uint64 room_id = 6[jstype=JS_STRING];\n    string device_id = 7;\n    uint32 conn_status = 8;\n}\nmessage NetworkStateReq {\n    uint32 gameID = 1;\n    uint64 roomID = 2[jstype=JS_STRING];\n    uint32 UserID = 3;\n    uint32 state = 4;\n}\nmessage NetworkStateRsp {\n    uint32 status = 1;\n}\nmessage NetworkStateNotify {\n    uint64 roomID = 1[jstype=JS_STRING];\n    uint32 UserID = 2;\n    uint32 state = 3;\n    uint32 owner = 4;\n}\nmessage CreateRoom {\n\tPlayerInfo playerInfo = 1;\n\tuint32 gameID = 2;\n\tRoomInfo roomInfo = 3;\n}\nmessage CreateRoomRsp\n{\n\tErrorCode status = 1;\n\tuint64 roomID = 2[jstype=JS_STRING];\n\tBookInfo bookInfo = 3;\n    uint32 owner = 4;\n}\nmessage GetRoomList\n{\n\tuint32 gameID = 1;\n\tRoomFilter roomFilter = 2;\n}\nmessage RoomFilter\n{\n\tuint32 maxPlayer = 1;\n\tint32 mode = 2;\n\tint32 canWatch = 3;\n\tbytes roomProperty = 4;\n}\nmessage GetRoomListRsp\n{\n\tErrorCode status = 1;\n\trepeated RoomInfo roomInfo = 2;\n}\nmessage KickPlayer\n{\n\tuint64 roomID = 1[jstype=JS_STRING];\n\tuint32 srcUserID = 2;\n\tuint32 userID = 3;\n\tbytes cpProto = 4;\n}\nmessage KickPlayerRsp\n{\n\tErrorCode status = 1;\n\tuint32 userID = 2;\n\tuint64 roomID = 3[jstype=JS_STRING];\n    uint32 owner = 4;\n}\nmessage KickPlayerNotify\n{\n\tuint32 srcUserID = 1;\n\tuint32 userID = 2;\n\tbytes cpProto = 3;\n    uint32 owner = 4;\n}\n";
var sdk = "syntax = \"proto3\";\n\npackage stream;\n\nenum SDKHotelCmdID {\n    InValidSDKCmd    = 0;\n    CheckinCMDID    = 1401;\n    CheckinAckCMDID = 1402;\n    HeartbeatCMDID    = 1403;\n    HeartbeatAckCMDID = 1404;\n    BroadcastCMDID    = 1405;\n    BroadcastAckCMDID = 1406;\n\n    NotifyCMDID = 1408;\n\n    CheckInNotifyCMDID = 1410;\n\n    SubscribeCMDID    = 1411;\n    SubscribeAckCMDID = 1412;\n\n    PublishCMDID    = 1413;\n    PublishAckCMDID = 1414;\n\n    PublishNotifyCMDID = 1416;\n}\n\nmessage CheckIn {\n    uint32 gameID = 1;\n    uint64 roomID = 2[jstype=JS_STRING];\n    uint32 userID = 3;\n    string bookID = 4;\n    string key = 5;\n}\n\nmessage CheckInAck {\n    uint32 status = 1;\n    string bookID = 2;\n    repeated uint32 checkins = 3;\n    repeated uint32 players = 4;\n    uint32 maxPlayers = 5;\n}\n\nmessage Heartbeat {\n    uint32 gameID = 1;\n    uint64 roomID = 2[jstype=JS_STRING];\n    uint32 userID = 3;\n}\n\nmessage HeartbeatAck {\n    uint32 status = 1;\n}\n\nmessage Broadcast {\n    uint64 roomID = 1[jstype=JS_STRING];\n    uint32 flag = 2;\n    repeated uint32 dstUids = 3;\n    bytes cpProto = 4;\n}\n\nmessage BroadcastAck {\n    uint32 status = 1;\n}\n\nmessage CheckInNotify {\n    uint32 userID = 1;\n    string bookID = 2;\n    repeated uint32 checkins = 3;\n    repeated uint32 players = 4;\n    uint32 maxPlayers = 5;\n}\n\nmessage Notify {\n    uint32 srcUid = 1;\n    uint32 priority = 2;\n    bytes cpProto = 3;\n}\n\nmessage Subscribe {\n    uint32 gameID = 1;\n    uint64 roomID = 2[jstype=JS_STRING];\n    repeated string confirms = 3;\n    repeated string cancels = 4;\n}\n\nmessage SubscribeAck {\n    uint32 status = 1;\n    repeated string groups = 2;\n}\n\nmessage Publish {\n    uint64 roomID = 1[jstype=JS_STRING];\n    uint32 priority = 2;\n    repeated string groups = 3;\n    bytes cpProto = 4;\n}\n\nmessage PublishAck {\n    uint32 status = 1;\n    uint32 dstNum = 2;\n}\n\nmessage PublishNotify {\n    uint32 srcUid = 1;\n    uint32 priority = 2;\n    repeated string groups = 3;\n    bytes cpProto = 4;\n}";
/* ================ md5.js ================= */
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0; /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad = ""; /* base-64 pad character. "=" for strict RFC compliance   */
var chrsz = 8; /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_md5(s) {
    return binl2hex(core_md5(str2binl(s), s.length * chrsz));
}
function b64_md5(s) {
    return binl2b64(core_md5(str2binl(s), s.length * chrsz));
}
function str_md5(s) {
    return binl2str(core_md5(str2binl(s), s.length * chrsz));
}
function hex_hmac_md5(key, data) {
    return binl2hex(core_hmac_md5(key, data));
}
function b64_hmac_md5(key, data) {
    return binl2b64(core_hmac_md5(key, data));
}
function str_hmac_md5(key, data) {
    return binl2str(core_hmac_md5(key, data));
}

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test() {
    return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len) {
    /* append padding */
    x[len >> 5] |= 0x80 << len % 32;
    x[(len + 64 >>> 9 << 4) + 14] = len;

    var a = 1732584193;
    var b = -271733879;
    var c = -1732584194;
    var d = 271733878;

    for (var i = 0; i < x.length; i += 16) {
        var olda = a;
        var oldb = b;
        var oldc = c;
        var oldd = d;

        a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
        d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);

        a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
        a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);

        a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
        c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);

        a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
        d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);

        a = safe_add(a, olda);
        b = safe_add(b, oldb);
        c = safe_add(c, oldc);
        d = safe_add(d, oldd);
    }
    return Array(a, b, c, d);
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t) {
    return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
}
function md5_ff(a, b, c, d, x, s, t) {
    return md5_cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t) {
    return md5_cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t) {
    return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t) {
    return md5_cmn(c ^ (b | ~d), a, b, x, s, t);
}

/*
 * Calculate the HMAC-MD5, of a key and some data
 */
function core_hmac_md5(key, data) {
    var bkey = str2binl(key);
    if (bkey.length > 16) bkey = core_md5(bkey, key.length * chrsz);

    var ipad = Array(16),
        opad = Array(16);
    for (var i = 0; i < 16; i++) {
        ipad[i] = bkey[i] ^ 0x36363636;
        opad[i] = bkey[i] ^ 0x5C5C5C5C;
    }

    var hash = core_md5(ipad.concat(str2binl(data)), 512 + data.length * chrsz);
    return core_md5(opad.concat(hash), 512 + 128);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y) {
    var lsw = (x & 0xFFFF) + (y & 0xFFFF);
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 0xFFFF;
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt) {
    return num << cnt | num >>> 32 - cnt;
}

/*
 * Convert a string to an array of little-endian words
 * If chrsz is ASCII, characters >255 have their hi-byte silently ignored.
 */
function str2binl(str) {
    var bin = Array();
    var mask = (1 << chrsz) - 1;
    for (var i = 0; i < str.length * chrsz; i += chrsz) {
        bin[i >> 5] |= (str.charCodeAt(i / chrsz) & mask) << i % 32;
    }return bin;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2str(bin) {
    var str = "";
    var mask = (1 << chrsz) - 1;
    for (var i = 0; i < bin.length * 32; i += chrsz) {
        str += String.fromCharCode(bin[i >> 5] >>> i % 32 & mask);
    }return str;
}

/*
 * Convert an array of little-endian words to a hex string.
 */
function binl2hex(binarray) {
    var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
    var str = "";
    for (var i = 0; i < binarray.length * 4; i++) {
        str += hex_tab.charAt(binarray[i >> 2] >> i % 4 * 8 + 4 & 0xF) + hex_tab.charAt(binarray[i >> 2] >> i % 4 * 8 & 0xF);
    }
    return str;
}

/*
 * Convert an array of little-endian words to a base-64 string
 */
function binl2b64(binarray) {
    var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var str = "";
    for (var i = 0; i < binarray.length * 4; i += 3) {
        var triplet = (binarray[i >> 2] >> 8 * (i % 4) & 0xFF) << 16 | (binarray[i + 1 >> 2] >> 8 * ((i + 1) % 4) & 0xFF) << 8 | binarray[i + 2 >> 2] >> 8 * ((i + 2) % 4) & 0xFF;
        for (var j = 0; j < 4; j++) {
            if (i * 8 + j * 6 > binarray.length * 32) str += b64pad;else str += tab.charAt(triplet >> 6 * (3 - j) & 0x3F);
        }
    }
    return str;
}
/* ================ format.js ================= */
//
// format - printf-like string formatting for JavaScript
// github.com/samsonjs/format
// @_sjs
//
// Copyright 2010 - 2013 Sami Samhuri <sami@samhuri.net>
//
// MIT License
// http://sjs.mit-license.org
//

var format = function format(fmt) {
    var argIndex = 1 // skip initial format argument
    ,
        args = [].slice.call(arguments),
        i = 0,
        n = fmt.length,
        result = '',
        c,
        escaped = false,
        arg,
        tmp,
        leadingZero = false,
        precision,
        nextArg = function nextArg() {
        return args[argIndex++];
    },
        slurpNumber = function slurpNumber() {
        var digits = '';
        while (/\d/.test(fmt[i])) {
            digits += fmt[i++];
            c = fmt[i];
        }
        return digits.length > 0 ? parseInt(digits) : null;
    };
    for (; i < n; ++i) {
        c = fmt[i];
        if (escaped) {
            escaped = false;
            if (c == '.') {
                leadingZero = false;
                c = fmt[++i];
            } else if (c == '0' && fmt[i + 1] == '.') {
                leadingZero = true;
                i += 2;
                c = fmt[i];
            } else {
                leadingZero = true;
            }
            precision = slurpNumber();
            switch (c) {
                case 'b':
                    // number in binary
                    result += parseInt(nextArg(), 10).toString(2);
                    break;
                case 'c':
                    // character
                    arg = nextArg();
                    if (typeof arg === 'string' || arg instanceof String) result += arg;else result += String.fromCharCode(parseInt(arg, 10));
                    break;
                case 'd':
                    // number in decimal
                    result += parseInt(nextArg(), 10);
                    break;
                case 'f':
                    // floating point number
                    tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
                    result += leadingZero ? tmp : tmp.replace(/^0/, '');
                    break;
                case 'j':
                    // JSON
                    result += JSON.stringify(nextArg());
                    break;
                case 'o':
                    // number in octal
                    result += '0' + parseInt(nextArg(), 10).toString(8);
                    break;
                case 's':
                    // string
                    result += nextArg();
                    break;
                case 'x':
                    // lowercase hexadecimal
                    result += '0x' + parseInt(nextArg(), 10).toString(16);
                    break;
                case 'X':
                    // uppercase hexadecimal
                    result += '0x' + parseInt(nextArg(), 10).toString(16).toUpperCase();
                    break;
                default:
                    result += c;
                    break;
            }
        } else if (c === '%') {
            escaped = true;
        } else {
            result += c;
        }
    }
    return result;
};
/* ================ mvsconfig.js ================= */
/**
 * http
 * @type {{GETHOSTLIST_URL: string, REGISTER_USER_URL: string}}
 */
var AlphaHttpConf = {
    HOST_GATWAY_ADDR: "ws://115.231.9.79:7001", //gatway
    GETHOSTLIST_URL: "http://testuser.matchvs.com", //hostlist
    REGISTER_USER_URL: "http://testuser.matchvs.com" //
};

var ReleaseHttpConf = {
    HOST_GATWAY_ADDR: "ws://115.231.9.79:7001", //gatway
    GETHOSTLIST_URL: "http://testuser.matchvs.com", //hostlist
    REGISTER_USER_URL: "http://testuser.matchvs.com" //
};

var TestHttpConf = {
    HOST_GATWAY_ADDR: "ws://115.231.9.79:7001", //gatway
    GETHOSTLIST_URL: "http://testuser.matchvs.com", //hostlist
    REGISTER_USER_URL: "http://testuser.matchvs.com" //
};
var LocalConf = {
    HOST_GATWAY_ADDR: "ws://192.168.9.94:12345/ws", //gatway
    GETHOSTLIST_URL: "http://testuser.matchvs.com", //hostlist
    REGISTER_USER_URL: "http://testuser.matchvs.com" //

};

var HttpConf = {
    HOST_GATWAY_ADDR: "",
    GETHOSTLIST_URL: "http://sdk.matchvs.com",
    REGISTER_USER_URL: "",
    CMSNS_URL: "",
    VS_OPEN_URL: "",
    VS_PAY_URL: "",
    VS_PRODUCT_URL: ""

    /**
     * 
     * @param channel
     * @param platform
     * @returns {*}
     * @constructor
     */
};function MVSConfig(channel, platform) {
    // if (platform === "release"){
    //     return ReleaseHttpConf;
    // }else if (platform === "alpha"){
    //     return AlphaHttpConf;
    if ("localhost" === platform) {
        return LocalConf;
    }if ("test" === platform) {
        return TestHttpConf;
    } else {
        return HttpConf;
    }
}
/* ================ msutil.js ================= */
if (typeof String.prototype.startsWith !== 'function') {
    String.prototype.startsWith = function (prefix) {
        return this.slice(0, prefix.length) === prefix;
    };
}
if (typeof String.prototype.endsWith !== 'function') {
    String.prototype.endsWith = function (suffix) {
        return this.indexOf(suffix, this.length - suffix.length) !== -1;
    };
}

function IncludeJS(fileName) {
    new_element = document.createElement("script");
    new_element.setAttribute("type", "text/javascript");
    new_element.setAttribute("src", fileName); // a.js
    document.body.appendChild(new_element);
}

// IncludeJS("msutil.js");

function MSExtend(Child, Parent) {
    var p = Parent.prototype;
    var c = Child.prototype;
    for (var i in p) {
        c[i] = p[i];
    }
}

function stringToUtf8ByteArray(a) {
    for (var b = [], c = 0, d = 0; d < a.length; d++) {
        var e = a.charCodeAt(d);
        128 > e ? b[c++] = e : (2048 > e ? b[c++] = e >> 6 | 192 : (55296 == (e & 64512) && d + 1 < a.length && 56320 == (a.charCodeAt(d + 1) & 64512) ? (e = 65536 + ((e & 1023) << 10) + (a.charCodeAt(++d) & 1023), b[c++] = e >> 18 | 240, b[c++] = e >> 12 & 63 | 128) : b[c++] = e >> 12 | 224, b[c++] = e >> 6 & 63 | 128), b[c++] = e & 63 | 128);
    }
    var buf = new Uint8Array(b.length);
    for (var i = 0; i < buf.length; i++) {
        buf[i] = b[i];
    }
    return buf;
}
function utf8ByteArrayToString(a) {
    for (var b = [], c = 0, d = 0; c < a.length;) {
        var e = a[c++];
        if (128 > e) b[d++] = String.fromCharCode(e);else if (191 < e && 224 > e) {
            var f = a[c++];
            b[d++] = String.fromCharCode((e & 31) << 6 | f & 63);
        } else if (239 < e && 365 > e) {
            var f = a[c++],
                g = a[c++],
                h = a[c++],
                e = ((e & 7) << 18 | (f & 63) << 12 | (g & 63) << 6 | h & 63) - 65536;
            b[d++] = String.fromCharCode(55296 + (e >> 10));
            b[d++] = String.fromCharCode(56320 + (e & 1023));
        } else f = a[c++], g = a[c++], b[d++] = String.fromCharCode((e & 15) << 12 | (f & 63) << 6 | g & 63);
    }
    return b.join("");
}
function str2u8array(str) {
    if (!(str && typeof str === "string")) {
        return str;
    }
    var out = new Uint8Array(str.length * 2);
    for (var i = 0; i < str.length; i++) {
        out[i * 2] = str.charCodeAt(i) >> 8;
        out[i * 2 + 1] = str.charCodeAt(i);
    }
    return out;
}
function u8array2str(u8array) {
    var buf = new Uint16Array(u8array.length / 2);
    for (var i = 0; i < buf.length; i++) {
        buf[i] = u8array[i * 2] << 8 | u8array[i * 2 + 1];
    }
    return String.fromCharCode.apply(null, buf);
}

/**
 * @return {boolean}
 */
function LocalStore_Save(key, value) {
    //IE6~7 cookie HTML5
    if (window.localStorage) {
        localStorage.setItem(key, value);
        return true;
    } else {
        return false;
        // document.cookie+=(key+"="+value);
    }
}

/**
 * @return {null}
 */
function LocalStore_Load(key) {
    if (window.localStorage) {
        return localStorage.getItem(key);
    } else {
        // return  document.cookie.replace(/(?:(?:^|.*;\s*)"+key+"\s*\=\s*([^;]*).*$)|^.*$/, "$1");
        return null;
    }
}

function isIE() {
    //ie?
    return !!window.ActiveXObject || "ActiveXObject" in window;
} /* ================ mspb.js ================= */
(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof _require == "function" && _require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = { exports: {} };
            t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
    }

    var i = typeof _require == "function" && _require;
    for (var o = 0; o < r.length; o++) {
        s(r[o]);
    }return s;
})({
    1: [function (_require, module, exports) {
        (function (global) {
            var $jscomp = {
                scope: {}, getGlobal: function getGlobal(a) {
                    return "undefined" != typeof window && window === a ? a : "undefined" != typeof global ? global : a;
                }
            };
            $jscomp.global = $jscomp.getGlobal(this);
            $jscomp.initSymbol = function () {
                $jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol);
                $jscomp.initSymbol = function () {};
            };
            $jscomp.symbolCounter_ = 0;
            $jscomp.Symbol = function (a) {
                return "jscomp_symbol_" + a + $jscomp.symbolCounter_++;
            };
            $jscomp.initSymbolIterator = function () {
                $jscomp.initSymbol();
                $jscomp.global.Symbol.iterator || ($jscomp.global.Symbol.iterator = $jscomp.global.Symbol("iterator"));
                $jscomp.initSymbolIterator = function () {};
            };
            $jscomp.makeIterator = function (a) {
                $jscomp.initSymbolIterator();
                $jscomp.initSymbol();
                $jscomp.initSymbolIterator();
                var b = a[Symbol.iterator];
                if (b) return b.call(a);
                var c = 0;
                return {
                    next: function next() {
                        return c < a.length ? { done: !1, value: a[c++] } : { done: !0 };
                    }
                };
            };
            $jscomp.arrayFromIterator = function (a) {
                for (var b, c = []; !(b = a.next()).done;) {
                    c.push(b.value);
                }return c;
            };
            $jscomp.arrayFromIterable = function (a) {
                return a instanceof Array ? a : $jscomp.arrayFromIterator($jscomp.makeIterator(a));
            };
            $jscomp.inherits = function (a, b) {
                function c() {}

                c.prototype = b.prototype;
                a.prototype = new c();
                a.prototype.constructor = a;
                for (var d in b) {
                    if (Object.defineProperties) {
                        var e = Object.getOwnPropertyDescriptor(b, d);
                        e && Object.defineProperty(a, d, e);
                    } else a[d] = b[d];
                }
            };
            $jscomp.array = $jscomp.array || {};
            $jscomp.iteratorFromArray = function (a, b) {
                $jscomp.initSymbolIterator();
                a instanceof String && (a += "");
                var c = 0,
                    d = {
                    next: function next() {
                        if (c < a.length) {
                            var e = c++;
                            return { value: b(e, a[e]), done: !1 };
                        }
                        d.next = function () {
                            return { done: !0, value: void 0 };
                        };
                        return d.next();
                    }
                };
                $jscomp.initSymbol();
                $jscomp.initSymbolIterator();
                d[Symbol.iterator] = function () {
                    return d;
                };
                return d;
            };
            $jscomp.findInternal = function (a, b, c) {
                a instanceof String && (a = String(a));
                for (var d = a.length, e = 0; e < d; e++) {
                    var f = a[e];
                    if (b.call(c, f, e, a)) return { i: e, v: f };
                }
                return { i: -1, v: void 0 };
            };
            $jscomp.array.from = function (a, b, c) {
                $jscomp.initSymbolIterator();
                b = null != b ? b : function (a) {
                    return a;
                };
                var d = [];
                $jscomp.initSymbol();
                $jscomp.initSymbolIterator();
                var e = a[Symbol.iterator];
                "function" == typeof e && (a = e.call(a));
                if ("function" == typeof a.next) for (; !(e = a.next()).done;) {
                    d.push(b.call(c, e.value));
                } else for (var e = a.length, f = 0; f < e; f++) {
                    d.push(b.call(c, a[f]));
                }return d;
            };
            $jscomp.array.of = function (a) {
                return $jscomp.array.from(arguments);
            };
            $jscomp.array.entries = function () {
                return $jscomp.iteratorFromArray(this, function (a, b) {
                    return [a, b];
                });
            };
            $jscomp.array.installHelper_ = function (a, b) {
                !Array.prototype[a] && Object.defineProperties && Object.defineProperty && Object.defineProperty(Array.prototype, a, {
                    configurable: !0,
                    enumerable: !1,
                    writable: !0,
                    value: b
                });
            };
            $jscomp.array.entries$install = function () {
                $jscomp.array.installHelper_("entries", $jscomp.array.entries);
            };
            $jscomp.array.keys = function () {
                return $jscomp.iteratorFromArray(this, function (a) {
                    return a;
                });
            };
            $jscomp.array.keys$install = function () {
                $jscomp.array.installHelper_("keys", $jscomp.array.keys);
            };
            $jscomp.array.values = function () {
                return $jscomp.iteratorFromArray(this, function (a, b) {
                    return b;
                });
            };
            $jscomp.array.values$install = function () {
                $jscomp.array.installHelper_("values", $jscomp.array.values);
            };
            $jscomp.array.copyWithin = function (a, b, c) {
                var d = this.length;
                a = Number(a);
                b = Number(b);
                c = Number(null != c ? c : d);
                if (a < b) for (c = Math.min(c, d); b < c;) {
                    b in this ? this[a++] = this[b++] : (delete this[a++], b++);
                } else for (c = Math.min(c, d + b - a), a += c - b; c > b;) {
                    --c in this ? this[--a] = this[c] : delete this[a];
                }return this;
            };
            $jscomp.array.copyWithin$install = function () {
                $jscomp.array.installHelper_("copyWithin", $jscomp.array.copyWithin);
            };
            $jscomp.array.fill = function (a, b, c) {
                var d = this.length || 0;
                0 > b && (b = Math.max(0, d + b));
                if (null == c || c > d) c = d;
                c = Number(c);
                0 > c && (c = Math.max(0, d + c));
                for (b = Number(b || 0); b < c; b++) {
                    this[b] = a;
                }return this;
            };
            $jscomp.array.fill$install = function () {
                $jscomp.array.installHelper_("fill", $jscomp.array.fill);
            };
            $jscomp.array.find = function (a, b) {
                return $jscomp.findInternal(this, a, b).v;
            };
            $jscomp.array.find$install = function () {
                $jscomp.array.installHelper_("find", $jscomp.array.find);
            };
            $jscomp.array.findIndex = function (a, b) {
                return $jscomp.findInternal(this, a, b).i;
            };
            $jscomp.array.findIndex$install = function () {
                $jscomp.array.installHelper_("findIndex", $jscomp.array.findIndex);
            };
            $jscomp.ASSUME_NO_NATIVE_MAP = !1;
            $jscomp.Map$isConformant = function () {
                if ($jscomp.ASSUME_NO_NATIVE_MAP) return !1;
                var a = $jscomp.global.Map;
                if (!a || !a.prototype.entries || "function" != typeof Object.seal) return !1;
                try {
                    var b = Object.seal({ x: 4 }),
                        c = new a($jscomp.makeIterator([[b, "s"]]));
                    if ("s" != c.get(b) || 1 != c.size || c.get({ x: 4 }) || c.set({ x: 4 }, "t") != c || 2 != c.size) return !1;
                    var d = c.entries(),
                        e = d.next();
                    if (e.done || e.value[0] != b || "s" != e.value[1]) return !1;
                    e = d.next();
                    return e.done || 4 != e.value[0].x || "t" != e.value[1] || !d.next().done ? !1 : !0;
                } catch (f) {
                    return !1;
                }
            };
            $jscomp.Map = function (a) {
                this.data_ = {};
                this.head_ = $jscomp.Map.createHead();
                this.size = 0;
                if (a) {
                    a = $jscomp.makeIterator(a);
                    for (var b; !(b = a.next()).done;) {
                        b = b.value, this.set(b[0], b[1]);
                    }
                }
            };
            $jscomp.Map.prototype.set = function (a, b) {
                var c = $jscomp.Map.maybeGetEntry(this, a);
                c.list || (c.list = this.data_[c.id] = []);
                c.entry ? c.entry.value = b : (c.entry = {
                    next: this.head_,
                    previous: this.head_.previous,
                    head: this.head_,
                    key: a,
                    value: b
                }, c.list.push(c.entry), this.head_.previous.next = c.entry, this.head_.previous = c.entry, this.size++);
                return this;
            };
            $jscomp.Map.prototype["delete"] = function (a) {
                a = $jscomp.Map.maybeGetEntry(this, a);
                return a.entry && a.list ? (a.list.splice(a.index, 1), a.list.length || delete this.data_[a.id], a.entry.previous.next = a.entry.next, a.entry.next.previous = a.entry.previous, a.entry.head = null, this.size--, !0) : !1;
            };
            $jscomp.Map.prototype.clear = function () {
                this.data_ = {};
                this.head_ = this.head_.previous = $jscomp.Map.createHead();
                this.size = 0;
            };
            $jscomp.Map.prototype.has = function (a) {
                return !!$jscomp.Map.maybeGetEntry(this, a).entry;
            };
            $jscomp.Map.prototype.get = function (a) {
                return (a = $jscomp.Map.maybeGetEntry(this, a).entry) && a.value;
            };
            $jscomp.Map.prototype.entries = function () {
                return $jscomp.Map.makeIterator_(this, function (a) {
                    return [a.key, a.value];
                });
            };
            $jscomp.Map.prototype.keys = function () {
                return $jscomp.Map.makeIterator_(this, function (a) {
                    return a.key;
                });
            };
            $jscomp.Map.prototype.values = function () {
                return $jscomp.Map.makeIterator_(this, function (a) {
                    return a.value;
                });
            };
            $jscomp.Map.prototype.forEach = function (a, b) {
                for (var c = this.entries(), d; !(d = c.next()).done;) {
                    d = d.value, a.call(b, d[1], d[0], this);
                }
            };
            $jscomp.Map.maybeGetEntry = function (a, b) {
                var c = $jscomp.Map.getId(b),
                    d = a.data_[c];
                if (d && Object.prototype.hasOwnProperty.call(a.data_, c)) for (var e = 0; e < d.length; e++) {
                    var f = d[e];
                    if (b !== b && f.key !== f.key || b === f.key) return { id: c, list: d, index: e, entry: f };
                }
                return { id: c, list: d, index: -1, entry: void 0 };
            };
            $jscomp.Map.makeIterator_ = function (a, b) {
                var c = a.head_,
                    d = {
                    next: function next() {
                        if (c) {
                            for (; c.head != a.head_;) {
                                c = c.previous;
                            }for (; c.next != c.head;) {
                                return c = c.next, { done: !1, value: b(c) };
                            }c = null;
                        }
                        return { done: !0, value: void 0 };
                    }
                };
                $jscomp.initSymbol();
                $jscomp.initSymbolIterator();
                d[Symbol.iterator] = function () {
                    return d;
                };
                return d;
            };
            $jscomp.Map.mapIndex_ = 0;
            $jscomp.Map.createHead = function () {
                var a = {};
                return a.previous = a.next = a.head = a;
            };
            $jscomp.Map.getId = function (a) {
                if (!(a instanceof Object)) return "p_" + a;
                if (!($jscomp.Map.idKey in a)) try {
                    $jscomp.Map.defineProperty(a, $jscomp.Map.idKey, { value: ++$jscomp.Map.mapIndex_ });
                } catch (b) {}
                return $jscomp.Map.idKey in a ? a[$jscomp.Map.idKey] : "o_ " + a;
            };
            $jscomp.Map.defineProperty = Object.defineProperty ? function (a, b, c) {
                Object.defineProperty(a, b, { value: String(c) });
            } : function (a, b, c) {
                a[b] = String(c);
            };
            $jscomp.Map.Entry = function () {};
            $jscomp.Map$install = function () {
                $jscomp.initSymbol();
                $jscomp.initSymbolIterator();
                $jscomp.Map$isConformant() ? $jscomp.Map = $jscomp.global.Map : ($jscomp.initSymbol(), $jscomp.initSymbolIterator(), $jscomp.Map.prototype[Symbol.iterator] = $jscomp.Map.prototype.entries, $jscomp.initSymbol(), $jscomp.Map.idKey = Symbol("map-id-key"), $jscomp.Map$install = function () {});
            };
            $jscomp.math = $jscomp.math || {};
            $jscomp.math.clz32 = function (a) {
                a = Number(a) >>> 0;
                if (0 === a) return 32;
                var b = 0;
                0 === (a & 4294901760) && (a <<= 16, b += 16);
                0 === (a & 4278190080) && (a <<= 8, b += 8);
                0 === (a & 4026531840) && (a <<= 4, b += 4);
                0 === (a & 3221225472) && (a <<= 2, b += 2);
                0 === (a & 2147483648) && b++;
                return b;
            };
            $jscomp.math.imul = function (a, b) {
                a = Number(a);
                b = Number(b);
                var c = a & 65535,
                    d = b & 65535;
                return c * d + ((a >>> 16 & 65535) * d + c * (b >>> 16 & 65535) << 16 >>> 0) | 0;
            };
            $jscomp.math.sign = function (a) {
                a = Number(a);
                return 0 === a || isNaN(a) ? a : 0 < a ? 1 : -1;
            };
            $jscomp.math.log10 = function (a) {
                return Math.log(a) / Math.LN10;
            };
            $jscomp.math.log2 = function (a) {
                return Math.log(a) / Math.LN2;
            };
            $jscomp.math.log1p = function (a) {
                a = Number(a);
                if (.25 > a && -.25 < a) {
                    for (var b = a, c = 1, d = a, e = 0, f = 1; e != d;) {
                        b *= a, f *= -1, d = (e = d) + f * b / ++c;
                    }return d;
                }
                return Math.log(1 + a);
            };
            $jscomp.math.expm1 = function (a) {
                a = Number(a);
                if (.25 > a && -.25 < a) {
                    for (var b = a, c = 1, d = a, e = 0; e != d;) {
                        b *= a / ++c, d = (e = d) + b;
                    }return d;
                }
                return Math.exp(a) - 1;
            };
            $jscomp.math.cosh = function (a) {
                a = Number(a);
                return (Math.exp(a) + Math.exp(-a)) / 2;
            };
            $jscomp.math.sinh = function (a) {
                a = Number(a);
                return 0 === a ? a : (Math.exp(a) - Math.exp(-a)) / 2;
            };
            $jscomp.math.tanh = function (a) {
                a = Number(a);
                if (0 === a) return a;
                var b = Math.exp(-2 * Math.abs(a)),
                    b = (1 - b) / (1 + b);
                return 0 > a ? -b : b;
            };
            $jscomp.math.acosh = function (a) {
                a = Number(a);
                return Math.log(a + Math.sqrt(a * a - 1));
            };
            $jscomp.math.asinh = function (a) {
                a = Number(a);
                if (0 === a) return a;
                var b = Math.log(Math.abs(a) + Math.sqrt(a * a + 1));
                return 0 > a ? -b : b;
            };
            $jscomp.math.atanh = function (a) {
                a = Number(a);
                return ($jscomp.math.log1p(a) - $jscomp.math.log1p(-a)) / 2;
            };
            $jscomp.math.hypot = function (a, b, c) {
                a = Number(a);
                b = Number(b);
                var d,
                    e,
                    f,
                    g = Math.max(Math.abs(a), Math.abs(b));
                for (d = 2; d < arguments.length; d++) {
                    g = Math.max(g, Math.abs(arguments[d]));
                }if (1E100 < g || 1E-100 > g) {
                    a /= g;
                    b /= g;
                    f = a * a + b * b;
                    for (d = 2; d < arguments.length; d++) {
                        e = Number(arguments[d]) / g, f += e * e;
                    }return Math.sqrt(f) * g;
                }
                f = a * a + b * b;
                for (d = 2; d < arguments.length; d++) {
                    e = Number(arguments[d]), f += e * e;
                }return Math.sqrt(f);
            };
            $jscomp.math.trunc = function (a) {
                a = Number(a);
                if (isNaN(a) || Infinity === a || -Infinity === a || 0 === a) return a;
                var b = Math.floor(Math.abs(a));
                return 0 > a ? -b : b;
            };
            $jscomp.math.cbrt = function (a) {
                if (0 === a) return a;
                a = Number(a);
                var b = Math.pow(Math.abs(a), 1 / 3);
                return 0 > a ? -b : b;
            };
            $jscomp.number = $jscomp.number || {};
            $jscomp.number.isFinite = function (a) {
                return "number" !== typeof a ? !1 : !isNaN(a) && Infinity !== a && -Infinity !== a;
            };
            $jscomp.number.isInteger = function (a) {
                return $jscomp.number.isFinite(a) ? a === Math.floor(a) : !1;
            };
            $jscomp.number.isNaN = function (a) {
                return "number" === typeof a && isNaN(a);
            };
            $jscomp.number.isSafeInteger = function (a) {
                return $jscomp.number.isInteger(a) && Math.abs(a) <= $jscomp.number.MAX_SAFE_INTEGER;
            };
            $jscomp.number.EPSILON = function () {
                return Math.pow(2, -52);
            }();
            $jscomp.number.MAX_SAFE_INTEGER = function () {
                return 9007199254740991;
            }();
            $jscomp.number.MIN_SAFE_INTEGER = function () {
                return -9007199254740991;
            }();
            $jscomp.object = $jscomp.object || {};
            $jscomp.object.assign = function (a, b) {
                for (var c = 1; c < arguments.length; c++) {
                    var d = arguments[c];
                    if (d) for (var e in d) {
                        Object.prototype.hasOwnProperty.call(d, e) && (a[e] = d[e]);
                    }
                }
                return a;
            };
            $jscomp.object.is = function (a, b) {
                return a === b ? 0 !== a || 1 / a === 1 / b : a !== a && b !== b;
            };
            $jscomp.ASSUME_NO_NATIVE_SET = !1;
            $jscomp.Set$isConformant = function () {
                if ($jscomp.ASSUME_NO_NATIVE_SET) return !1;
                var a = $jscomp.global.Set;
                if (!a || !a.prototype.entries || "function" != typeof Object.seal) return !1;
                try {
                    var b = Object.seal({ x: 4 }),
                        c = new a($jscomp.makeIterator([b]));
                    if (!c.has(b) || 1 != c.size || c.add(b) != c || 1 != c.size || c.add({ x: 4 }) != c || 2 != c.size) return !1;
                    var d = c.entries(),
                        e = d.next();
                    if (e.done || e.value[0] != b || e.value[1] != b) return !1;
                    e = d.next();
                    return e.done || e.value[0] == b || 4 != e.value[0].x || e.value[1] != e.value[0] ? !1 : d.next().done;
                } catch (f) {
                    return !1;
                }
            };
            $jscomp.Set = function (a) {
                this.map_ = new $jscomp.Map();
                if (a) {
                    a = $jscomp.makeIterator(a);
                    for (var b; !(b = a.next()).done;) {
                        this.add(b.value);
                    }
                }
                this.size = this.map_.size;
            };
            $jscomp.Set.prototype.add = function (a) {
                this.map_.set(a, a);
                this.size = this.map_.size;
                return this;
            };
            $jscomp.Set.prototype["delete"] = function (a) {
                a = this.map_["delete"](a);
                this.size = this.map_.size;
                return a;
            };
            $jscomp.Set.prototype.clear = function () {
                this.map_.clear();
                this.size = 0;
            };
            $jscomp.Set.prototype.has = function (a) {
                return this.map_.has(a);
            };
            $jscomp.Set.prototype.entries = function () {
                return this.map_.entries();
            };
            $jscomp.Set.prototype.values = function () {
                return this.map_.values();
            };
            $jscomp.Set.prototype.forEach = function (a, b) {
                var c = this;
                this.map_.forEach(function (d) {
                    return a.call(b, d, d, c);
                });
            };
            $jscomp.Set$install = function () {
                $jscomp.Map$install();
                $jscomp.Set$isConformant() ? $jscomp.Set = $jscomp.global.Set : ($jscomp.initSymbol(), $jscomp.initSymbolIterator(), $jscomp.Set.prototype[Symbol.iterator] = $jscomp.Set.prototype.values, $jscomp.Set$install = function () {});
            };
            $jscomp.string = $jscomp.string || {};
            $jscomp.checkStringArgs = function (a, b, c) {
                if (null == a) throw new TypeError("The 'this' value for String.prototype." + c + " must not be null or undefined");
                if (b instanceof RegExp) throw new TypeError("First argument to String.prototype." + c + " must not be a regular expression");
                return a + "";
            };
            $jscomp.string.fromCodePoint = function (a) {
                for (var b = "", c = 0; c < arguments.length; c++) {
                    var d = Number(arguments[c]);
                    if (0 > d || 1114111 < d || d !== Math.floor(d)) throw new RangeError("invalid_code_point " + d);
                    65535 >= d ? b += String.fromCharCode(d) : (d -= 65536, b += String.fromCharCode(d >>> 10 & 1023 | 55296), b += String.fromCharCode(d & 1023 | 56320));
                }
                return b;
            };
            $jscomp.string.repeat = function (a) {
                var b = $jscomp.checkStringArgs(this, null, "repeat");
                if (0 > a || 1342177279 < a) throw new RangeError("Invalid count value");
                a |= 0;
                for (var c = ""; a;) {
                    if (a & 1 && (c += b), a >>>= 1) b += b;
                }return c;
            };
            $jscomp.string.repeat$install = function () {
                String.prototype.repeat || (String.prototype.repeat = $jscomp.string.repeat);
            };
            $jscomp.string.codePointAt = function (a) {
                var b = $jscomp.checkStringArgs(this, null, "codePointAt"),
                    c = b.length;
                a = Number(a) || 0;
                if (0 <= a && a < c) {
                    a |= 0;
                    var d = b.charCodeAt(a);
                    if (55296 > d || 56319 < d || a + 1 === c) return d;
                    a = b.charCodeAt(a + 1);
                    return 56320 > a || 57343 < a ? d : 1024 * (d - 55296) + a + 9216;
                }
            };
            $jscomp.string.codePointAt$install = function () {
                String.prototype.codePointAt || (String.prototype.codePointAt = $jscomp.string.codePointAt);
            };
            $jscomp.string.includes = function (a, b) {
                return -1 !== $jscomp.checkStringArgs(this, a, "includes").indexOf(a, b || 0);
            };
            $jscomp.string.includes$install = function () {
                String.prototype.includes || (String.prototype.includes = $jscomp.string.includes);
            };
            $jscomp.string.startsWith = function (a, b) {
                var c = $jscomp.checkStringArgs(this, a, "startsWith");
                a += "";
                for (var d = c.length, e = a.length, f = Math.max(0, Math.min(b | 0, c.length)), g = 0; g < e && f < d;) {
                    if (c[f++] != a[g++]) return !1;
                }return g >= e;
            };
            $jscomp.string.startsWith$install = function () {
                String.prototype.startsWith || (String.prototype.startsWith = $jscomp.string.startsWith);
            };
            $jscomp.string.endsWith = function (a, b) {
                var c = $jscomp.checkStringArgs(this, a, "endsWith");
                a += "";
                void 0 === b && (b = c.length);
                for (var d = Math.max(0, Math.min(b | 0, c.length)), e = a.length; 0 < e && 0 < d;) {
                    if (c[--d] != a[--e]) return !1;
                }return 0 >= e;
            };
            $jscomp.string.endsWith$install = function () {
                String.prototype.endsWith || (String.prototype.endsWith = $jscomp.string.endsWith);
            };
            var COMPILED = !0,
                goog = goog || {};
            goog.global = this;
            goog.isDef = function (a) {
                return void 0 !== a;
            };
            goog.exportPath_ = function (a, b, c) {
                a = a.split(".");
                c = c || goog.global;
                a[0] in c || !c.execScript || c.execScript("var " + a[0]);
                for (var d; a.length && (d = a.shift());) {
                    !a.length && goog.isDef(b) ? c[d] = b : c = c[d] ? c[d] : c[d] = {};
                }
            };
            goog.define = function (a, b) {
                var c = b;
                COMPILED || (goog.global.CLOSURE_UNCOMPILED_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_UNCOMPILED_DEFINES, a) ? c = goog.global.CLOSURE_UNCOMPILED_DEFINES[a] : goog.global.CLOSURE_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_DEFINES, a) && (c = goog.global.CLOSURE_DEFINES[a]));
                goog.exportPath_(a, c);
            };
            goog.DEBUG = !0;
            goog.LOCALE = "en";
            goog.TRUSTED_SITE = !0;
            goog.STRICT_MODE_COMPATIBLE = !1;
            goog.DISALLOW_TEST_ONLY_CODE = COMPILED && !goog.DEBUG;
            goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING = !1;
            goog.provide = function (a) {
                if (!COMPILED && goog.isProvided_(a)) throw Error('Namespace "' + a + '" already declared.');
                goog.constructNamespace_(a);
            };
            goog.constructNamespace_ = function (a, b) {
                if (!COMPILED) {
                    delete goog.implicitNamespaces_[a];
                    for (var c = a; (c = c.substring(0, c.lastIndexOf("."))) && !goog.getObjectByName(c);) {
                        goog.implicitNamespaces_[c] = !0;
                    }
                }
                goog.exportPath_(a, b);
            };
            goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
            goog.module = function (a) {
                if (!goog.isString(a) || !a || -1 == a.search(goog.VALID_MODULE_RE_)) throw Error("Invalid module identifier");
                if (!goog.isInModuleLoader_()) throw Error("Module " + a + " has been loaded incorrectly.");
                if (goog.moduleLoaderState_.moduleName) throw Error("goog.module may only be called once per module.");
                goog.moduleLoaderState_.moduleName = a;
                if (!COMPILED) {
                    if (goog.isProvided_(a)) throw Error('Namespace "' + a + '" already declared.');
                    delete goog.implicitNamespaces_[a];
                }
            };
            goog.module.get = function (a) {
                return goog.module.getInternal_(a);
            };
            goog.module.getInternal_ = function (a) {
                if (!COMPILED) return goog.isProvided_(a) ? a in goog.loadedModules_ ? goog.loadedModules_[a] : goog.getObjectByName(a) : null;
            };
            goog.moduleLoaderState_ = null;
            goog.isInModuleLoader_ = function () {
                return null != goog.moduleLoaderState_;
            };
            goog.module.declareLegacyNamespace = function () {
                if (!COMPILED && !goog.isInModuleLoader_()) throw Error("goog.module.declareLegacyNamespace must be called from within a goog.module");
                if (!COMPILED && !goog.moduleLoaderState_.moduleName) throw Error("goog.module must be called prior to goog.module.declareLegacyNamespace.");
                goog.moduleLoaderState_.declareLegacyNamespace = !0;
            };
            goog.setTestOnly = function (a) {
                if (goog.DISALLOW_TEST_ONLY_CODE) throw a = a || "", Error("Importing test-only code into non-debug environment" + (a ? ": " + a : "."));
            };
            goog.forwardDeclare = function (a) {};
            COMPILED || (goog.isProvided_ = function (a) {
                return a in goog.loadedModules_ || !goog.implicitNamespaces_[a] && goog.isDefAndNotNull(goog.getObjectByName(a));
            }, goog.implicitNamespaces_ = { "goog.module": !0 });
            goog.getObjectByName = function (a, b) {
                for (var c = a.split("."), d = b || goog.global, e; e = c.shift();) {
                    if (goog.isDefAndNotNull(d[e])) d = d[e];else return null;
                }return d;
            };
            goog.globalize = function (a, b) {
                var c = b || goog.global,
                    d;
                for (d in a) {
                    c[d] = a[d];
                }
            };
            goog.addDependency = function (a, b, c, d) {
                if (goog.DEPENDENCIES_ENABLED) {
                    var e;
                    a = a.replace(/\\/g, "/");
                    for (var f = goog.dependencies_, g = 0; e = b[g]; g++) {
                        f.nameToPath[e] = a, f.pathIsModule[a] = !!d;
                    }for (d = 0; b = c[d]; d++) {
                        a in f._requires || (f._requires[a] = {}), f._requires[a][b] = !0;
                    }
                }
            };
            goog.ENABLE_DEBUG_LOADER = !0;
            goog.logToConsole_ = function (a) {
                goog.global.console && goog.global.console.error(a);
            };
            goog._require = function (a) {
                if (!COMPILED) {
                    goog.ENABLE_DEBUG_LOADER && goog.IS_OLD_IE_ && goog.maybeProcessDeferredDep_(a);
                    if (goog.isProvided_(a)) return goog.isInModuleLoader_() ? goog.module.getInternal_(a) : null;
                    if (goog.ENABLE_DEBUG_LOADER) {
                        var b = goog.getPathFromDeps_(a);
                        if (b) return goog.writeScripts_(b), null;
                    }
                    a = "goog._require could not find: " + a;
                    goog.logToConsole_(a);
                    throw Error(a);
                }
            };
            goog.basePath = "";
            goog.nullFunction = function () {};
            goog.abstractMethod = function () {
                throw Error("unimplemented abstract method");
            };
            goog.addSingletonGetter = function (a) {
                a.getInstance = function () {
                    if (a.instance_) return a.instance_;
                    goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = a);
                    return a.instance_ = new a();
                };
            };
            goog.instantiatedSingletons_ = [];
            goog.LOAD_MODULE_USING_EVAL = !0;
            goog.SEAL_MODULE_EXPORTS = goog.DEBUG;
            goog.loadedModules_ = {};
            goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;
            goog.DEPENDENCIES_ENABLED && (goog.dependencies_ = {
                pathIsModule: {},
                nameToPath: {},
                _requires: {},
                visited: {},
                written: {},
                deferred: {}
            }, goog.inHtmlDocument_ = function () {
                var a = goog.global.document;
                return null != a && "write" in a;
            }, goog.findBasePath_ = function () {
                if (goog.isDef(goog.global.CLOSURE_BASE_PATH)) goog.basePath = goog.global.CLOSURE_BASE_PATH;else if (goog.inHtmlDocument_()) for (var a = goog.global.document.getElementsByTagName("SCRIPT"), b = a.length - 1; 0 <= b; --b) {
                    var c = a[b].src,
                        d = c.lastIndexOf("?"),
                        d = -1 == d ? c.length : d;
                    if ("base.js" == c.substr(d - 7, 7)) {
                        goog.basePath = c.substr(0, d - 7);
                        break;
                    }
                }
            }, goog.importScript_ = function (a, b) {
                (goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_)(a, b) && (goog.dependencies_.written[a] = !0);
            }, goog.IS_OLD_IE_ = !(goog.global.atob || !goog.global.document || !goog.global.document.all), goog.importModule_ = function (a) {
                goog.importScript_("", 'goog.retrieveAndExecModule_("' + a + '");') && (goog.dependencies_.written[a] = !0);
            }, goog.queuedModules_ = [], goog.wrapModule_ = function (a, b) {
                return goog.LOAD_MODULE_USING_EVAL && goog.isDef(goog.global.JSON) ? "goog.loadModule(" + goog.global.JSON.stringify(b + "\n//# sourceURL=" + a + "\n") + ");" : 'goog.loadModule(function(exports) {"use strict";' + b + "\n;return exports});\n//# sourceURL=" + a + "\n";
            }, goog.loadQueuedModules_ = function () {
                var a = goog.queuedModules_.length;
                if (0 < a) {
                    var b = goog.queuedModules_;
                    goog.queuedModules_ = [];
                    for (var c = 0; c < a; c++) {
                        goog.maybeProcessDeferredPath_(b[c]);
                    }
                }
            }, goog.maybeProcessDeferredDep_ = function (a) {
                goog.isDeferredModule_(a) && goog.allDepsAreAvailable_(a) && (a = goog.getPathFromDeps_(a), goog.maybeProcessDeferredPath_(goog.basePath + a));
            }, goog.isDeferredModule_ = function (a) {
                return (a = goog.getPathFromDeps_(a)) && goog.dependencies_.pathIsModule[a] ? goog.basePath + a in goog.dependencies_.deferred : !1;
            }, goog.allDepsAreAvailable_ = function (a) {
                if ((a = goog.getPathFromDeps_(a)) && a in goog.dependencies_._requires) for (var b in goog.dependencies_._requires[a]) {
                    if (!goog.isProvided_(b) && !goog.isDeferredModule_(b)) return !1;
                }return !0;
            }, goog.maybeProcessDeferredPath_ = function (a) {
                if (a in goog.dependencies_.deferred) {
                    var b = goog.dependencies_.deferred[a];
                    delete goog.dependencies_.deferred[a];
                    goog.globalEval(b);
                }
            }, goog.loadModuleFromUrl = function (a) {
                goog.retrieveAndExecModule_(a);
            }, goog.loadModule = function (a) {
                var b = goog.moduleLoaderState_;
                try {
                    goog.moduleLoaderState_ = { moduleName: void 0, declareLegacyNamespace: !1 };
                    var c;
                    if (goog.isFunction(a)) c = a.call(goog.global, {});else if (goog.isString(a)) c = goog.loadModuleFromSource_.call(goog.global, a);else throw Error("Invalid module definition");
                    var d = goog.moduleLoaderState_.moduleName;
                    if (!goog.isString(d) || !d) throw Error('Invalid module name "' + d + '"');
                    goog.moduleLoaderState_.declareLegacyNamespace ? goog.constructNamespace_(d, c) : goog.SEAL_MODULE_EXPORTS && Object.seal && Object.seal(c);
                    goog.loadedModules_[d] = c;
                } finally {
                    goog.moduleLoaderState_ = b;
                }
            }, goog.loadModuleFromSource_ = function (a) {
                eval(a);
                return {};
            }, goog.writeScriptSrcNode_ = function (a) {
                goog.global.document.write('<script type="text/javascript" src="' + a + '">\x3c/script>');
            }, goog.appendScriptSrcNode_ = function (a) {
                var b = goog.global.document,
                    c = b.createElement("script");
                c.type = "text/javascript";
                c.src = a;
                c.defer = !1;
                c.async = !1;
                b.head.appendChild(c);
            }, goog.writeScriptTag_ = function (a, b) {
                if (goog.inHtmlDocument_()) {
                    var c = goog.global.document;
                    if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING && "complete" == c.readyState) {
                        if (/\bdeps.js$/.test(a)) return !1;
                        throw Error('Cannot write "' + a + '" after document load');
                    }
                    var d = goog.IS_OLD_IE_;
                    void 0 === b ? d ? (d = " onreadystatechange='goog.onScriptLoad_(this, " + ++goog.lastNonModuleScriptIndex_ + ")' ", c.write('<script type="text/javascript" src="' + a + '"' + d + ">\x3c/script>")) : goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING ? goog.appendScriptSrcNode_(a) : goog.writeScriptSrcNode_(a) : c.write('<script type="text/javascript">' + b + "\x3c/script>");
                    return !0;
                }
                return !1;
            }, goog.lastNonModuleScriptIndex_ = 0, goog.onScriptLoad_ = function (a, b) {
                "complete" == a.readyState && goog.lastNonModuleScriptIndex_ == b && goog.loadQueuedModules_();
                return !0;
            }, goog.writeScripts_ = function (a) {
                function b(a) {
                    if (!(a in e.written || a in e.visited)) {
                        e.visited[a] = !0;
                        if (a in e._requires) for (var f in e._requires[a]) {
                            if (!goog.isProvided_(f)) if (f in e.nameToPath) b(e.nameToPath[f]);else throw Error("Undefined nameToPath for " + f);
                        }a in d || (d[a] = !0, c.push(a));
                    }
                }

                var c = [],
                    d = {},
                    e = goog.dependencies_;
                b(a);
                for (a = 0; a < c.length; a++) {
                    var f = c[a];
                    goog.dependencies_.written[f] = !0;
                }
                var g = goog.moduleLoaderState_;
                goog.moduleLoaderState_ = null;
                for (a = 0; a < c.length; a++) {
                    if (f = c[a]) e.pathIsModule[f] ? goog.importModule_(goog.basePath + f) : goog.importScript_(goog.basePath + f);else throw goog.moduleLoaderState_ = g, Error("Undefined script input");
                }goog.moduleLoaderState_ = g;
            }, goog.getPathFromDeps_ = function (a) {
                return a in goog.dependencies_.nameToPath ? goog.dependencies_.nameToPath[a] : null;
            }, goog.findBasePath_(), goog.global.CLOSURE_NO_DEPS || goog.importScript_(goog.basePath + "deps.js"));
            goog.normalizePath_ = function (a) {
                a = a.split("/");
                for (var b = 0; b < a.length;) {
                    "." == a[b] ? a.splice(b, 1) : b && ".." == a[b] && a[b - 1] && ".." != a[b - 1] ? a.splice(--b, 2) : b++;
                }return a.join("/");
            };
            goog.loadFileSync_ = function (a) {
                if (goog.global.CLOSURE_LOAD_FILE_SYNC) return goog.global.CLOSURE_LOAD_FILE_SYNC(a);
                var b = new goog.global.XMLHttpRequest();
                b.open("get", a, !1);
                b.send();
                return b.responseText;
            };
            goog.retrieveAndExecModule_ = function (a) {
                if (!COMPILED) {
                    var b = a;
                    a = goog.normalizePath_(a);
                    var c = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_,
                        d = goog.loadFileSync_(a);
                    if (null != d) d = goog.wrapModule_(a, d), goog.IS_OLD_IE_ ? (goog.dependencies_.deferred[b] = d, goog.queuedModules_.push(b)) : c(a, d);else throw Error("load of " + a + "failed");
                }
            };
            goog.typeOf = function (a) {
                var b = typeof a === "undefined" ? "undefined" : _typeof(a);
                if ("object" == b) {
                    if (a) {
                        if (a instanceof Array) return "array";
                        if (a instanceof Object) return b;
                        var c = Object.prototype.toString.call(a);
                        if ("[object Window]" == c) return "object";
                        if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice")) return "array";
                        if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call")) return "function";
                    } else return "null";
                } else if ("function" == b && "undefined" == typeof a.call) return "object";
                return b;
            };
            goog.isNull = function (a) {
                return null === a;
            };
            goog.isDefAndNotNull = function (a) {
                return null != a;
            };
            goog.isArray = function (a) {
                return "array" == goog.typeOf(a);
            };
            goog.isArrayLike = function (a) {
                var b = goog.typeOf(a);
                return "array" == b || "object" == b && "number" == typeof a.length;
            };
            goog.isDateLike = function (a) {
                return goog.isObject(a) && "function" == typeof a.getFullYear;
            };
            goog.isString = function (a) {
                return "string" == typeof a;
            };
            goog.isBoolean = function (a) {
                return "boolean" == typeof a;
            };
            goog.isNumber = function (a) {
                return "number" == typeof a;
            };
            goog.isFunction = function (a) {
                return "function" == goog.typeOf(a);
            };
            goog.isObject = function (a) {
                var b = typeof a === "undefined" ? "undefined" : _typeof(a);
                return "object" == b && null != a || "function" == b;
            };
            goog.getUid = function (a) {
                return a[goog.UID_PROPERTY_] || (a[goog.UID_PROPERTY_] = ++goog.uidCounter_);
            };
            goog.hasUid = function (a) {
                return !!a[goog.UID_PROPERTY_];
            };
            goog.removeUid = function (a) {
                null !== a && "removeAttribute" in a && a.removeAttribute(goog.UID_PROPERTY_);
                try {
                    delete a[goog.UID_PROPERTY_];
                } catch (b) {}
            };
            goog.UID_PROPERTY_ = "closure_uid_" + (1E9 * Math.random() >>> 0);
            goog.uidCounter_ = 0;
            goog.getHashCode = goog.getUid;
            goog.removeHashCode = goog.removeUid;
            goog.cloneObject = function (a) {
                var b = goog.typeOf(a);
                if ("object" == b || "array" == b) {
                    if (a.clone) return a.clone();
                    var b = "array" == b ? [] : {},
                        c;
                    for (c in a) {
                        b[c] = goog.cloneObject(a[c]);
                    }return b;
                }
                return a;
            };
            goog.bindNative_ = function (a, b, c) {
                return a.call.apply(a.bind, arguments);
            };
            goog.bindJs_ = function (a, b, c) {
                if (!a) throw Error();
                if (2 < arguments.length) {
                    var d = Array.prototype.slice.call(arguments, 2);
                    return function () {
                        var c = Array.prototype.slice.call(arguments);
                        Array.prototype.unshift.apply(c, d);
                        return a.apply(b, c);
                    };
                }
                return function () {
                    return a.apply(b, arguments);
                };
            };
            goog.bind = function (a, b, c) {
                Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? goog.bind = goog.bindNative_ : goog.bind = goog.bindJs_;
                return goog.bind.apply(null, arguments);
            };
            goog.partial = function (a, b) {
                var c = Array.prototype.slice.call(arguments, 1);
                return function () {
                    var b = c.slice();
                    b.push.apply(b, arguments);
                    return a.apply(this, b);
                };
            };
            goog.mixin = function (a, b) {
                for (var c in b) {
                    a[c] = b[c];
                }
            };
            goog.now = goog.TRUSTED_SITE && Date.now || function () {
                return +new Date();
            };
            goog.globalEval = function (a) {
                if (goog.global.execScript) goog.global.execScript(a, "JavaScript");else if (goog.global.eval) {
                    if (null == goog.evalWorksForGlobals_) if (goog.global.eval("var _evalTest_ = 1;"), "undefined" != typeof goog.global._evalTest_) {
                        try {
                            delete goog.global._evalTest_;
                        } catch (d) {}
                        goog.evalWorksForGlobals_ = !0;
                    } else goog.evalWorksForGlobals_ = !1;
                    if (goog.evalWorksForGlobals_) goog.global.eval(a);else {
                        var b = goog.global.document,
                            c = b.createElement("SCRIPT");
                        c.type = "text/javascript";
                        c.defer = !1;
                        c.appendChild(b.createTextNode(a));
                        b.body.appendChild(c);
                        b.body.removeChild(c);
                    }
                } else throw Error("goog.globalEval not available");
            };
            goog.evalWorksForGlobals_ = null;
            goog.getCssName = function (a, b) {
                var c = function c(a) {
                    return goog.cssNameMapping_[a] || a;
                },
                    d = function d(a) {
                    a = a.split("-");
                    for (var b = [], d = 0; d < a.length; d++) {
                        b.push(c(a[d]));
                    }return b.join("-");
                },
                    d = goog.cssNameMapping_ ? "BY_WHOLE" == goog.cssNameMappingStyle_ ? c : d : function (a) {
                    return a;
                };
                return b ? a + "-" + d(b) : d(a);
            };
            goog.setCssNameMapping = function (a, b) {
                goog.cssNameMapping_ = a;
                goog.cssNameMappingStyle_ = b;
            };
            !COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING && (goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING);
            goog.getMsg = function (a, b) {
                b && (a = a.replace(/\{\$([^}]+)}/g, function (a, d) {
                    return null != b && d in b ? b[d] : a;
                }));
                return a;
            };
            goog.getMsgWithFallback = function (a, b) {
                return a;
            };
            goog.exportSymbol = function (a, b, c) {
                goog.exportPath_(a, b, c);
            };
            goog.exportProperty = function (a, b, c) {
                a[b] = c;
            };
            goog.inherits = function (a, b) {
                function c() {}

                c.prototype = b.prototype;
                a.superClass_ = b.prototype;
                a.prototype = new c();
                a.prototype.constructor = a;
                a.base = function (a, c, f) {
                    for (var g = Array(arguments.length - 2), h = 2; h < arguments.length; h++) {
                        g[h - 2] = arguments[h];
                    }return b.prototype[c].apply(a, g);
                };
            };
            goog.base = function (a, b, c) {
                var d = arguments.callee.caller;
                if (goog.STRICT_MODE_COMPATIBLE || goog.DEBUG && !d) throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C");
                if (d.superClass_) {
                    for (var e = Array(arguments.length - 1), f = 1; f < arguments.length; f++) {
                        e[f - 1] = arguments[f];
                    }return d.superClass_.constructor.apply(a, e);
                }
                e = Array(arguments.length - 2);
                for (f = 2; f < arguments.length; f++) {
                    e[f - 2] = arguments[f];
                }for (var f = !1, g = a.constructor; g; g = g.superClass_ && g.superClass_.constructor) {
                    if (g.prototype[b] === d) f = !0;else if (f) return g.prototype[b].apply(a, e);
                }if (a[b] === d) return a.constructor.prototype[b].apply(a, e);
                throw Error("goog.base called from a method of one name to a method of a different name");
            };
            goog.scope = function (a) {
                a.call(goog.global);
            };
            COMPILED || (goog.global.COMPILED = COMPILED);
            goog.defineClass = function (a, b) {
                var c = b.constructor,
                    d = b.statics;
                c && c != Object.prototype.constructor || (c = function c() {
                    throw Error("cannot instantiate an interface (no constructor defined).");
                });
                c = goog.defineClass.createSealingConstructor_(c, a);
                a && goog.inherits(c, a);
                delete b.constructor;
                delete b.statics;
                goog.defineClass.applyProperties_(c.prototype, b);
                null != d && (d instanceof Function ? d(c) : goog.defineClass.applyProperties_(c, d));
                return c;
            };
            goog.defineClass.SEAL_CLASS_INSTANCES = goog.DEBUG;
            goog.defineClass.createSealingConstructor_ = function (a, b) {
                if (goog.defineClass.SEAL_CLASS_INSTANCES && Object.seal instanceof Function) {
                    if (b && b.prototype && b.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]) return a;
                    var c = function c() {
                        var b = a.apply(this, arguments) || this;
                        b[goog.UID_PROPERTY_] = b[goog.UID_PROPERTY_];
                        this.constructor === c && Object.seal(b);
                        return b;
                    };
                    return c;
                }
                return a;
            };
            goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
            goog.defineClass.applyProperties_ = function (a, b) {
                for (var c in b) {
                    Object.prototype.hasOwnProperty.call(b, c) && (a[c] = b[c]);
                }for (var d = 0; d < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; d++) {
                    c = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[d], Object.prototype.hasOwnProperty.call(b, c) && (a[c] = b[c]);
                }
            };
            goog.tagUnsealableClass = function (a) {
                !COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES && (a.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = !0);
            };
            goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = "goog_defineClass_legacy_unsealable";
            goog.dom = {};
            goog.dom.NodeType = {
                ELEMENT: 1,
                ATTRIBUTE: 2,
                TEXT: 3,
                CDATA_SECTION: 4,
                ENTITY_REFERENCE: 5,
                ENTITY: 6,
                PROCESSING_INSTRUCTION: 7,
                COMMENT: 8,
                DOCUMENT: 9,
                DOCUMENT_TYPE: 10,
                DOCUMENT_FRAGMENT: 11,
                NOTATION: 12
            };
            goog.debug = {};
            goog.debug.Error = function (a) {
                if (Error.captureStackTrace) Error.captureStackTrace(this, goog.debug.Error);else {
                    var b = Error().stack;
                    b && (this.stack = b);
                }
                a && (this.message = String(a));
                this.reportErrorToServer = !0;
            };
            goog.inherits(goog.debug.Error, Error);
            goog.debug.Error.prototype.name = "CustomError";
            goog.string = {};
            goog.string.DETECT_DOUBLE_ESCAPING = !1;
            goog.string.FORCE_NON_DOM_HTML_UNESCAPING = !1;
            goog.string.Unicode = { NBSP: "\xA0" };
            goog.string.startsWith = function (a, b) {
                return 0 == a.lastIndexOf(b, 0);
            };
            goog.string.endsWith = function (a, b) {
                var c = a.length - b.length;
                return 0 <= c && a.indexOf(b, c) == c;
            };
            goog.string.caseInsensitiveStartsWith = function (a, b) {
                return 0 == goog.string.caseInsensitiveCompare(b, a.substr(0, b.length));
            };
            goog.string.caseInsensitiveEndsWith = function (a, b) {
                return 0 == goog.string.caseInsensitiveCompare(b, a.substr(a.length - b.length, b.length));
            };
            goog.string.caseInsensitiveEquals = function (a, b) {
                return a.toLowerCase() == b.toLowerCase();
            };
            goog.string.subs = function (a, b) {
                for (var c = a.split("%s"), d = "", e = Array.prototype.slice.call(arguments, 1); e.length && 1 < c.length;) {
                    d += c.shift() + e.shift();
                }return d + c.join("%s");
            };
            goog.string.collapseWhitespace = function (a) {
                return a.replace(/[\s\xa0]+/g, " ").replace(/^\s+|\s+$/g, "");
            };
            goog.string.isEmptyOrWhitespace = function (a) {
                return (/^[\s\xa0]*$/.test(a)
                );
            };
            goog.string.isEmptyString = function (a) {
                return 0 == a.length;
            };
            goog.string.isEmpty = goog.string.isEmptyOrWhitespace;
            goog.string.isEmptyOrWhitespaceSafe = function (a) {
                return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(a));
            };
            goog.string.isEmptySafe = goog.string.isEmptyOrWhitespaceSafe;
            goog.string.isBreakingWhitespace = function (a) {
                return !/[^\t\n\r ]/.test(a);
            };
            goog.string.isAlpha = function (a) {
                return !/[^a-zA-Z]/.test(a);
            };
            goog.string.isNumeric = function (a) {
                return !/[^0-9]/.test(a);
            };
            goog.string.isAlphaNumeric = function (a) {
                return !/[^a-zA-Z0-9]/.test(a);
            };
            goog.string.isSpace = function (a) {
                return " " == a;
            };
            goog.string.isUnicodeChar = function (a) {
                return 1 == a.length && " " <= a && "~" >= a || "\x80" <= a && "\uFFFD" >= a;
            };
            goog.string.stripNewlines = function (a) {
                return a.replace(/(\r\n|\r|\n)+/g, " ");
            };
            goog.string.canonicalizeNewlines = function (a) {
                return a.replace(/(\r\n|\r|\n)/g, "\n");
            };
            goog.string.normalizeWhitespace = function (a) {
                return a.replace(/\xa0|\s/g, " ");
            };
            goog.string.normalizeSpaces = function (a) {
                return a.replace(/\xa0|[ \t]+/g, " ");
            };
            goog.string.collapseBreakingSpaces = function (a) {
                return a.replace(/[\t\r\n ]+/g, " ").replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, "");
            };
            goog.string.trim = goog.TRUSTED_SITE && String.prototype.trim ? function (a) {
                return a.trim();
            } : function (a) {
                return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g, "");
            };
            goog.string.trimLeft = function (a) {
                return a.replace(/^[\s\xa0]+/, "");
            };
            goog.string.trimRight = function (a) {
                return a.replace(/[\s\xa0]+$/, "");
            };
            goog.string.caseInsensitiveCompare = function (a, b) {
                var c = String(a).toLowerCase(),
                    d = String(b).toLowerCase();
                return c < d ? -1 : c == d ? 0 : 1;
            };
            goog.string.numberAwareCompare_ = function (a, b, c) {
                if (a == b) return 0;
                if (!a) return -1;
                if (!b) return 1;
                for (var d = a.toLowerCase().match(c), e = b.toLowerCase().match(c), f = Math.min(d.length, e.length), g = 0; g < f; g++) {
                    c = d[g];
                    var h = e[g];
                    if (c != h) return a = parseInt(c, 10), !isNaN(a) && (b = parseInt(h, 10), !isNaN(b) && a - b) ? a - b : c < h ? -1 : 1;
                }
                return d.length != e.length ? d.length - e.length : a < b ? -1 : 1;
            };
            goog.string.intAwareCompare = function (a, b) {
                return goog.string.numberAwareCompare_(a, b, /\d+|\D+/g);
            };
            goog.string.floatAwareCompare = function (a, b) {
                return goog.string.numberAwareCompare_(a, b, /\d+|\.\d+|\D+/g);
            };
            goog.string.numerateCompare = goog.string.floatAwareCompare;
            goog.string.urlEncode = function (a) {
                return encodeURIComponent(String(a));
            };
            goog.string.urlDecode = function (a) {
                return decodeURIComponent(a.replace(/\+/g, " "));
            };
            goog.string.newLineToBr = function (a, b) {
                return a.replace(/(\r\n|\r|\n)/g, b ? "<br />" : "<br>");
            };
            goog.string.htmlEscape = function (a, b) {
                if (b) a = a.replace(goog.string.AMP_RE_, "&amp;").replace(goog.string.LT_RE_, "&lt;").replace(goog.string.GT_RE_, "&gt;").replace(goog.string.QUOT_RE_, "&quot;").replace(goog.string.SINGLE_QUOTE_RE_, "&#39;").replace(goog.string.NULL_RE_, "&#0;"), goog.string.DETECT_DOUBLE_ESCAPING && (a = a.replace(goog.string.E_RE_, "&#101;"));else {
                    if (!goog.string.ALL_RE_.test(a)) return a;
                    -1 != a.indexOf("&") && (a = a.replace(goog.string.AMP_RE_, "&amp;"));
                    -1 != a.indexOf("<") && (a = a.replace(goog.string.LT_RE_, "&lt;"));
                    -1 != a.indexOf(">") && (a = a.replace(goog.string.GT_RE_, "&gt;"));
                    -1 != a.indexOf('"') && (a = a.replace(goog.string.QUOT_RE_, "&quot;"));
                    -1 != a.indexOf("'") && (a = a.replace(goog.string.SINGLE_QUOTE_RE_, "&#39;"));
                    -1 != a.indexOf("\x00") && (a = a.replace(goog.string.NULL_RE_, "&#0;"));
                    goog.string.DETECT_DOUBLE_ESCAPING && -1 != a.indexOf("e") && (a = a.replace(goog.string.E_RE_, "&#101;"));
                }
                return a;
            };
            goog.string.AMP_RE_ = /&/g;
            goog.string.LT_RE_ = /</g;
            goog.string.GT_RE_ = />/g;
            goog.string.QUOT_RE_ = /"/g;
            goog.string.SINGLE_QUOTE_RE_ = /'/g;
            goog.string.NULL_RE_ = /\x00/g;
            goog.string.E_RE_ = /e/g;
            goog.string.ALL_RE_ = goog.string.DETECT_DOUBLE_ESCAPING ? /[\x00&<>"'e]/ : /[\x00&<>"']/;
            goog.string.unescapeEntities = function (a) {
                return goog.string.contains(a, "&") ? !goog.string.FORCE_NON_DOM_HTML_UNESCAPING && "document" in goog.global ? goog.string.unescapeEntitiesUsingDom_(a) : goog.string.unescapePureXmlEntities_(a) : a;
            };
            goog.string.unescapeEntitiesWithDocument = function (a, b) {
                return goog.string.contains(a, "&") ? goog.string.unescapeEntitiesUsingDom_(a, b) : a;
            };
            goog.string.unescapeEntitiesUsingDom_ = function (a, b) {
                var c = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"' },
                    d;
                d = b ? b.createElement("div") : goog.global.document.createElement("div");
                return a.replace(goog.string.HTML_ENTITY_PATTERN_, function (a, b) {
                    var g = c[a];
                    if (g) return g;
                    if ("#" == b.charAt(0)) {
                        var h = Number("0" + b.substr(1));
                        isNaN(h) || (g = String.fromCharCode(h));
                    }
                    g || (d.innerHTML = a + " ", g = d.firstChild.nodeValue.slice(0, -1));
                    return c[a] = g;
                });
            };
            goog.string.unescapePureXmlEntities_ = function (a) {
                return a.replace(/&([^;]+);/g, function (a, c) {
                    switch (c) {
                        case "amp":
                            return "&";
                        case "lt":
                            return "<";
                        case "gt":
                            return ">";
                        case "quot":
                            return '"';
                        default:
                            if ("#" == c.charAt(0)) {
                                var d = Number("0" + c.substr(1));
                                if (!isNaN(d)) return String.fromCharCode(d);
                            }
                            return a;
                    }
                });
            };
            goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;
            goog.string.whitespaceEscape = function (a, b) {
                return goog.string.newLineToBr(a.replace(/  /g, " &#160;"), b);
            };
            goog.string.preserveSpaces = function (a) {
                return a.replace(/(^|[\n ]) /g, "$1" + goog.string.Unicode.NBSP);
            };
            goog.string.stripQuotes = function (a, b) {
                for (var c = b.length, d = 0; d < c; d++) {
                    var e = 1 == c ? b : b.charAt(d);
                    if (a.charAt(0) == e && a.charAt(a.length - 1) == e) return a.substring(1, a.length - 1);
                }
                return a;
            };
            goog.string.truncate = function (a, b, c) {
                c && (a = goog.string.unescapeEntities(a));
                a.length > b && (a = a.substring(0, b - 3) + "...");
                c && (a = goog.string.htmlEscape(a));
                return a;
            };
            goog.string.truncateMiddle = function (a, b, c, d) {
                c && (a = goog.string.unescapeEntities(a));
                if (d && a.length > b) {
                    d > b && (d = b);
                    var e = a.length - d;
                    a = a.substring(0, b - d) + "..." + a.substring(e);
                } else a.length > b && (d = Math.floor(b / 2), e = a.length - d, a = a.substring(0, d + b % 2) + "..." + a.substring(e));
                c && (a = goog.string.htmlEscape(a));
                return a;
            };
            goog.string.specialEscapeChars_ = {
                "\x00": "\\0",
                "\b": "\\b",
                "\f": "\\f",
                "\n": "\\n",
                "\r": "\\r",
                "\t": "\\t",
                "\x0B": "\\x0B",
                '"': '\\"',
                "\\": "\\\\",
                "<": "<"
            };
            goog.string.jsEscapeCache_ = { "'": "\\'" };
            goog.string.quote = function (a) {
                a = String(a);
                for (var b = ['"'], c = 0; c < a.length; c++) {
                    var d = a.charAt(c),
                        e = d.charCodeAt(0);
                    b[c + 1] = goog.string.specialEscapeChars_[d] || (31 < e && 127 > e ? d : goog.string.escapeChar(d));
                }
                b.push('"');
                return b.join("");
            };
            goog.string.escapeString = function (a) {
                for (var b = [], c = 0; c < a.length; c++) {
                    b[c] = goog.string.escapeChar(a.charAt(c));
                }return b.join("");
            };
            goog.string.escapeChar = function (a) {
                if (a in goog.string.jsEscapeCache_) return goog.string.jsEscapeCache_[a];
                if (a in goog.string.specialEscapeChars_) return goog.string.jsEscapeCache_[a] = goog.string.specialEscapeChars_[a];
                var b,
                    c = a.charCodeAt(0);
                if (31 < c && 127 > c) b = a;else {
                    if (256 > c) {
                        if (b = "\\x", 16 > c || 256 < c) b += "0";
                    } else b = "\\u", 4096 > c && (b += "0");
                    b += c.toString(16).toUpperCase();
                }
                return goog.string.jsEscapeCache_[a] = b;
            };
            goog.string.contains = function (a, b) {
                return -1 != a.indexOf(b);
            };
            goog.string.caseInsensitiveContains = function (a, b) {
                return goog.string.contains(a.toLowerCase(), b.toLowerCase());
            };
            goog.string.countOf = function (a, b) {
                return a && b ? a.split(b).length - 1 : 0;
            };
            goog.string.removeAt = function (a, b, c) {
                var d = a;
                0 <= b && b < a.length && 0 < c && (d = a.substr(0, b) + a.substr(b + c, a.length - b - c));
                return d;
            };
            goog.string.remove = function (a, b) {
                var c = new RegExp(goog.string.regExpEscape(b), "");
                return a.replace(c, "");
            };
            goog.string.removeAll = function (a, b) {
                var c = new RegExp(goog.string.regExpEscape(b), "g");
                return a.replace(c, "");
            };
            goog.string.regExpEscape = function (a) {
                return String(a).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
            };
            goog.string.repeat = String.prototype.repeat ? function (a, b) {
                return a.repeat(b);
            } : function (a, b) {
                return Array(b + 1).join(a);
            };
            goog.string.padNumber = function (a, b, c) {
                a = goog.isDef(c) ? a.toFixed(c) : String(a);
                c = a.indexOf(".");
                -1 == c && (c = a.length);
                return goog.string.repeat("0", Math.max(0, b - c)) + a;
            };
            goog.string.makeSafe = function (a) {
                return null == a ? "" : String(a);
            };
            goog.string.buildString = function (a) {
                return Array.prototype.join.call(arguments, "");
            };
            goog.string.getRandomString = function () {
                return Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ goog.now()).toString(36);
            };
            goog.string.compareVersions = function (a, b) {
                for (var c = 0, d = goog.string.trim(String(a)).split("."), e = goog.string.trim(String(b)).split("."), f = Math.max(d.length, e.length), g = 0; 0 == c && g < f; g++) {
                    var h = d[g] || "",
                        k = e[g] || "",
                        l = RegExp("(\\d*)(\\D*)", "g"),
                        p = RegExp("(\\d*)(\\D*)", "g");
                    do {
                        var m = l.exec(h) || ["", "", ""],
                            n = p.exec(k) || ["", "", ""];
                        if (0 == m[0].length && 0 == n[0].length) break;
                        var c = 0 == m[1].length ? 0 : parseInt(m[1], 10),
                            q = 0 == n[1].length ? 0 : parseInt(n[1], 10),
                            c = goog.string.compareElements_(c, q) || goog.string.compareElements_(0 == m[2].length, 0 == n[2].length) || goog.string.compareElements_(m[2], n[2]);
                    } while (0 == c);
                }
                return c;
            };
            goog.string.compareElements_ = function (a, b) {
                return a < b ? -1 : a > b ? 1 : 0;
            };
            goog.string.hashCode = function (a) {
                for (var b = 0, c = 0; c < a.length; ++c) {
                    b = 31 * b + a.charCodeAt(c) >>> 0;
                }return b;
            };
            goog.string.uniqueStringCounter_ = 2147483648 * Math.random() | 0;
            goog.string.createUniqueString = function () {
                return "goog_" + goog.string.uniqueStringCounter_++;
            };
            goog.string.toNumber = function (a) {
                var b = Number(a);
                return 0 == b && goog.string.isEmptyOrWhitespace(a) ? NaN : b;
            };
            goog.string.isLowerCamelCase = function (a) {
                return (/^[a-z]+([A-Z][a-z]*)*$/.test(a)
                );
            };
            goog.string.isUpperCamelCase = function (a) {
                return (/^([A-Z][a-z]*)+$/.test(a)
                );
            };
            goog.string.toCamelCase = function (a) {
                return String(a).replace(/\-([a-z])/g, function (a, c) {
                    return c.toUpperCase();
                });
            };
            goog.string.toSelectorCase = function (a) {
                return String(a).replace(/([A-Z])/g, "-$1").toLowerCase();
            };
            goog.string.toTitleCase = function (a, b) {
                var c = goog.isString(b) ? goog.string.regExpEscape(b) : "\\s";
                return a.replace(new RegExp("(^" + (c ? "|[" + c + "]+" : "") + ")([a-z])", "g"), function (a, b, c) {
                    return b + c.toUpperCase();
                });
            };
            goog.string.capitalize = function (a) {
                return String(a.charAt(0)).toUpperCase() + String(a.substr(1)).toLowerCase();
            };
            goog.string.parseInt = function (a) {
                isFinite(a) && (a = String(a));
                return goog.isString(a) ? /^\s*-?0x/i.test(a) ? parseInt(a, 16) : parseInt(a, 10) : NaN;
            };
            goog.string.splitLimit = function (a, b, c) {
                a = a.split(b);
                for (var d = []; 0 < c && a.length;) {
                    d.push(a.shift()), c--;
                }a.length && d.push(a.join(b));
                return d;
            };
            goog.string.editDistance = function (a, b) {
                var c = [],
                    d = [];
                if (a == b) return 0;
                if (!a.length || !b.length) return Math.max(a.length, b.length);
                for (var e = 0; e < b.length + 1; e++) {
                    c[e] = e;
                }for (e = 0; e < a.length; e++) {
                    d[0] = e + 1;
                    for (var f = 0; f < b.length; f++) {
                        d[f + 1] = Math.min(d[f] + 1, c[f + 1] + 1, c[f] + Number(a[e] != b[f]));
                    }for (f = 0; f < c.length; f++) {
                        c[f] = d[f];
                    }
                }
                return d[b.length];
            };
            goog.asserts = {};
            goog.asserts.ENABLE_ASSERTS = goog.DEBUG;
            goog.asserts.AssertionError = function (a, b) {
                b.unshift(a);
                goog.debug.Error.call(this, goog.string.subs.apply(null, b));
                b.shift();
                this.messagePattern = a;
            };
            goog.inherits(goog.asserts.AssertionError, goog.debug.Error);
            goog.asserts.AssertionError.prototype.name = "AssertionError";
            goog.asserts.DEFAULT_ERROR_HANDLER = function (a) {
                throw a;
            };
            goog.asserts.errorHandler_ = goog.asserts.DEFAULT_ERROR_HANDLER;
            goog.asserts.doAssertFailure_ = function (a, b, c, d) {
                var e = "Assertion failed";
                if (c) var e = e + (": " + c),
                    f = d;else a && (e += ": " + a, f = b);
                a = new goog.asserts.AssertionError("" + e, f || []);
                goog.asserts.errorHandler_(a);
            };
            goog.asserts.setErrorHandler = function (a) {
                goog.asserts.ENABLE_ASSERTS && (goog.asserts.errorHandler_ = a);
            };
            goog.asserts.assert = function (a, b, c) {
                goog.asserts.ENABLE_ASSERTS && !a && goog.asserts.doAssertFailure_("", null, b, Array.prototype.slice.call(arguments, 2));
                return a;
            };
            goog.asserts.fail = function (a, b) {
                goog.asserts.ENABLE_ASSERTS && goog.asserts.errorHandler_(new goog.asserts.AssertionError("Failure" + (a ? ": " + a : ""), Array.prototype.slice.call(arguments, 1)));
            };
            goog.asserts.assertNumber = function (a, b, c) {
                goog.asserts.ENABLE_ASSERTS && !goog.isNumber(a) && goog.asserts.doAssertFailure_("Expected number but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
                return a;
            };
            goog.asserts.assertString = function (a, b, c) {
                goog.asserts.ENABLE_ASSERTS && !goog.isString(a) && goog.asserts.doAssertFailure_("Expected string but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
                return a;
            };
            goog.asserts.assertFunction = function (a, b, c) {
                goog.asserts.ENABLE_ASSERTS && !goog.isFunction(a) && goog.asserts.doAssertFailure_("Expected function but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
                return a;
            };
            goog.asserts.assertObject = function (a, b, c) {
                goog.asserts.ENABLE_ASSERTS && !goog.isObject(a) && goog.asserts.doAssertFailure_("Expected object but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
                return a;
            };
            goog.asserts.assertArray = function (a, b, c) {
                goog.asserts.ENABLE_ASSERTS && !goog.isArray(a) && goog.asserts.doAssertFailure_("Expected array but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
                return a;
            };
            goog.asserts.assertBoolean = function (a, b, c) {
                goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(a) && goog.asserts.doAssertFailure_("Expected boolean but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
                return a;
            };
            goog.asserts.assertElement = function (a, b, c) {
                !goog.asserts.ENABLE_ASSERTS || goog.isObject(a) && a.nodeType == goog.dom.NodeType.ELEMENT || goog.asserts.doAssertFailure_("Expected Element but got %s: %s.", [goog.typeOf(a), a], b, Array.prototype.slice.call(arguments, 2));
                return a;
            };
            goog.asserts.assertInstanceof = function (a, b, c, d) {
                !goog.asserts.ENABLE_ASSERTS || a instanceof b || goog.asserts.doAssertFailure_("Expected instanceof %s but got %s.", [goog.asserts.getType_(b), goog.asserts.getType_(a)], c, Array.prototype.slice.call(arguments, 3));
                return a;
            };
            goog.asserts.assertObjectPrototypeIsIntact = function () {
                for (var a in Object.prototype) {
                    goog.asserts.fail(a + " should not be enumerable in Object.prototype.");
                }
            };
            goog.asserts.getType_ = function (a) {
                return a instanceof Function ? a.displayName || a.name || "unknown type name" : a instanceof Object ? a.constructor.displayName || a.constructor.name || Object.prototype.toString.call(a) : null === a ? "null" : typeof a === "undefined" ? "undefined" : _typeof(a);
            };
            var jspb = {
                Map: function Map(a, b) {
                    this.arr_ = a;
                    this.valueCtor_ = b;
                    this.map_ = {};
                    this.arrClean = !0;
                    0 < this.arr_.length && this.loadFromArray_();
                }
            };
            jspb.Map.prototype.loadFromArray_ = function () {
                for (var a = 0; a < this.arr_.length; a++) {
                    var b = this.arr_[a],
                        c = b[0];
                    this.map_[c.toString()] = new jspb.Map.Entry_(c, b[1]);
                }
                this.arrClean = !0;
            };
            jspb.Map.prototype.toArray = function () {
                if (this.arrClean) {
                    if (this.valueCtor_) {
                        var a = this.map_,
                            b;
                        for (b in a) {
                            if (Object.prototype.hasOwnProperty.call(a, b)) {
                                var c = a[b].valueWrapper;
                                c && c.toArray();
                            }
                        }
                    }
                } else {
                    this.arr_.length = 0;
                    a = this.stringKeys_();
                    a.sort();
                    for (b = 0; b < a.length; b++) {
                        var d = this.map_[a[b]];
                        (c = d.valueWrapper) && c.toArray();
                        this.arr_.push([d.key, d.value]);
                    }
                    this.arrClean = !0;
                }
                return this.arr_;
            };
            jspb.Map.prototype.toObject = function (a, b) {
                for (var c = this.toArray(), d = [], e = 0; e < c.length; e++) {
                    var f = this.map_[c[e][0].toString()];
                    this.wrapEntry_(f);
                    var g = f.valueWrapper;
                    g ? (goog.asserts.assert(b), d.push([f.key, b(a, g)])) : d.push([f.key, f.value]);
                }
                return d;
            };
            jspb.Map.fromObject = function (a, b, c) {
                b = new jspb.Map([], b);
                for (var d = 0; d < a.length; d++) {
                    var e = a[d][0],
                        f = c(a[d][1]);
                    b.set(e, f);
                }
                return b;
            };
            jspb.Map.ArrayIteratorIterable_ = function (a) {
                this.idx_ = 0;
                this.arr_ = a;
            };
            jspb.Map.ArrayIteratorIterable_.prototype.next = function () {
                return this.idx_ < this.arr_.length ? { done: !1, value: this.arr_[this.idx_++] } : {
                    done: !0,
                    value: void 0
                };
            };
            $jscomp.initSymbol();
            "undefined" != typeof Symbol && ($jscomp.initSymbol(), $jscomp.initSymbolIterator(), jspb.Map.ArrayIteratorIterable_.prototype[Symbol.iterator] = function () {
                return this;
            });
            jspb.Map.prototype.getLength = function () {
                return this.stringKeys_().length;
            };
            jspb.Map.prototype.clear = function () {
                this.map_ = {};
                this.arrClean = !1;
            };
            jspb.Map.prototype.del = function (a) {
                a = a.toString();
                var b = this.map_.hasOwnProperty(a);
                delete this.map_[a];
                this.arrClean = !1;
                return b;
            };
            jspb.Map.prototype.getEntryList = function () {
                var a = [],
                    b = this.stringKeys_();
                b.sort();
                for (var c = 0; c < b.length; c++) {
                    var d = this.map_[b[c]];
                    a.push([d.key, d.value]);
                }
                return a;
            };
            jspb.Map.prototype.entries = function () {
                var a = [],
                    b = this.stringKeys_();
                b.sort();
                for (var c = 0; c < b.length; c++) {
                    var d = this.map_[b[c]];
                    a.push([d.key, this.wrapEntry_(d)]);
                }
                return new jspb.Map.ArrayIteratorIterable_(a);
            };
            jspb.Map.prototype.keys = function () {
                var a = [],
                    b = this.stringKeys_();
                b.sort();
                for (var c = 0; c < b.length; c++) {
                    a.push(this.map_[b[c]].key);
                }return new jspb.Map.ArrayIteratorIterable_(a);
            };
            jspb.Map.prototype.values = function () {
                var a = [],
                    b = this.stringKeys_();
                b.sort();
                for (var c = 0; c < b.length; c++) {
                    a.push(this.wrapEntry_(this.map_[b[c]]));
                }return new jspb.Map.ArrayIteratorIterable_(a);
            };
            jspb.Map.prototype.forEach = function (a, b) {
                var c = this.stringKeys_();
                c.sort();
                for (var d = 0; d < c.length; d++) {
                    var e = this.map_[c[d]];
                    a.call(b, this.wrapEntry_(e), e.key, this);
                }
            };
            jspb.Map.prototype.set = function (a, b) {
                var c = new jspb.Map.Entry_(a);
                this.valueCtor_ ? (c.valueWrapper = b, c.value = b.toArray()) : c.value = b;
                this.map_[a.toString()] = c;
                this.arrClean = !1;
                return this;
            };
            jspb.Map.prototype.wrapEntry_ = function (a) {
                return this.valueCtor_ ? (a.valueWrapper || (a.valueWrapper = new this.valueCtor_(a.value)), a.valueWrapper) : a.value;
            };
            jspb.Map.prototype.get = function (a) {
                if (a = this.map_[a.toString()]) return this.wrapEntry_(a);
            };
            jspb.Map.prototype.has = function (a) {
                return a.toString() in this.map_;
            };
            jspb.Map.prototype.serializeBinary = function (a, b, c, d, e) {
                var f = this.stringKeys_();
                f.sort();
                for (var g = 0; g < f.length; g++) {
                    var h = this.map_[f[g]];
                    b.beginSubMessage(a);
                    c.call(b, 1, h.key);
                    this.valueCtor_ ? d.call(b, 2, this.wrapEntry_(h), e) : d.call(b, 2, h.value);
                    b.endSubMessage();
                }
            };
            jspb.Map.deserializeBinary = function (a, b, c, d, e) {
                for (var f = void 0, g = void 0; b.nextField() && !b.isEndGroup();) {
                    var h = b.getFieldNumber();
                    1 == h ? f = c.call(b) : 2 == h && (a.valueCtor_ ? (g = new a.valueCtor_(), d.call(b, g, e)) : g = d.call(b));
                }
                goog.asserts.assert(void 0 != f);
                goog.asserts.assert(void 0 != g);
                a.set(f, g);
            };
            jspb.Map.prototype.stringKeys_ = function () {
                var a = this.map_,
                    b = [],
                    c;
                for (c in a) {
                    Object.prototype.hasOwnProperty.call(a, c) && b.push(c);
                }return b;
            };
            jspb.Map.Entry_ = function (a, b) {
                this.key = a;
                this.value = b;
                this.valueWrapper = void 0;
            };
            goog.array = {};
            goog.NATIVE_ARRAY_PROTOTYPES = goog.TRUSTED_SITE;
            goog.array.ASSUME_NATIVE_FUNCTIONS = !1;
            goog.array.peek = function (a) {
                return a[a.length - 1];
            };
            goog.array.last = goog.array.peek;
            goog.array.indexOf = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.indexOf) ? function (a, b, c) {
                goog.asserts.assert(null != a.length);
                return Array.prototype.indexOf.call(a, b, c);
            } : function (a, b, c) {
                c = null == c ? 0 : 0 > c ? Math.max(0, a.length + c) : c;
                if (goog.isString(a)) return goog.isString(b) && 1 == b.length ? a.indexOf(b, c) : -1;
                for (; c < a.length; c++) {
                    if (c in a && a[c] === b) return c;
                }return -1;
            };
            goog.array.lastIndexOf = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.lastIndexOf) ? function (a, b, c) {
                goog.asserts.assert(null != a.length);
                return Array.prototype.lastIndexOf.call(a, b, null == c ? a.length - 1 : c);
            } : function (a, b, c) {
                c = null == c ? a.length - 1 : c;
                0 > c && (c = Math.max(0, a.length + c));
                if (goog.isString(a)) return goog.isString(b) && 1 == b.length ? a.lastIndexOf(b, c) : -1;
                for (; 0 <= c; c--) {
                    if (c in a && a[c] === b) return c;
                }return -1;
            };
            goog.array.forEach = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.forEach) ? function (a, b, c) {
                goog.asserts.assert(null != a.length);
                Array.prototype.forEach.call(a, b, c);
            } : function (a, b, c) {
                for (var d = a.length, e = goog.isString(a) ? a.split("") : a, f = 0; f < d; f++) {
                    f in e && b.call(c, e[f], f, a);
                }
            };
            goog.array.forEachRight = function (a, b, c) {
                for (var d = a.length, e = goog.isString(a) ? a.split("") : a, d = d - 1; 0 <= d; --d) {
                    d in e && b.call(c, e[d], d, a);
                }
            };
            goog.array.filter = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.filter) ? function (a, b, c) {
                goog.asserts.assert(null != a.length);
                return Array.prototype.filter.call(a, b, c);
            } : function (a, b, c) {
                for (var d = a.length, e = [], f = 0, g = goog.isString(a) ? a.split("") : a, h = 0; h < d; h++) {
                    if (h in g) {
                        var k = g[h];
                        b.call(c, k, h, a) && (e[f++] = k);
                    }
                }return e;
            };
            goog.array.map = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.map) ? function (a, b, c) {
                goog.asserts.assert(null != a.length);
                return Array.prototype.map.call(a, b, c);
            } : function (a, b, c) {
                for (var d = a.length, e = Array(d), f = goog.isString(a) ? a.split("") : a, g = 0; g < d; g++) {
                    g in f && (e[g] = b.call(c, f[g], g, a));
                }return e;
            };
            goog.array.reduce = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduce) ? function (a, b, c, d) {
                goog.asserts.assert(null != a.length);
                d && (b = goog.bind(b, d));
                return Array.prototype.reduce.call(a, b, c);
            } : function (a, b, c, d) {
                var e = c;
                goog.array.forEach(a, function (c, g) {
                    e = b.call(d, e, c, g, a);
                });
                return e;
            };
            goog.array.reduceRight = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduceRight) ? function (a, b, c, d) {
                goog.asserts.assert(null != a.length);
                goog.asserts.assert(null != b);
                d && (b = goog.bind(b, d));
                return Array.prototype.reduceRight.call(a, b, c);
            } : function (a, b, c, d) {
                var e = c;
                goog.array.forEachRight(a, function (c, g) {
                    e = b.call(d, e, c, g, a);
                });
                return e;
            };
            goog.array.some = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.some) ? function (a, b, c) {
                goog.asserts.assert(null != a.length);
                return Array.prototype.some.call(a, b, c);
            } : function (a, b, c) {
                for (var d = a.length, e = goog.isString(a) ? a.split("") : a, f = 0; f < d; f++) {
                    if (f in e && b.call(c, e[f], f, a)) return !0;
                }return !1;
            };
            goog.array.every = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.every) ? function (a, b, c) {
                goog.asserts.assert(null != a.length);
                return Array.prototype.every.call(a, b, c);
            } : function (a, b, c) {
                for (var d = a.length, e = goog.isString(a) ? a.split("") : a, f = 0; f < d; f++) {
                    if (f in e && !b.call(c, e[f], f, a)) return !1;
                }return !0;
            };
            goog.array.count = function (a, b, c) {
                var d = 0;
                goog.array.forEach(a, function (a, f, g) {
                    b.call(c, a, f, g) && ++d;
                }, c);
                return d;
            };
            goog.array.find = function (a, b, c) {
                b = goog.array.findIndex(a, b, c);
                return 0 > b ? null : goog.isString(a) ? a.charAt(b) : a[b];
            };
            goog.array.findIndex = function (a, b, c) {
                for (var d = a.length, e = goog.isString(a) ? a.split("") : a, f = 0; f < d; f++) {
                    if (f in e && b.call(c, e[f], f, a)) return f;
                }return -1;
            };
            goog.array.findRight = function (a, b, c) {
                b = goog.array.findIndexRight(a, b, c);
                return 0 > b ? null : goog.isString(a) ? a.charAt(b) : a[b];
            };
            goog.array.findIndexRight = function (a, b, c) {
                for (var d = a.length, e = goog.isString(a) ? a.split("") : a, d = d - 1; 0 <= d; d--) {
                    if (d in e && b.call(c, e[d], d, a)) return d;
                }return -1;
            };
            goog.array.contains = function (a, b) {
                return 0 <= goog.array.indexOf(a, b);
            };
            goog.array.isEmpty = function (a) {
                return 0 == a.length;
            };
            goog.array.clear = function (a) {
                if (!goog.isArray(a)) for (var b = a.length - 1; 0 <= b; b--) {
                    delete a[b];
                }a.length = 0;
            };
            goog.array.insert = function (a, b) {
                goog.array.contains(a, b) || a.push(b);
            };
            goog.array.insertAt = function (a, b, c) {
                goog.array.splice(a, c, 0, b);
            };
            goog.array.insertArrayAt = function (a, b, c) {
                goog.partial(goog.array.splice, a, c, 0).apply(null, b);
            };
            goog.array.insertBefore = function (a, b, c) {
                var d;
                2 == arguments.length || 0 > (d = goog.array.indexOf(a, c)) ? a.push(b) : goog.array.insertAt(a, b, d);
            };
            goog.array.remove = function (a, b) {
                var c = goog.array.indexOf(a, b),
                    d;
                (d = 0 <= c) && goog.array.removeAt(a, c);
                return d;
            };
            goog.array.removeAt = function (a, b) {
                goog.asserts.assert(null != a.length);
                return 1 == Array.prototype.splice.call(a, b, 1).length;
            };
            goog.array.removeIf = function (a, b, c) {
                b = goog.array.findIndex(a, b, c);
                return 0 <= b ? (goog.array.removeAt(a, b), !0) : !1;
            };
            goog.array.removeAllIf = function (a, b, c) {
                var d = 0;
                goog.array.forEachRight(a, function (e, f) {
                    b.call(c, e, f, a) && goog.array.removeAt(a, f) && d++;
                });
                return d;
            };
            goog.array.concat = function (a) {
                return Array.prototype.concat.apply(Array.prototype, arguments);
            };
            goog.array.join = function (a) {
                return Array.prototype.concat.apply(Array.prototype, arguments);
            };
            goog.array.toArray = function (a) {
                var b = a.length;
                if (0 < b) {
                    for (var c = Array(b), d = 0; d < b; d++) {
                        c[d] = a[d];
                    }return c;
                }
                return [];
            };
            goog.array.clone = goog.array.toArray;
            goog.array.extend = function (a, b) {
                for (var c = 1; c < arguments.length; c++) {
                    var d = arguments[c];
                    if (goog.isArrayLike(d)) {
                        var e = a.length || 0,
                            f = d.length || 0;
                        a.length = e + f;
                        for (var g = 0; g < f; g++) {
                            a[e + g] = d[g];
                        }
                    } else a.push(d);
                }
            };
            goog.array.splice = function (a, b, c, d) {
                goog.asserts.assert(null != a.length);
                return Array.prototype.splice.apply(a, goog.array.slice(arguments, 1));
            };
            goog.array.slice = function (a, b, c) {
                goog.asserts.assert(null != a.length);
                return 2 >= arguments.length ? Array.prototype.slice.call(a, b) : Array.prototype.slice.call(a, b, c);
            };
            goog.array.removeDuplicates = function (a, b, c) {
                b = b || a;
                var d = function d(a) {
                    return goog.isObject(a) ? "o" + goog.getUid(a) : (typeof a === "undefined" ? "undefined" : _typeof(a)).charAt(0) + a;
                };
                c = c || d;
                for (var d = {}, e = 0, f = 0; f < a.length;) {
                    var g = a[f++],
                        h = c(g);
                    Object.prototype.hasOwnProperty.call(d, h) || (d[h] = !0, b[e++] = g);
                }
                b.length = e;
            };
            goog.array.binarySearch = function (a, b, c) {
                return goog.array.binarySearch_(a, c || goog.array.defaultCompare, !1, b);
            };
            goog.array.binarySelect = function (a, b, c) {
                return goog.array.binarySearch_(a, b, !0, void 0, c);
            };
            goog.array.binarySearch_ = function (a, b, c, d, e) {
                for (var f = 0, g = a.length, h; f < g;) {
                    var k = f + g >> 1,
                        l;
                    l = c ? b.call(e, a[k], k, a) : b(d, a[k]);
                    0 < l ? f = k + 1 : (g = k, h = !l);
                }
                return h ? f : ~f;
            };
            goog.array.sort = function (a, b) {
                a.sort(b || goog.array.defaultCompare);
            };
            goog.array.stableSort = function (a, b) {
                for (var c = 0; c < a.length; c++) {
                    a[c] = { index: c, value: a[c] };
                }var d = b || goog.array.defaultCompare;
                goog.array.sort(a, function (a, b) {
                    return d(a.value, b.value) || a.index - b.index;
                });
                for (c = 0; c < a.length; c++) {
                    a[c] = a[c].value;
                }
            };
            goog.array.sortByKey = function (a, b, c) {
                var d = c || goog.array.defaultCompare;
                goog.array.sort(a, function (a, c) {
                    return d(b(a), b(c));
                });
            };
            goog.array.sortObjectsByKey = function (a, b, c) {
                goog.array.sortByKey(a, function (a) {
                    return a[b];
                }, c);
            };
            goog.array.isSorted = function (a, b, c) {
                b = b || goog.array.defaultCompare;
                for (var d = 1; d < a.length; d++) {
                    var e = b(a[d - 1], a[d]);
                    if (0 < e || 0 == e && c) return !1;
                }
                return !0;
            };
            goog.array.equals = function (a, b, c) {
                if (!goog.isArrayLike(a) || !goog.isArrayLike(b) || a.length != b.length) return !1;
                var d = a.length;
                c = c || goog.array.defaultCompareEquality;
                for (var e = 0; e < d; e++) {
                    if (!c(a[e], b[e])) return !1;
                }return !0;
            };
            goog.array.compare3 = function (a, b, c) {
                c = c || goog.array.defaultCompare;
                for (var d = Math.min(a.length, b.length), e = 0; e < d; e++) {
                    var f = c(a[e], b[e]);
                    if (0 != f) return f;
                }
                return goog.array.defaultCompare(a.length, b.length);
            };
            goog.array.defaultCompare = function (a, b) {
                return a > b ? 1 : a < b ? -1 : 0;
            };
            goog.array.inverseDefaultCompare = function (a, b) {
                return -goog.array.defaultCompare(a, b);
            };
            goog.array.defaultCompareEquality = function (a, b) {
                return a === b;
            };
            goog.array.binaryInsert = function (a, b, c) {
                c = goog.array.binarySearch(a, b, c);
                return 0 > c ? (goog.array.insertAt(a, b, -(c + 1)), !0) : !1;
            };
            goog.array.binaryRemove = function (a, b, c) {
                b = goog.array.binarySearch(a, b, c);
                return 0 <= b ? goog.array.removeAt(a, b) : !1;
            };
            goog.array.bucket = function (a, b, c) {
                for (var d = {}, e = 0; e < a.length; e++) {
                    var f = a[e],
                        g = b.call(c, f, e, a);
                    goog.isDef(g) && (d[g] || (d[g] = [])).push(f);
                }
                return d;
            };
            goog.array.toObject = function (a, b, c) {
                var d = {};
                goog.array.forEach(a, function (e, f) {
                    d[b.call(c, e, f, a)] = e;
                });
                return d;
            };
            goog.array.range = function (a, b, c) {
                var d = [],
                    e = 0,
                    f = a;
                c = c || 1;
                void 0 !== b && (e = a, f = b);
                if (0 > c * (f - e)) return [];
                if (0 < c) for (a = e; a < f; a += c) {
                    d.push(a);
                } else for (a = e; a > f; a += c) {
                    d.push(a);
                }return d;
            };
            goog.array.repeat = function (a, b) {
                for (var c = [], d = 0; d < b; d++) {
                    c[d] = a;
                }return c;
            };
            goog.array.flatten = function (a) {
                for (var b = [], c = 0; c < arguments.length; c++) {
                    var d = arguments[c];
                    if (goog.isArray(d)) for (var e = 0; e < d.length; e += 8192) {
                        for (var f = goog.array.slice(d, e, e + 8192), f = goog.array.flatten.apply(null, f), g = 0; g < f.length; g++) {
                            b.push(f[g]);
                        }
                    } else b.push(d);
                }
                return b;
            };
            goog.array.rotate = function (a, b) {
                goog.asserts.assert(null != a.length);
                a.length && (b %= a.length, 0 < b ? Array.prototype.unshift.apply(a, a.splice(-b, b)) : 0 > b && Array.prototype.push.apply(a, a.splice(0, -b)));
                return a;
            };
            goog.array.moveItem = function (a, b, c) {
                goog.asserts.assert(0 <= b && b < a.length);
                goog.asserts.assert(0 <= c && c < a.length);
                b = Array.prototype.splice.call(a, b, 1);
                Array.prototype.splice.call(a, c, 0, b[0]);
            };
            goog.array.zip = function (a) {
                if (!arguments.length) return [];
                for (var b = [], c = arguments[0].length, d = 1; d < arguments.length; d++) {
                    arguments[d].length < c && (c = arguments[d].length);
                }for (d = 0; d < c; d++) {
                    for (var e = [], f = 0; f < arguments.length; f++) {
                        e.push(arguments[f][d]);
                    }b.push(e);
                }
                return b;
            };
            goog.array.shuffle = function (a, b) {
                for (var c = b || Math.random, d = a.length - 1; 0 < d; d--) {
                    var e = Math.floor(c() * (d + 1)),
                        f = a[d];
                    a[d] = a[e];
                    a[e] = f;
                }
            };
            goog.array.copyByIndex = function (a, b) {
                var c = [];
                goog.array.forEach(b, function (b) {
                    c.push(a[b]);
                });
                return c;
            };
            goog.crypt = {};
            goog.crypt.stringToByteArray = function (a) {
                for (var b = [], c = 0, d = 0; d < a.length; d++) {
                    for (var e = a.charCodeAt(d); 255 < e;) {
                        b[c++] = e & 255, e >>= 8;
                    }b[c++] = e;
                }
                return b;
            };
            goog.crypt.byteArrayToString = function (a) {
                if (8192 >= a.length) return String.fromCharCode.apply(null, a);
                for (var b = "", c = 0; c < a.length; c += 8192) {
                    var d = goog.array.slice(a, c, c + 8192),
                        b = b + String.fromCharCode.apply(null, d);
                }return b;
            };
            goog.crypt.byteArrayToHex = function (a) {
                return goog.array.map(a, function (a) {
                    a = a.toString(16);
                    return 1 < a.length ? a : "0" + a;
                }).join("");
            };
            goog.crypt.hexToByteArray = function (a) {
                goog.asserts.assert(0 == a.length % 2, "Key string length must be multiple of 2");
                for (var b = [], c = 0; c < a.length; c += 2) {
                    b.push(parseInt(a.substring(c, c + 2), 16));
                }return b;
            };
            goog.crypt.stringToUtf8ByteArray = function (a) {
                for (var b = [], c = 0, d = 0; d < a.length; d++) {
                    var e = a.charCodeAt(d);
                    128 > e ? b[c++] = e : (2048 > e ? b[c++] = e >> 6 | 192 : (55296 == (e & 64512) && d + 1 < a.length && 56320 == (a.charCodeAt(d + 1) & 64512) ? (e = 65536 + ((e & 1023) << 10) + (a.charCodeAt(++d) & 1023), b[c++] = e >> 18 | 240, b[c++] = e >> 12 & 63 | 128) : b[c++] = e >> 12 | 224, b[c++] = e >> 6 & 63 | 128), b[c++] = e & 63 | 128);
                }
                return b;
            };
            goog.crypt.utf8ByteArrayToString = function (a) {
                for (var b = [], c = 0, d = 0; c < a.length;) {
                    var e = a[c++];
                    if (128 > e) b[d++] = String.fromCharCode(e);else if (191 < e && 224 > e) {
                        var f = a[c++];
                        b[d++] = String.fromCharCode((e & 31) << 6 | f & 63);
                    } else if (239 < e && 365 > e) {
                        var f = a[c++],
                            g = a[c++],
                            h = a[c++],
                            e = ((e & 7) << 18 | (f & 63) << 12 | (g & 63) << 6 | h & 63) - 65536;
                        b[d++] = String.fromCharCode(55296 + (e >> 10));
                        b[d++] = String.fromCharCode(56320 + (e & 1023));
                    } else f = a[c++], g = a[c++], b[d++] = String.fromCharCode((e & 15) << 12 | (f & 63) << 6 | g & 63);
                }
                return b.join("");
            };
            goog.crypt.xorByteArray = function (a, b) {
                goog.asserts.assert(a.length == b.length, "XOR array lengths must match");
                for (var c = [], d = 0; d < a.length; d++) {
                    c.push(a[d] ^ b[d]);
                }return c;
            };
            goog.labs = {};
            goog.labs.userAgent = {};
            goog.labs.userAgent.util = {};
            goog.labs.userAgent.util.getNativeUserAgentString_ = function () {
                var a = goog.labs.userAgent.util.getNavigator_();
                return a && (a = a.userAgent) ? a : "";
            };
            goog.labs.userAgent.util.getNavigator_ = function () {
                return goog.global.navigator;
            };
            goog.labs.userAgent.util.userAgent_ = goog.labs.userAgent.util.getNativeUserAgentString_();
            goog.labs.userAgent.util.setUserAgent = function (a) {
                goog.labs.userAgent.util.userAgent_ = a || goog.labs.userAgent.util.getNativeUserAgentString_();
            };
            goog.labs.userAgent.util.getUserAgent = function () {
                return goog.labs.userAgent.util.userAgent_;
            };
            goog.labs.userAgent.util.matchUserAgent = function (a) {
                var b = goog.labs.userAgent.util.getUserAgent();
                return goog.string.contains(b, a);
            };
            goog.labs.userAgent.util.matchUserAgentIgnoreCase = function (a) {
                var b = goog.labs.userAgent.util.getUserAgent();
                return goog.string.caseInsensitiveContains(b, a);
            };
            goog.labs.userAgent.util.extractVersionTuples = function (a) {
                for (var b = RegExp("(\\w[\\w ]+)/([^\\s]+)\\s*(?:\\((.*?)\\))?", "g"), c = [], d; d = b.exec(a);) {
                    c.push([d[1], d[2], d[3] || void 0]);
                }return c;
            };
            goog.labs.userAgent.platform = {};
            goog.labs.userAgent.platform.isAndroid = function () {
                return goog.labs.userAgent.util.matchUserAgent("Android");
            };
            goog.labs.userAgent.platform.isIpod = function () {
                return goog.labs.userAgent.util.matchUserAgent("iPod");
            };
            goog.labs.userAgent.platform.isIphone = function () {
                return goog.labs.userAgent.util.matchUserAgent("iPhone") && !goog.labs.userAgent.util.matchUserAgent("iPod") && !goog.labs.userAgent.util.matchUserAgent("iPad");
            };
            goog.labs.userAgent.platform.isIpad = function () {
                return goog.labs.userAgent.util.matchUserAgent("iPad");
            };
            goog.labs.userAgent.platform.isIos = function () {
                return goog.labs.userAgent.platform.isIphone() || goog.labs.userAgent.platform.isIpad() || goog.labs.userAgent.platform.isIpod();
            };
            goog.labs.userAgent.platform.isMacintosh = function () {
                return goog.labs.userAgent.util.matchUserAgent("Macintosh");
            };
            goog.labs.userAgent.platform.isLinux = function () {
                return goog.labs.userAgent.util.matchUserAgent("Linux");
            };
            goog.labs.userAgent.platform.isWindows = function () {
                return goog.labs.userAgent.util.matchUserAgent("Windows");
            };
            goog.labs.userAgent.platform.isChromeOS = function () {
                return goog.labs.userAgent.util.matchUserAgent("CrOS");
            };
            goog.labs.userAgent.platform.getVersion = function () {
                var a = goog.labs.userAgent.util.getUserAgent(),
                    b = "";
                goog.labs.userAgent.platform.isWindows() ? (b = /Windows (?:NT|Phone) ([0-9.]+)/, b = (a = b.exec(a)) ? a[1] : "0.0") : goog.labs.userAgent.platform.isIos() ? (b = /(?:iPhone|iPod|iPad|CPU)\s+OS\s+(\S+)/, b = (a = b.exec(a)) && a[1].replace(/_/g, ".")) : goog.labs.userAgent.platform.isMacintosh() ? (b = /Mac OS X ([0-9_.]+)/, b = (a = b.exec(a)) ? a[1].replace(/_/g, ".") : "10") : goog.labs.userAgent.platform.isAndroid() ? (b = /Android\s+([^\);]+)(\)|;)/, b = (a = b.exec(a)) && a[1]) : goog.labs.userAgent.platform.isChromeOS() && (b = /(?:CrOS\s+(?:i686|x86_64)\s+([0-9.]+))/, b = (a = b.exec(a)) && a[1]);
                return b || "";
            };
            goog.labs.userAgent.platform.isVersionOrHigher = function (a) {
                return 0 <= goog.string.compareVersions(goog.labs.userAgent.platform.getVersion(), a);
            };
            goog.object = {};
            goog.object.forEach = function (a, b, c) {
                for (var d in a) {
                    b.call(c, a[d], d, a);
                }
            };
            goog.object.filter = function (a, b, c) {
                var d = {},
                    e;
                for (e in a) {
                    b.call(c, a[e], e, a) && (d[e] = a[e]);
                }return d;
            };
            goog.object.map = function (a, b, c) {
                var d = {},
                    e;
                for (e in a) {
                    d[e] = b.call(c, a[e], e, a);
                }return d;
            };
            goog.object.some = function (a, b, c) {
                for (var d in a) {
                    if (b.call(c, a[d], d, a)) return !0;
                }return !1;
            };
            goog.object.every = function (a, b, c) {
                for (var d in a) {
                    if (!b.call(c, a[d], d, a)) return !1;
                }return !0;
            };
            goog.object.getCount = function (a) {
                var b = 0,
                    c;
                for (c in a) {
                    b++;
                }return b;
            };
            goog.object.getAnyKey = function (a) {
                for (var b in a) {
                    return b;
                }
            };
            goog.object.getAnyValue = function (a) {
                for (var b in a) {
                    return a[b];
                }
            };
            goog.object.contains = function (a, b) {
                return goog.object.containsValue(a, b);
            };
            goog.object.getValues = function (a) {
                var b = [],
                    c = 0,
                    d;
                for (d in a) {
                    b[c++] = a[d];
                }return b;
            };
            goog.object.getKeys = function (a) {
                var b = [],
                    c = 0,
                    d;
                for (d in a) {
                    b[c++] = d;
                }return b;
            };
            goog.object.getValueByKeys = function (a, b) {
                for (var c = goog.isArrayLike(b), d = c ? b : arguments, c = c ? 0 : 1; c < d.length && (a = a[d[c]], goog.isDef(a)); c++) {}
                return a;
            };
            goog.object.containsKey = function (a, b) {
                return null !== a && b in a;
            };
            goog.object.containsValue = function (a, b) {
                for (var c in a) {
                    if (a[c] == b) return !0;
                }return !1;
            };
            goog.object.findKey = function (a, b, c) {
                for (var d in a) {
                    if (b.call(c, a[d], d, a)) return d;
                }
            };
            goog.object.findValue = function (a, b, c) {
                return (b = goog.object.findKey(a, b, c)) && a[b];
            };
            goog.object.isEmpty = function (a) {
                for (var b in a) {
                    return !1;
                }return !0;
            };
            goog.object.clear = function (a) {
                for (var b in a) {
                    delete a[b];
                }
            };
            goog.object.remove = function (a, b) {
                var c;
                (c = b in a) && delete a[b];
                return c;
            };
            goog.object.add = function (a, b, c) {
                if (null !== a && b in a) throw Error('The object already contains the key "' + b + '"');
                goog.object.set(a, b, c);
            };
            goog.object.get = function (a, b, c) {
                return null !== a && b in a ? a[b] : c;
            };
            goog.object.set = function (a, b, c) {
                a[b] = c;
            };
            goog.object.setIfUndefined = function (a, b, c) {
                return b in a ? a[b] : a[b] = c;
            };
            goog.object.setWithReturnValueIfNotSet = function (a, b, c) {
                if (b in a) return a[b];
                c = c();
                return a[b] = c;
            };
            goog.object.equals = function (a, b) {
                for (var c in a) {
                    if (!(c in b) || a[c] !== b[c]) return !1;
                }for (c in b) {
                    if (!(c in a)) return !1;
                }return !0;
            };
            goog.object.clone = function (a) {
                var b = {},
                    c;
                for (c in a) {
                    b[c] = a[c];
                }return b;
            };
            goog.object.unsafeClone = function (a) {
                var b = goog.typeOf(a);
                if ("object" == b || "array" == b) {
                    if (goog.isFunction(a.clone)) return a.clone();
                    var b = "array" == b ? [] : {},
                        c;
                    for (c in a) {
                        b[c] = goog.object.unsafeClone(a[c]);
                    }return b;
                }
                return a;
            };
            goog.object.transpose = function (a) {
                var b = {},
                    c;
                for (c in a) {
                    b[a[c]] = c;
                }return b;
            };
            goog.object.PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
            goog.object.extend = function (a, b) {
                for (var c, d, e = 1; e < arguments.length; e++) {
                    d = arguments[e];
                    for (c in d) {
                        a[c] = d[c];
                    }for (var f = 0; f < goog.object.PROTOTYPE_FIELDS_.length; f++) {
                        c = goog.object.PROTOTYPE_FIELDS_[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
                    }
                }
            };
            goog.object.create = function (a) {
                var b = arguments.length;
                if (1 == b && goog.isArray(arguments[0])) return goog.object.create.apply(null, arguments[0]);
                if (b % 2) throw Error("Uneven number of arguments");
                for (var c = {}, d = 0; d < b; d += 2) {
                    c[arguments[d]] = arguments[d + 1];
                }return c;
            };
            goog.object.createSet = function (a) {
                var b = arguments.length;
                if (1 == b && goog.isArray(arguments[0])) return goog.object.createSet.apply(null, arguments[0]);
                for (var c = {}, d = 0; d < b; d++) {
                    c[arguments[d]] = !0;
                }return c;
            };
            goog.object.createImmutableView = function (a) {
                var b = a;
                Object.isFrozen && !Object.isFrozen(a) && (b = Object.create(a), Object.freeze(b));
                return b;
            };
            goog.object.isImmutableView = function (a) {
                return !!Object.isFrozen && Object.isFrozen(a);
            };
            goog.labs.userAgent.browser = {};
            goog.labs.userAgent.browser.matchOpera_ = function () {
                return goog.labs.userAgent.util.matchUserAgent("Opera") || goog.labs.userAgent.util.matchUserAgent("OPR");
            };
            goog.labs.userAgent.browser.matchIE_ = function () {
                return goog.labs.userAgent.util.matchUserAgent("Trident") || goog.labs.userAgent.util.matchUserAgent("MSIE");
            };
            goog.labs.userAgent.browser.matchEdge_ = function () {
                return goog.labs.userAgent.util.matchUserAgent("Edge");
            };
            goog.labs.userAgent.browser.matchFirefox_ = function () {
                return goog.labs.userAgent.util.matchUserAgent("Firefox");
            };
            goog.labs.userAgent.browser.matchSafari_ = function () {
                return goog.labs.userAgent.util.matchUserAgent("Safari") && !(goog.labs.userAgent.browser.matchChrome_() || goog.labs.userAgent.browser.matchCoast_() || goog.labs.userAgent.browser.matchOpera_() || goog.labs.userAgent.browser.matchEdge_() || goog.labs.userAgent.browser.isSilk() || goog.labs.userAgent.util.matchUserAgent("Android"));
            };
            goog.labs.userAgent.browser.matchCoast_ = function () {
                return goog.labs.userAgent.util.matchUserAgent("Coast");
            };
            goog.labs.userAgent.browser.matchIosWebview_ = function () {
                return (goog.labs.userAgent.util.matchUserAgent("iPad") || goog.labs.userAgent.util.matchUserAgent("iPhone")) && !goog.labs.userAgent.browser.matchSafari_() && !goog.labs.userAgent.browser.matchChrome_() && !goog.labs.userAgent.browser.matchCoast_() && goog.labs.userAgent.util.matchUserAgent("AppleWebKit");
            };
            goog.labs.userAgent.browser.matchChrome_ = function () {
                return (goog.labs.userAgent.util.matchUserAgent("Chrome") || goog.labs.userAgent.util.matchUserAgent("CriOS")) && !goog.labs.userAgent.browser.matchOpera_() && !goog.labs.userAgent.browser.matchEdge_();
            };
            goog.labs.userAgent.browser.matchAndroidBrowser_ = function () {
                return goog.labs.userAgent.util.matchUserAgent("Android") && !(goog.labs.userAgent.browser.isChrome() || goog.labs.userAgent.browser.isFirefox() || goog.labs.userAgent.browser.isOpera() || goog.labs.userAgent.browser.isSilk());
            };
            goog.labs.userAgent.browser.isOpera = goog.labs.userAgent.browser.matchOpera_;
            goog.labs.userAgent.browser.isIE = goog.labs.userAgent.browser.matchIE_;
            goog.labs.userAgent.browser.isEdge = goog.labs.userAgent.browser.matchEdge_;
            goog.labs.userAgent.browser.isFirefox = goog.labs.userAgent.browser.matchFirefox_;
            goog.labs.userAgent.browser.isSafari = goog.labs.userAgent.browser.matchSafari_;
            goog.labs.userAgent.browser.isCoast = goog.labs.userAgent.browser.matchCoast_;
            goog.labs.userAgent.browser.isIosWebview = goog.labs.userAgent.browser.matchIosWebview_;
            goog.labs.userAgent.browser.isChrome = goog.labs.userAgent.browser.matchChrome_;
            goog.labs.userAgent.browser.isAndroidBrowser = goog.labs.userAgent.browser.matchAndroidBrowser_;
            goog.labs.userAgent.browser.isSilk = function () {
                return goog.labs.userAgent.util.matchUserAgent("Silk");
            };
            goog.labs.userAgent.browser.getVersion = function () {
                function a(a) {
                    a = goog.array.find(a, d);
                    return c[a] || "";
                }

                var b = goog.labs.userAgent.util.getUserAgent();
                if (goog.labs.userAgent.browser.isIE()) return goog.labs.userAgent.browser.getIEVersion_(b);
                var b = goog.labs.userAgent.util.extractVersionTuples(b),
                    c = {};
                goog.array.forEach(b, function (a) {
                    c[a[0]] = a[1];
                });
                var d = goog.partial(goog.object.containsKey, c);
                return goog.labs.userAgent.browser.isOpera() ? a(["Version", "Opera", "OPR"]) : goog.labs.userAgent.browser.isEdge() ? a(["Edge"]) : goog.labs.userAgent.browser.isChrome() ? a(["Chrome", "CriOS"]) : (b = b[2]) && b[1] || "";
            };
            goog.labs.userAgent.browser.isVersionOrHigher = function (a) {
                return 0 <= goog.string.compareVersions(goog.labs.userAgent.browser.getVersion(), a);
            };
            goog.labs.userAgent.browser.getIEVersion_ = function (a) {
                var b = /rv: *([\d\.]*)/.exec(a);
                if (b && b[1]) return b[1];
                var b = "",
                    c = /MSIE +([\d\.]+)/.exec(a);
                if (c && c[1]) if (a = /Trident\/(\d.\d)/.exec(a), "7.0" == c[1]) {
                    if (a && a[1]) switch (a[1]) {
                        case "4.0":
                            b = "8.0";
                            break;
                        case "5.0":
                            b = "9.0";
                            break;
                        case "6.0":
                            b = "10.0";
                            break;
                        case "7.0":
                            b = "11.0";
                    } else b = "7.0";
                } else b = c[1];
                return b;
            };
            goog.labs.userAgent.engine = {};
            goog.labs.userAgent.engine.isPresto = function () {
                return goog.labs.userAgent.util.matchUserAgent("Presto");
            };
            goog.labs.userAgent.engine.isTrident = function () {
                return goog.labs.userAgent.util.matchUserAgent("Trident") || goog.labs.userAgent.util.matchUserAgent("MSIE");
            };
            goog.labs.userAgent.engine.isEdge = function () {
                return goog.labs.userAgent.util.matchUserAgent("Edge");
            };
            goog.labs.userAgent.engine.isWebKit = function () {
                return goog.labs.userAgent.util.matchUserAgentIgnoreCase("WebKit") && !goog.labs.userAgent.engine.isEdge();
            };
            goog.labs.userAgent.engine.isGecko = function () {
                return goog.labs.userAgent.util.matchUserAgent("Gecko") && !goog.labs.userAgent.engine.isWebKit() && !goog.labs.userAgent.engine.isTrident() && !goog.labs.userAgent.engine.isEdge();
            };
            goog.labs.userAgent.engine.getVersion = function () {
                var a = goog.labs.userAgent.util.getUserAgent();
                if (a) {
                    var a = goog.labs.userAgent.util.extractVersionTuples(a),
                        b = goog.labs.userAgent.engine.getEngineTuple_(a);
                    if (b) return "Gecko" == b[0] ? goog.labs.userAgent.engine.getVersionForKey_(a, "Firefox") : b[1];
                    var a = a[0],
                        c;
                    if (a && (c = a[2]) && (c = /Trident\/([^\s;]+)/.exec(c))) return c[1];
                }
                return "";
            };
            goog.labs.userAgent.engine.getEngineTuple_ = function (a) {
                if (!goog.labs.userAgent.engine.isEdge()) return a[1];
                for (var b = 0; b < a.length; b++) {
                    var c = a[b];
                    if ("Edge" == c[0]) return c;
                }
            };
            goog.labs.userAgent.engine.isVersionOrHigher = function (a) {
                return 0 <= goog.string.compareVersions(goog.labs.userAgent.engine.getVersion(), a);
            };
            goog.labs.userAgent.engine.getVersionForKey_ = function (a, b) {
                var c = goog.array.find(a, function (a) {
                    return b == a[0];
                });
                return c && c[1] || "";
            };
            goog.userAgent = {};
            goog.userAgent.ASSUME_IE = !1;
            goog.userAgent.ASSUME_EDGE = !1;
            goog.userAgent.ASSUME_GECKO = !1;
            goog.userAgent.ASSUME_WEBKIT = !1;
            goog.userAgent.ASSUME_MOBILE_WEBKIT = !1;
            goog.userAgent.ASSUME_OPERA = !1;
            goog.userAgent.ASSUME_ANY_VERSION = !1;
            goog.userAgent.BROWSER_KNOWN_ = goog.userAgent.ASSUME_IE || goog.userAgent.ASSUME_EDGE || goog.userAgent.ASSUME_GECKO || goog.userAgent.ASSUME_MOBILE_WEBKIT || goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_OPERA;
            goog.userAgent.getUserAgentString = function () {
                return goog.labs.userAgent.util.getUserAgent();
            };
            goog.userAgent.getNavigator = function () {
                return goog.global.navigator || null;
            };
            goog.userAgent.OPERA = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_OPERA : goog.labs.userAgent.browser.isOpera();
            goog.userAgent.IE = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_IE : goog.labs.userAgent.browser.isIE();
            goog.userAgent.EDGE = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_EDGE : goog.labs.userAgent.engine.isEdge();
            goog.userAgent.EDGE_OR_IE = goog.userAgent.EDGE || goog.userAgent.IE;
            goog.userAgent.GECKO = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_GECKO : goog.labs.userAgent.engine.isGecko();
            goog.userAgent.WEBKIT = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_MOBILE_WEBKIT : goog.labs.userAgent.engine.isWebKit();
            goog.userAgent.isMobile_ = function () {
                return goog.userAgent.WEBKIT && goog.labs.userAgent.util.matchUserAgent("Mobile");
            };
            goog.userAgent.MOBILE = goog.userAgent.ASSUME_MOBILE_WEBKIT || goog.userAgent.isMobile_();
            goog.userAgent.SAFARI = goog.userAgent.WEBKIT;
            goog.userAgent.determinePlatform_ = function () {
                var a = goog.userAgent.getNavigator();
                return a && a.platform || "";
            };
            goog.userAgent.PLATFORM = goog.userAgent.determinePlatform_();
            goog.userAgent.ASSUME_MAC = !1;
            goog.userAgent.ASSUME_WINDOWS = !1;
            goog.userAgent.ASSUME_LINUX = !1;
            goog.userAgent.ASSUME_X11 = !1;
            goog.userAgent.ASSUME_ANDROID = !1;
            goog.userAgent.ASSUME_IPHONE = !1;
            goog.userAgent.ASSUME_IPAD = !1;
            goog.userAgent.PLATFORM_KNOWN_ = goog.userAgent.ASSUME_MAC || goog.userAgent.ASSUME_WINDOWS || goog.userAgent.ASSUME_LINUX || goog.userAgent.ASSUME_X11 || goog.userAgent.ASSUME_ANDROID || goog.userAgent.ASSUME_IPHONE || goog.userAgent.ASSUME_IPAD;
            goog.userAgent.MAC = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_MAC : goog.labs.userAgent.platform.isMacintosh();
            goog.userAgent.WINDOWS = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_WINDOWS : goog.labs.userAgent.platform.isWindows();
            goog.userAgent.isLegacyLinux_ = function () {
                return goog.labs.userAgent.platform.isLinux() || goog.labs.userAgent.platform.isChromeOS();
            };
            goog.userAgent.LINUX = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_LINUX : goog.userAgent.isLegacyLinux_();
            goog.userAgent.isX11_ = function () {
                var a = goog.userAgent.getNavigator();
                return !!a && goog.string.contains(a.appVersion || "", "X11");
            };
            goog.userAgent.X11 = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_X11 : goog.userAgent.isX11_();
            goog.userAgent.ANDROID = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_ANDROID : goog.labs.userAgent.platform.isAndroid();
            goog.userAgent.IPHONE = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPHONE : goog.labs.userAgent.platform.isIphone();
            goog.userAgent.IPAD = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPAD : goog.labs.userAgent.platform.isIpad();
            goog.userAgent.operaVersion_ = function () {
                var a = goog.global.opera.version;
                try {
                    return a();
                } catch (b) {
                    return a;
                }
            };
            goog.userAgent.determineVersion_ = function () {
                if (goog.userAgent.OPERA && goog.global.opera) return goog.userAgent.operaVersion_();
                var a = "",
                    b = goog.userAgent.getVersionRegexResult_();
                b && (a = b ? b[1] : "");
                return goog.userAgent.IE && (b = goog.userAgent.getDocumentMode_(), b > parseFloat(a)) ? String(b) : a;
            };
            goog.userAgent.getVersionRegexResult_ = function () {
                var a = goog.userAgent.getUserAgentString();
                if (goog.userAgent.GECKO) return (/rv\:([^\);]+)(\)|;)/.exec(a)
                );
                if (goog.userAgent.EDGE) return (/Edge\/([\d\.]+)/.exec(a)
                );
                if (goog.userAgent.IE) return (/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a)
                );
                if (goog.userAgent.WEBKIT) return (/WebKit\/(\S+)/.exec(a)
                );
            };
            goog.userAgent.getDocumentMode_ = function () {
                var a = goog.global.document;
                return a ? a.documentMode : void 0;
            };
            goog.userAgent.VERSION = goog.userAgent.determineVersion_();
            goog.userAgent.compare = function (a, b) {
                return goog.string.compareVersions(a, b);
            };
            goog.userAgent.isVersionOrHigherCache_ = {};
            goog.userAgent.isVersionOrHigher = function (a) {
                return goog.userAgent.ASSUME_ANY_VERSION || goog.userAgent.isVersionOrHigherCache_[a] || (goog.userAgent.isVersionOrHigherCache_[a] = 0 <= goog.string.compareVersions(goog.userAgent.VERSION, a));
            };
            goog.userAgent.isVersion = goog.userAgent.isVersionOrHigher;
            goog.userAgent.isDocumentModeOrHigher = function (a) {
                return Number(goog.userAgent.DOCUMENT_MODE) >= a;
            };
            goog.userAgent.isDocumentMode = goog.userAgent.isDocumentModeOrHigher;
            goog.userAgent.DOCUMENT_MODE = function () {
                var a = goog.global.document,
                    b = goog.userAgent.getDocumentMode_();
                return a && goog.userAgent.IE ? b || ("CSS1Compat" == a.compatMode ? parseInt(goog.userAgent.VERSION, 10) : 5) : void 0;
            }();
            goog.userAgent.product = {};
            goog.userAgent.product.ASSUME_FIREFOX = !1;
            goog.userAgent.product.ASSUME_IPHONE = !1;
            goog.userAgent.product.ASSUME_IPAD = !1;
            goog.userAgent.product.ASSUME_ANDROID = !1;
            goog.userAgent.product.ASSUME_CHROME = !1;
            goog.userAgent.product.ASSUME_SAFARI = !1;
            goog.userAgent.product.PRODUCT_KNOWN_ = goog.userAgent.ASSUME_IE || goog.userAgent.ASSUME_EDGE || goog.userAgent.ASSUME_OPERA || goog.userAgent.product.ASSUME_FIREFOX || goog.userAgent.product.ASSUME_IPHONE || goog.userAgent.product.ASSUME_IPAD || goog.userAgent.product.ASSUME_ANDROID || goog.userAgent.product.ASSUME_CHROME || goog.userAgent.product.ASSUME_SAFARI;
            goog.userAgent.product.OPERA = goog.userAgent.OPERA;
            goog.userAgent.product.IE = goog.userAgent.IE;
            goog.userAgent.product.EDGE = goog.userAgent.EDGE;
            goog.userAgent.product.FIREFOX = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_FIREFOX : goog.labs.userAgent.browser.isFirefox();
            goog.userAgent.product.isIphoneOrIpod_ = function () {
                return goog.labs.userAgent.platform.isIphone() || goog.labs.userAgent.platform.isIpod();
            };
            goog.userAgent.product.IPHONE = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_IPHONE : goog.userAgent.product.isIphoneOrIpod_();
            goog.userAgent.product.IPAD = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_IPAD : goog.labs.userAgent.platform.isIpad();
            goog.userAgent.product.ANDROID = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_ANDROID : goog.labs.userAgent.browser.isAndroidBrowser();
            goog.userAgent.product.CHROME = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_CHROME : goog.labs.userAgent.browser.isChrome();
            goog.userAgent.product.isSafariDesktop_ = function () {
                return goog.labs.userAgent.browser.isSafari() && !goog.labs.userAgent.platform.isIos();
            };
            goog.userAgent.product.SAFARI = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_SAFARI : goog.userAgent.product.isSafariDesktop_();
            goog.crypt.base64 = {};
            goog.crypt.base64.byteToCharMap_ = null;
            goog.crypt.base64.charToByteMap_ = null;
            goog.crypt.base64.byteToCharMapWebSafe_ = null;
            goog.crypt.base64.ENCODED_VALS_BASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
            goog.crypt.base64.ENCODED_VALS = goog.crypt.base64.ENCODED_VALS_BASE + "+/=";
            goog.crypt.base64.ENCODED_VALS_WEBSAFE = goog.crypt.base64.ENCODED_VALS_BASE + "-_.";
            goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ = goog.userAgent.GECKO || goog.userAgent.WEBKIT && !goog.userAgent.product.SAFARI || goog.userAgent.OPERA;
            goog.crypt.base64.HAS_NATIVE_ENCODE_ = goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ || "function" == typeof goog.global.btoa;
            goog.crypt.base64.HAS_NATIVE_DECODE_ = goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ || !goog.userAgent.product.SAFARI && !goog.userAgent.IE && "function" == typeof goog.global.atob;
            goog.crypt.base64.encodeByteArray = function (a, b) {
                goog.asserts.assert(goog.isArrayLike(a), "encodeByteArray takes an array as a parameter");
                goog.crypt.base64.init_();
                for (var c = b ? goog.crypt.base64.byteToCharMapWebSafe_ : goog.crypt.base64.byteToCharMap_, d = [], e = 0; e < a.length; e += 3) {
                    var f = a[e],
                        g = e + 1 < a.length,
                        h = g ? a[e + 1] : 0,
                        k = e + 2 < a.length,
                        l = k ? a[e + 2] : 0,
                        p = f >> 2,
                        f = (f & 3) << 4 | h >> 4,
                        h = (h & 15) << 2 | l >> 6,
                        l = l & 63;
                    k || (l = 64, g || (h = 64));
                    d.push(c[p], c[f], c[h], c[l]);
                }
                return d.join("");
            };
            goog.crypt.base64.encodeString = function (a, b) {
                return goog.crypt.base64.HAS_NATIVE_ENCODE_ && !b ? goog.global.btoa(a) : goog.crypt.base64.encodeByteArray(goog.crypt.stringToByteArray(a), b);
            };
            goog.crypt.base64.decodeString = function (a, b) {
                if (goog.crypt.base64.HAS_NATIVE_DECODE_ && !b) return goog.global.atob(a);
                var c = "";
                goog.crypt.base64.decodeStringInternal_(a, function (a) {
                    c += String.fromCharCode(a);
                });
                return c;
            };
            goog.crypt.base64.decodeStringToByteArray = function (a, b) {
                var c = [];
                goog.crypt.base64.decodeStringInternal_(a, function (a) {
                    c.push(a);
                });
                return c;
            };
            goog.crypt.base64.decodeStringToUint8Array = function (a) {
                goog.asserts.assert(!goog.userAgent.IE || goog.userAgent.isVersionOrHigher("10"), "Browser does not support typed arrays");
                var b = new Uint8Array(Math.ceil(3 * a.length / 4)),
                    c = 0;
                goog.crypt.base64.decodeStringInternal_(a, function (a) {
                    b[c++] = a;
                });
                return b.subarray(0, c);
            };
            goog.crypt.base64.decodeStringInternal_ = function (a, b) {
                function c(b) {
                    for (; d < a.length;) {
                        var c = a.charAt(d++),
                            e = goog.crypt.base64.charToByteMap_[c];
                        if (null != e) return e;
                        if (!goog.string.isEmptyOrWhitespace(c)) throw Error("Unknown base64 encoding at char: " + c);
                    }
                    return b;
                }

                goog.crypt.base64.init_();
                for (var d = 0;;) {
                    var e = c(-1),
                        f = c(0),
                        g = c(64),
                        h = c(64);
                    if (64 === h && -1 === e) break;
                    b(e << 2 | f >> 4);
                    64 != g && (b(f << 4 & 240 | g >> 2), 64 != h && b(g << 6 & 192 | h));
                }
            };
            goog.crypt.base64.init_ = function () {
                if (!goog.crypt.base64.byteToCharMap_) {
                    goog.crypt.base64.byteToCharMap_ = {};
                    goog.crypt.base64.charToByteMap_ = {};
                    goog.crypt.base64.byteToCharMapWebSafe_ = {};
                    for (var a = 0; a < goog.crypt.base64.ENCODED_VALS.length; a++) {
                        goog.crypt.base64.byteToCharMap_[a] = goog.crypt.base64.ENCODED_VALS.charAt(a), goog.crypt.base64.charToByteMap_[goog.crypt.base64.byteToCharMap_[a]] = a, goog.crypt.base64.byteToCharMapWebSafe_[a] = goog.crypt.base64.ENCODED_VALS_WEBSAFE.charAt(a), a >= goog.crypt.base64.ENCODED_VALS_BASE.length && (goog.crypt.base64.charToByteMap_[goog.crypt.base64.ENCODED_VALS_WEBSAFE.charAt(a)] = a);
                    }
                }
            };
            jspb.ExtensionFieldInfo = function (a, b, c, d, e) {
                this.fieldIndex = a;
                this.fieldName = b;
                this.ctor = c;
                this.toObjectFn = d;
                this.isRepeated = e;
            };
            jspb.ExtensionFieldBinaryInfo = function (a, b, c, d, e, f) {
                this.fieldInfo = a;
                this.binaryReaderFn = b;
                this.binaryWriterFn = c;
                this.binaryMessageSerializeFn = d;
                this.binaryMessageDeserializeFn = e;
                this.isPacked = f;
            };
            jspb.ExtensionFieldInfo.prototype.isMessageType = function () {
                return !!this.ctor;
            };
            jspb.Message = function () {};
            jspb.Message.GENERATE_TO_OBJECT = !0;
            jspb.Message.GENERATE_FROM_OBJECT = !goog.DISALLOW_TEST_ONLY_CODE;
            jspb.Message.GENERATE_TO_STRING = !0;
            jspb.Message.ASSUME_LOCAL_ARRAYS = !1;
            jspb.Message.MINIMIZE_MEMORY_ALLOCATIONS = COMPILED;
            jspb.Message.SUPPORTS_UINT8ARRAY_ = "function" == typeof Uint8Array;
            jspb.Message.prototype.getJsPbMessageId = function () {
                return this.messageId_;
            };
            jspb.Message.getIndex_ = function (a, b) {
                return b + a.arrayIndexOffset_;
            };
            jspb.Message.initialize = function (a, b, c, d, e, f) {
                a.wrappers_ = jspb.Message.MINIMIZE_MEMORY_ALLOCATIONS ? null : {};
                b || (b = c ? [c] : []);
                a.messageId_ = c ? String(c) : void 0;
                a.arrayIndexOffset_ = 0 === c ? -1 : 0;
                a.array = b;
                jspb.Message.initPivotAndExtensionObject_(a, d);
                a.convertedFloatingPointFields_ = {};
                if (e) for (b = 0; b < e.length; b++) {
                    c = e[b], c < a.pivot_ ? (c = jspb.Message.getIndex_(a, c), a.array[c] = a.array[c] || (jspb.Message.MINIMIZE_MEMORY_ALLOCATIONS ? jspb.Message.EMPTY_LIST_SENTINEL_ : [])) : (jspb.Message.maybeInitEmptyExtensionObject_(a), a.extensionObject_[c] = a.extensionObject_[c] || (jspb.Message.MINIMIZE_MEMORY_ALLOCATIONS ? jspb.Message.EMPTY_LIST_SENTINEL_ : []));
                }f && f.length && goog.array.forEach(f, goog.partial(jspb.Message.computeOneofCase, a));
            };
            jspb.Message.EMPTY_LIST_SENTINEL_ = goog.DEBUG && Object.freeze ? Object.freeze([]) : [];
            jspb.Message.isArray_ = function (a) {
                return jspb.Message.ASSUME_LOCAL_ARRAYS ? a instanceof Array : goog.isArray(a);
            };
            jspb.Message.initPivotAndExtensionObject_ = function (a, b) {
                if (a.array.length) {
                    var c = a.array.length - 1,
                        d = a.array[c];
                    if (d && "object" == (typeof d === "undefined" ? "undefined" : _typeof(d)) && !jspb.Message.isArray_(d) && !(jspb.Message.SUPPORTS_UINT8ARRAY_ && d instanceof Uint8Array)) {
                        a.pivot_ = c - a.arrayIndexOffset_;
                        a.extensionObject_ = d;
                        return;
                    }
                }
                -1 < b ? (a.pivot_ = b, a.extensionObject_ = null) : a.pivot_ = Number.MAX_VALUE;
            };
            jspb.Message.maybeInitEmptyExtensionObject_ = function (a) {
                var b = jspb.Message.getIndex_(a, a.pivot_);
                a.array[b] || (a.extensionObject_ = a.array[b] = {});
            };
            jspb.Message.toObjectList = function (a, b, c) {
                for (var d = [], e = 0; e < a.length; e++) {
                    d[e] = b.call(a[e], c, a[e]);
                }return d;
            };
            jspb.Message.toObjectExtension = function (a, b, c, d, e) {
                for (var f in c) {
                    var g = c[f],
                        h = d.call(a, g);
                    if (null != h) {
                        for (var k in g.fieldName) {
                            if (g.fieldName.hasOwnProperty(k)) break;
                        }b[k] = g.toObjectFn ? g.isRepeated ? jspb.Message.toObjectList(h, g.toObjectFn, e) : g.toObjectFn(e, h) : h;
                    }
                }
            };
            jspb.Message.serializeBinaryExtensions = function (a, b, c, d) {
                for (var e in c) {
                    var f = c[e],
                        g = f.fieldInfo;
                    if (!f.binaryWriterFn) throw Error("Message extension present that was generated without binary serialization support");
                    var h = d.call(a, g);
                    if (null != h) if (g.isMessageType()) {
                        if (f.binaryMessageSerializeFn) f.binaryWriterFn.call(b, g.fieldIndex, h, f.binaryMessageSerializeFn);else throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
                    } else f.binaryWriterFn.call(b, g.fieldIndex, h);
                }
            };
            jspb.Message.readBinaryExtension = function (a, b, c, d, e) {
                var f = c[b.getFieldNumber()];
                if (f) {
                    c = f.fieldInfo;
                    if (!f.binaryReaderFn) throw Error("Deserializing extension whose generated code does not support binary format");
                    var g;
                    c.isMessageType() ? (g = new c.ctor(), f.binaryReaderFn.call(b, g, f.binaryMessageDeserializeFn)) : g = f.binaryReaderFn.call(b);
                    c.isRepeated && !f.isPacked ? (b = d.call(a, c)) ? b.push(g) : e.call(a, c, [g]) : e.call(a, c, g);
                } else b.skipField();
            };
            jspb.Message.getField = function (a, b) {
                if (b < a.pivot_) {
                    var c = jspb.Message.getIndex_(a, b),
                        d = a.array[c];
                    return d === jspb.Message.EMPTY_LIST_SENTINEL_ ? a.array[c] = [] : d;
                }
                if (a.extensionObject_) return d = a.extensionObject_[b], d === jspb.Message.EMPTY_LIST_SENTINEL_ ? a.extensionObject_[b] = [] : d;
            };
            jspb.Message.getRepeatedField = function (a, b) {
                if (b < a.pivot_) {
                    var c = jspb.Message.getIndex_(a, b),
                        d = a.array[c];
                    return d === jspb.Message.EMPTY_LIST_SENTINEL_ ? a.array[c] = [] : d;
                }
                d = a.extensionObject_[b];
                return d === jspb.Message.EMPTY_LIST_SENTINEL_ ? a.extensionObject_[b] = [] : d;
            };
            jspb.Message.getOptionalFloatingPointField = function (a, b) {
                var c = jspb.Message.getField(a, b);
                return null == c ? c : +c;
            };
            jspb.Message.getRepeatedFloatingPointField = function (a, b) {
                var c = jspb.Message.getRepeatedField(a, b);
                a.convertedFloatingPointFields_ || (a.convertedFloatingPointFields_ = {});
                if (!a.convertedFloatingPointFields_[b]) {
                    for (var d = 0; d < c.length; d++) {
                        c[d] = +c[d];
                    }a.convertedFloatingPointFields_[b] = !0;
                }
                return c;
            };
            jspb.Message.bytesAsB64 = function (a) {
                if (null == a || goog.isString(a)) return a;
                if (jspb.Message.SUPPORTS_UINT8ARRAY_ && a instanceof Uint8Array) return goog.crypt.base64.encodeByteArray(a);
                goog.asserts.fail("Cannot coerce to b64 string: " + goog.typeOf(a));
                return null;
            };
            jspb.Message.bytesAsU8 = function (a) {
                if (null == a || a instanceof Uint8Array) return a;
                if (goog.isString(a)) return goog.crypt.base64.decodeStringToUint8Array(a);
                goog.asserts.fail("Cannot coerce to Uint8Array: " + goog.typeOf(a));
                return null;
            };
            jspb.Message.bytesListAsB64 = function (a) {
                jspb.Message.assertConsistentTypes_(a);
                return !a.length || goog.isString(a[0]) ? a : goog.array.map(a, jspb.Message.bytesAsB64);
            };
            jspb.Message.bytesListAsU8 = function (a) {
                jspb.Message.assertConsistentTypes_(a);
                return !a.length || a[0] instanceof Uint8Array ? a : goog.array.map(a, jspb.Message.bytesAsU8);
            };
            jspb.Message.assertConsistentTypes_ = function (a) {
                if (goog.DEBUG && a && 1 < a.length) {
                    var b = goog.typeOf(a[0]);
                    goog.array.forEach(a, function (a) {
                        goog.typeOf(a) != b && goog.asserts.fail("Inconsistent type in JSPB repeated field array. Got " + goog.typeOf(a) + " expected " + b);
                    });
                }
            };
            jspb.Message.getFieldWithDefault = function (a, b, c) {
                a = jspb.Message.getField(a, b);
                return null == a ? c : a;
            };
            jspb.Message.getFieldProto3 = jspb.Message.getFieldWithDefault;
            jspb.Message.getMapField = function (a, b, c, d) {
                a.wrappers_ || (a.wrappers_ = {});
                if (b in a.wrappers_) return a.wrappers_[b];
                if (!c) return c = jspb.Message.getField(a, b), c || (c = [], jspb.Message.setField(a, b, c)), a.wrappers_[b] = new jspb.Map(c, d);
            };
            jspb.Message.setField = function (a, b, c) {
                b < a.pivot_ ? a.array[jspb.Message.getIndex_(a, b)] = c : (jspb.Message.maybeInitEmptyExtensionObject_(a), a.extensionObject_[b] = c);
            };
            jspb.Message.setProto3IntField = function (a, b, c) {
                jspb.Message.setFieldIgnoringDefault_(a, b, c, 0);
            };
            jspb.Message.setProto3FloatField = function (a, b, c) {
                jspb.Message.setFieldIgnoringDefault_(a, b, c, 0);
            };
            jspb.Message.setProto3BooleanField = function (a, b, c) {
                jspb.Message.setFieldIgnoringDefault_(a, b, c, !1);
            };
            jspb.Message.setProto3StringField = function (a, b, c) {
                jspb.Message.setFieldIgnoringDefault_(a, b, c, "");
            };
            jspb.Message.setProto3StringIntField = function (a, b, c) {
                jspb.Message.setFieldIgnoringDefault_(a, b, c, "");
            };
            jspb.Message.setProto3BytesField = function (a, b, c) {
                jspb.Message.setFieldIgnoringDefault_(a, b, c, "");
            };
            jspb.Message.setProto3EnumField = function (a, b, c) {
                jspb.Message.setFieldIgnoringDefault_(a, b, c, 0);
            };
            jspb.Message.setFieldIgnoringDefault_ = function (a, b, c, d) {
                c != d ? jspb.Message.setField(a, b, c) : a.array[jspb.Message.getIndex_(a, b)] = null;
            };
            jspb.Message.addToRepeatedField = function (a, b, c, d) {
                a = jspb.Message.getRepeatedField(a, b);
                void 0 != d ? a.splice(d, 0, c) : a.push(c);
            };
            jspb.Message.setOneofField = function (a, b, c, d) {
                (c = jspb.Message.computeOneofCase(a, c)) && c !== b && void 0 !== d && (a.wrappers_ && c in a.wrappers_ && (a.wrappers_[c] = void 0), jspb.Message.setField(a, c, void 0));
                jspb.Message.setField(a, b, d);
            };
            jspb.Message.computeOneofCase = function (a, b) {
                var c, d;
                goog.array.forEach(b, function (b) {
                    var f = jspb.Message.getField(a, b);
                    goog.isDefAndNotNull(f) && (c = b, d = f, jspb.Message.setField(a, b, void 0));
                });
                return c ? (jspb.Message.setField(a, c, d), c) : 0;
            };
            jspb.Message.getWrapperField = function (a, b, c, d) {
                a.wrappers_ || (a.wrappers_ = {});
                if (!a.wrappers_[c]) {
                    var e = jspb.Message.getField(a, c);
                    if (d || e) a.wrappers_[c] = new b(e);
                }
                return a.wrappers_[c];
            };
            jspb.Message.getRepeatedWrapperField = function (a, b, c) {
                jspb.Message.wrapRepeatedField_(a, b, c);
                b = a.wrappers_[c];
                b == jspb.Message.EMPTY_LIST_SENTINEL_ && (b = a.wrappers_[c] = []);
                return b;
            };
            jspb.Message.wrapRepeatedField_ = function (a, b, c) {
                a.wrappers_ || (a.wrappers_ = {});
                if (!a.wrappers_[c]) {
                    for (var d = jspb.Message.getRepeatedField(a, c), e = [], f = 0; f < d.length; f++) {
                        e[f] = new b(d[f]);
                    }a.wrappers_[c] = e;
                }
            };
            jspb.Message.setWrapperField = function (a, b, c) {
                a.wrappers_ || (a.wrappers_ = {});
                var d = c ? c.toArray() : c;
                a.wrappers_[b] = c;
                jspb.Message.setField(a, b, d);
            };
            jspb.Message.setOneofWrapperField = function (a, b, c, d) {
                a.wrappers_ || (a.wrappers_ = {});
                var e = d ? d.toArray() : d;
                a.wrappers_[b] = d;
                jspb.Message.setOneofField(a, b, c, e);
            };
            jspb.Message.setRepeatedWrapperField = function (a, b, c) {
                a.wrappers_ || (a.wrappers_ = {});
                c = c || [];
                for (var d = [], e = 0; e < c.length; e++) {
                    d[e] = c[e].toArray();
                }a.wrappers_[b] = c;
                jspb.Message.setField(a, b, d);
            };
            jspb.Message.addToRepeatedWrapperField = function (a, b, c, d, e) {
                jspb.Message.wrapRepeatedField_(a, d, b);
                var f = a.wrappers_[b];
                f || (f = a.wrappers_[b] = []);
                c = c ? c : new d();
                a = jspb.Message.getRepeatedField(a, b);
                void 0 != e ? (f.splice(e, 0, c), a.splice(e, 0, c.toArray())) : (f.push(c), a.push(c.toArray()));
                return c;
            };
            jspb.Message.toMap = function (a, b, c, d) {
                for (var e = {}, f = 0; f < a.length; f++) {
                    e[b.call(a[f])] = c ? c.call(a[f], d, a[f]) : a[f];
                }return e;
            };
            jspb.Message.prototype.syncMapFields_ = function () {
                if (this.wrappers_) for (var a in this.wrappers_) {
                    var b = this.wrappers_[a];
                    if (goog.isArray(b)) for (var c = 0; c < b.length; c++) {
                        b[c] && b[c].toArray();
                    } else b && b.toArray();
                }
            };
            jspb.Message.prototype.toArray = function () {
                this.syncMapFields_();
                return this.array;
            };
            jspb.Message.GENERATE_TO_STRING && (jspb.Message.prototype.toString = function () {
                this.syncMapFields_();
                return this.array.toString();
            });
            jspb.Message.prototype.getExtension = function (a) {
                if (this.extensionObject_) {
                    this.wrappers_ || (this.wrappers_ = {});
                    var b = a.fieldIndex;
                    if (a.isRepeated) {
                        if (a.isMessageType()) return this.wrappers_[b] || (this.wrappers_[b] = goog.array.map(this.extensionObject_[b] || [], function (b) {
                            return new a.ctor(b);
                        })), this.wrappers_[b];
                    } else if (a.isMessageType()) return !this.wrappers_[b] && this.extensionObject_[b] && (this.wrappers_[b] = new a.ctor(this.extensionObject_[b])), this.wrappers_[b];
                    return this.extensionObject_[b];
                }
            };
            jspb.Message.prototype.setExtension = function (a, b) {
                this.wrappers_ || (this.wrappers_ = {});
                jspb.Message.maybeInitEmptyExtensionObject_(this);
                var c = a.fieldIndex;
                a.isRepeated ? (b = b || [], a.isMessageType() ? (this.wrappers_[c] = b, this.extensionObject_[c] = goog.array.map(b, function (a) {
                    return a.toArray();
                })) : this.extensionObject_[c] = b) : a.isMessageType() ? (this.wrappers_[c] = b, this.extensionObject_[c] = b ? b.toArray() : b) : this.extensionObject_[c] = b;
                return this;
            };
            jspb.Message.difference = function (a, b) {
                if (!(a instanceof b.constructor)) throw Error("Messages have different types.");
                var c = a.toArray(),
                    d = b.toArray(),
                    e = [],
                    f = 0,
                    g = c.length > d.length ? c.length : d.length;
                a.getJsPbMessageId() && (e[0] = a.getJsPbMessageId(), f = 1);
                for (; f < g; f++) {
                    jspb.Message.compareFields(c[f], d[f]) || (e[f] = d[f]);
                }return new a.constructor(e);
            };
            jspb.Message.equals = function (a, b) {
                return a == b || !(!a || !b) && a instanceof b.constructor && jspb.Message.compareFields(a.toArray(), b.toArray());
            };
            jspb.Message.compareExtensions = function (a, b) {
                a = a || {};
                b = b || {};
                var c = {},
                    d;
                for (d in a) {
                    c[d] = 0;
                }for (d in b) {
                    c[d] = 0;
                }for (d in c) {
                    if (!jspb.Message.compareFields(a[d], b[d])) return !1;
                }return !0;
            };
            jspb.Message.compareFields = function (a, b) {
                if (a == b) return !0;
                if (!goog.isObject(a) || !goog.isObject(b) || a.constructor != b.constructor) return !1;
                if (jspb.Message.SUPPORTS_UINT8ARRAY_ && a.constructor === Uint8Array) {
                    if (a.length != b.length) return !1;
                    for (var c = 0; c < a.length; c++) {
                        if (a[c] != b[c]) return !1;
                    }return !0;
                }
                if (a.constructor === Array) {
                    for (var d = void 0, e = void 0, f = Math.max(a.length, b.length), c = 0; c < f; c++) {
                        var g = a[c],
                            h = b[c];
                        g && g.constructor == Object && (goog.asserts.assert(void 0 === d), goog.asserts.assert(c === a.length - 1), d = g, g = void 0);
                        h && h.constructor == Object && (goog.asserts.assert(void 0 === e), goog.asserts.assert(c === b.length - 1), e = h, h = void 0);
                        if (!jspb.Message.compareFields(g, h)) return !1;
                    }
                    return d || e ? (d = d || {}, e = e || {}, jspb.Message.compareExtensions(d, e)) : !0;
                }
                if (a.constructor === Object) return jspb.Message.compareExtensions(a, b);
                throw Error("Invalid type in JSPB array");
            };
            jspb.Message.prototype.cloneMessage = function () {
                return jspb.Message.cloneMessage(this);
            };
            jspb.Message.prototype.clone = function () {
                return jspb.Message.cloneMessage(this);
            };
            jspb.Message.clone = function (a) {
                return jspb.Message.cloneMessage(a);
            };
            jspb.Message.cloneMessage = function (a) {
                return new a.constructor(jspb.Message.clone_(a.toArray()));
            };
            jspb.Message.copyInto = function (a, b) {
                goog.asserts.assertInstanceof(a, jspb.Message);
                goog.asserts.assertInstanceof(b, jspb.Message);
                goog.asserts.assert(a.constructor == b.constructor, "Copy source and target message should have the same type.");
                for (var c = jspb.Message.clone(a), d = b.toArray(), e = c.toArray(), f = d.length = 0; f < e.length; f++) {
                    d[f] = e[f];
                }b.wrappers_ = c.wrappers_;
                b.extensionObject_ = c.extensionObject_;
            };
            jspb.Message.clone_ = function (a) {
                var b;
                if (goog.isArray(a)) {
                    for (var c = Array(a.length), d = 0; d < a.length; d++) {
                        null != (b = a[d]) && (c[d] = "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) ? jspb.Message.clone_(b) : b);
                    }return c;
                }
                if (jspb.Message.SUPPORTS_UINT8ARRAY_ && a instanceof Uint8Array) return new Uint8Array(a);
                c = {};
                for (d in a) {
                    null != (b = a[d]) && (c[d] = "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) ? jspb.Message.clone_(b) : b);
                }return c;
            };
            jspb.Message.registerMessageType = function (a, b) {
                jspb.Message.registry_[a] = b;
                b.messageId = a;
            };
            jspb.Message.registry_ = {};
            jspb.Message.messageSetExtensions = {};
            jspb.Message.messageSetExtensionsBinary = {};
            jspb.arith = {};
            jspb.arith.UInt64 = function (a, b) {
                this.lo = a;
                this.hi = b;
            };
            jspb.arith.UInt64.prototype.cmp = function (a) {
                return this.hi < a.hi || this.hi == a.hi && this.lo < a.lo ? -1 : this.hi == a.hi && this.lo == a.lo ? 0 : 1;
            };
            jspb.arith.UInt64.prototype.rightShift = function () {
                return new jspb.arith.UInt64((this.lo >>> 1 | (this.hi & 1) << 31) >>> 0, this.hi >>> 1 >>> 0);
            };
            jspb.arith.UInt64.prototype.leftShift = function () {
                return new jspb.arith.UInt64(this.lo << 1 >>> 0, (this.hi << 1 | this.lo >>> 31) >>> 0);
            };
            jspb.arith.UInt64.prototype.msb = function () {
                return !!(this.hi & 2147483648);
            };
            jspb.arith.UInt64.prototype.lsb = function () {
                return !!(this.lo & 1);
            };
            jspb.arith.UInt64.prototype.zero = function () {
                return 0 == this.lo && 0 == this.hi;
            };
            jspb.arith.UInt64.prototype.add = function (a) {
                return new jspb.arith.UInt64((this.lo + a.lo & 4294967295) >>> 0 >>> 0, ((this.hi + a.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + a.lo ? 1 : 0) >>> 0);
            };
            jspb.arith.UInt64.prototype.sub = function (a) {
                return new jspb.arith.UInt64((this.lo - a.lo & 4294967295) >>> 0 >>> 0, ((this.hi - a.hi & 4294967295) >>> 0) - (0 > this.lo - a.lo ? 1 : 0) >>> 0);
            };
            jspb.arith.UInt64.mul32x32 = function (a, b) {
                for (var c = a & 65535, d = a >>> 16, e = b & 65535, f = b >>> 16, g = c * e + 65536 * (c * f & 65535) + 65536 * (d * e & 65535), c = d * f + (c * f >>> 16) + (d * e >>> 16); 4294967296 <= g;) {
                    g -= 4294967296, c += 1;
                }return new jspb.arith.UInt64(g >>> 0, c >>> 0);
            };
            jspb.arith.UInt64.prototype.mul = function (a) {
                var b = jspb.arith.UInt64.mul32x32(this.lo, a);
                a = jspb.arith.UInt64.mul32x32(this.hi, a);
                a.hi = a.lo;
                a.lo = 0;
                return b.add(a);
            };
            jspb.arith.UInt64.prototype.div = function (a) {
                if (0 == a) return [];
                var b = new jspb.arith.UInt64(0, 0),
                    c = new jspb.arith.UInt64(this.lo, this.hi);
                a = new jspb.arith.UInt64(a, 0);
                for (var d = new jspb.arith.UInt64(1, 0); !a.msb();) {
                    a = a.leftShift(), d = d.leftShift();
                }for (; !d.zero();) {
                    0 >= a.cmp(c) && (b = b.add(d), c = c.sub(a)), a = a.rightShift(), d = d.rightShift();
                }return [b, c];
            };
            jspb.arith.UInt64.prototype.toString = function () {
                for (var a = "", b = this; !b.zero();) {
                    var b = b.div(10),
                        c = b[0],
                        a = b[1].lo + a,
                        b = c;
                }"" == a && (a = "0");
                return a;
            };
            jspb.arith.UInt64.fromString = function (a) {
                for (var b = new jspb.arith.UInt64(0, 0), c = new jspb.arith.UInt64(0, 0), d = 0; d < a.length; d++) {
                    if ("0" > a[d] || "9" < a[d]) return null;
                    var e = parseInt(a[d], 10);
                    c.lo = e;
                    b = b.mul(10).add(c);
                }
                return b;
            };
            jspb.arith.UInt64.prototype.clone = function () {
                return new jspb.arith.UInt64(this.lo, this.hi);
            };
            jspb.arith.Int64 = function (a, b) {
                this.lo = a;
                this.hi = b;
            };
            jspb.arith.Int64.prototype.add = function (a) {
                return new jspb.arith.Int64((this.lo + a.lo & 4294967295) >>> 0 >>> 0, ((this.hi + a.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + a.lo ? 1 : 0) >>> 0);
            };
            jspb.arith.Int64.prototype.sub = function (a) {
                return new jspb.arith.Int64((this.lo - a.lo & 4294967295) >>> 0 >>> 0, ((this.hi - a.hi & 4294967295) >>> 0) - (0 > this.lo - a.lo ? 1 : 0) >>> 0);
            };
            jspb.arith.Int64.prototype.clone = function () {
                return new jspb.arith.Int64(this.lo, this.hi);
            };
            jspb.arith.Int64.prototype.toString = function () {
                var a = 0 != (this.hi & 2147483648),
                    b = new jspb.arith.UInt64(this.lo, this.hi);
                a && (b = new jspb.arith.UInt64(0, 0).sub(b));
                return (a ? "-" : "") + b.toString();
            };
            jspb.arith.Int64.fromString = function (a) {
                var b = 0 < a.length && "-" == a[0];
                b && (a = a.substring(1));
                a = jspb.arith.UInt64.fromString(a);
                if (null === a) return null;
                b && (a = new jspb.arith.UInt64(0, 0).sub(a));
                return new jspb.arith.Int64(a.lo, a.hi);
            };
            jspb.BinaryConstants = {};
            jspb.ConstBinaryMessage = function () {};
            jspb.BinaryMessage = function () {};
            jspb.BinaryConstants.FieldType = {
                INVALID: -1,
                DOUBLE: 1,
                FLOAT: 2,
                INT64: 3,
                UINT64: 4,
                INT32: 5,
                FIXED64: 6,
                FIXED32: 7,
                BOOL: 8,
                STRING: 9,
                GROUP: 10,
                MESSAGE: 11,
                BYTES: 12,
                UINT32: 13,
                ENUM: 14,
                SFIXED32: 15,
                SFIXED64: 16,
                SINT32: 17,
                SINT64: 18,
                FHASH64: 30,
                VHASH64: 31
            };
            jspb.BinaryConstants.WireType = {
                INVALID: -1,
                VARINT: 0,
                FIXED64: 1,
                DELIMITED: 2,
                START_GROUP: 3,
                END_GROUP: 4,
                FIXED32: 5
            };
            jspb.BinaryConstants.FieldTypeToWireType = function (a) {
                var b = jspb.BinaryConstants.FieldType,
                    c = jspb.BinaryConstants.WireType;
                switch (a) {
                    case b.INT32:
                    case b.INT64:
                    case b.UINT32:
                    case b.UINT64:
                    case b.SINT32:
                    case b.SINT64:
                    case b.BOOL:
                    case b.ENUM:
                    case b.VHASH64:
                        return c.VARINT;
                    case b.DOUBLE:
                    case b.FIXED64:
                    case b.SFIXED64:
                    case b.FHASH64:
                        return c.FIXED64;
                    case b.STRING:
                    case b.MESSAGE:
                    case b.BYTES:
                        return c.DELIMITED;
                    case b.FLOAT:
                    case b.FIXED32:
                    case b.SFIXED32:
                        return c.FIXED32;
                    default:
                        return c.INVALID;
                }
            };
            jspb.BinaryConstants.INVALID_FIELD_NUMBER = -1;
            jspb.BinaryConstants.FLOAT32_EPS = 1.401298464324817E-45;
            jspb.BinaryConstants.FLOAT32_MIN = 1.1754943508222875E-38;
            jspb.BinaryConstants.FLOAT32_MAX = 3.4028234663852886E38;
            jspb.BinaryConstants.FLOAT64_EPS = 4.9E-324;
            jspb.BinaryConstants.FLOAT64_MIN = 2.2250738585072014E-308;
            jspb.BinaryConstants.FLOAT64_MAX = 1.7976931348623157E308;
            jspb.BinaryConstants.TWO_TO_20 = 1048576;
            jspb.BinaryConstants.TWO_TO_23 = 8388608;
            jspb.BinaryConstants.TWO_TO_31 = 2147483648;
            jspb.BinaryConstants.TWO_TO_32 = 4294967296;
            jspb.BinaryConstants.TWO_TO_52 = 4503599627370496;
            jspb.BinaryConstants.TWO_TO_63 = 0x7fffffffffffffff;
            jspb.BinaryConstants.TWO_TO_64 = 1.8446744073709552E19;
            jspb.BinaryConstants.ZERO_HASH = "\x00\x00\x00\x00\x00\x00\x00\x00";
            jspb.utils = {};
            jspb.utils.split64Low = 0;
            jspb.utils.split64High = 0;
            jspb.utils.splitUint64 = function (a) {
                var b = a >>> 0;
                a = Math.floor((a - b) / jspb.BinaryConstants.TWO_TO_32) >>> 0;
                jspb.utils.split64Low = b;
                jspb.utils.split64High = a;
            };
            jspb.utils.splitInt64 = function (a) {
                var b = 0 > a;
                a = Math.abs(a);
                var c = a >>> 0;
                a = Math.floor((a - c) / jspb.BinaryConstants.TWO_TO_32);
                a >>>= 0;
                b && (a = ~a >>> 0, c = (~c >>> 0) + 1, 4294967295 < c && (c = 0, a++, 4294967295 < a && (a = 0)));
                jspb.utils.split64Low = c;
                jspb.utils.split64High = a;
            };
            jspb.utils.splitZigzag64 = function (a) {
                var b = 0 > a;
                a = 2 * Math.abs(a);
                jspb.utils.splitUint64(a);
                a = jspb.utils.split64Low;
                var c = jspb.utils.split64High;
                b && (0 == a ? 0 == c ? c = a = 4294967295 : (c--, a = 4294967295) : a--);
                jspb.utils.split64Low = a;
                jspb.utils.split64High = c;
            };
            jspb.utils.splitFloat32 = function (a) {
                var b = 0 > a ? 1 : 0;
                a = b ? -a : a;
                var c;
                0 === a ? 0 < 1 / a ? (jspb.utils.split64High = 0, jspb.utils.split64Low = 0) : (jspb.utils.split64High = 0, jspb.utils.split64Low = 2147483648) : isNaN(a) ? (jspb.utils.split64High = 0, jspb.utils.split64Low = 2147483647) : a > jspb.BinaryConstants.FLOAT32_MAX ? (jspb.utils.split64High = 0, jspb.utils.split64Low = (b << 31 | 2139095040) >>> 0) : a < jspb.BinaryConstants.FLOAT32_MIN ? (a = Math.round(a / Math.pow(2, -149)), jspb.utils.split64High = 0, jspb.utils.split64Low = (b << 31 | a) >>> 0) : (c = Math.floor(Math.log(a) / Math.LN2), a *= Math.pow(2, -c), a = Math.round(a * jspb.BinaryConstants.TWO_TO_23) & 8388607, jspb.utils.split64High = 0, jspb.utils.split64Low = (b << 31 | c + 127 << 23 | a) >>> 0);
            };
            jspb.utils.splitFloat64 = function (a) {
                var b = 0 > a ? 1 : 0;
                a = b ? -a : a;
                if (0 === a) jspb.utils.split64High = 0 < 1 / a ? 0 : 2147483648, jspb.utils.split64Low = 0;else if (isNaN(a)) jspb.utils.split64High = 2147483647, jspb.utils.split64Low = 4294967295;else if (a > jspb.BinaryConstants.FLOAT64_MAX) jspb.utils.split64High = (b << 31 | 2146435072) >>> 0, jspb.utils.split64Low = 0;else if (a < jspb.BinaryConstants.FLOAT64_MIN) {
                    var c = a / Math.pow(2, -1074);
                    a = c / jspb.BinaryConstants.TWO_TO_32;
                    jspb.utils.split64High = (b << 31 | a) >>> 0;
                    jspb.utils.split64Low = c >>> 0;
                } else {
                    var d = Math.floor(Math.log(a) / Math.LN2);
                    1024 == d && (d = 1023);
                    c = a * Math.pow(2, -d);
                    a = c * jspb.BinaryConstants.TWO_TO_20 & 1048575;
                    c = c * jspb.BinaryConstants.TWO_TO_52 >>> 0;
                    jspb.utils.split64High = (b << 31 | d + 1023 << 20 | a) >>> 0;
                    jspb.utils.split64Low = c;
                }
            };
            jspb.utils.splitHash64 = function (a) {
                var b = a.charCodeAt(0),
                    c = a.charCodeAt(1),
                    d = a.charCodeAt(2),
                    e = a.charCodeAt(3),
                    f = a.charCodeAt(4),
                    g = a.charCodeAt(5),
                    h = a.charCodeAt(6);
                a = a.charCodeAt(7);
                jspb.utils.split64Low = b + (c << 8) + (d << 16) + (e << 24) >>> 0;
                jspb.utils.split64High = f + (g << 8) + (h << 16) + (a << 24) >>> 0;
            };
            jspb.utils.joinUint64 = function (a, b) {
                return b * jspb.BinaryConstants.TWO_TO_32 + a;
            };
            jspb.utils.joinInt64 = function (a, b) {
                var c = b & 2147483648;
                c && (a = ~a + 1 >>> 0, b = ~b >>> 0, 0 == a && (b = b + 1 >>> 0));
                var d = jspb.utils.joinUint64(a, b);
                return c ? -d : d;
            };
            jspb.utils.joinZigzag64 = function (a, b) {
                var c = a & 1;
                a = (a >>> 1 | b << 31) >>> 0;
                b >>>= 1;
                c && (a = a + 1 >>> 0, 0 == a && (b = b + 1 >>> 0));
                var d = jspb.utils.joinUint64(a, b);
                return c ? -d : d;
            };
            jspb.utils.joinFloat32 = function (a, b) {
                var c = 2 * (a >> 31) + 1,
                    d = a >>> 23 & 255,
                    e = a & 8388607;
                return 255 == d ? e ? NaN : Infinity * c : 0 == d ? c * Math.pow(2, -149) * e : c * Math.pow(2, d - 150) * (e + Math.pow(2, 23));
            };
            jspb.utils.joinFloat64 = function (a, b) {
                var c = 2 * (b >> 31) + 1,
                    d = b >>> 20 & 2047,
                    e = jspb.BinaryConstants.TWO_TO_32 * (b & 1048575) + a;
                return 2047 == d ? e ? NaN : Infinity * c : 0 == d ? c * Math.pow(2, -1074) * e : c * Math.pow(2, d - 1075) * (e + jspb.BinaryConstants.TWO_TO_52);
            };
            jspb.utils.joinHash64 = function (a, b) {
                return String.fromCharCode(a >>> 0 & 255, a >>> 8 & 255, a >>> 16 & 255, a >>> 24 & 255, b >>> 0 & 255, b >>> 8 & 255, b >>> 16 & 255, b >>> 24 & 255);
            };
            jspb.utils.DIGITS = "0123456789abcdef".split("");
            jspb.utils.joinUnsignedDecimalString = function (a, b) {
                function c(a) {
                    for (var b = 1E7, c = 0; 7 > c; c++) {
                        var b = b / 10,
                            d = a / b % 10 >>> 0;
                        if (0 != d || h) h = !0, k += g[d];
                    }
                }

                if (2097151 >= b) return "" + (jspb.BinaryConstants.TWO_TO_32 * b + a);
                var d = (a >>> 24 | b << 8) >>> 0 & 16777215,
                    e = b >> 16 & 65535,
                    f = (a & 16777215) + 6777216 * d + 6710656 * e,
                    d = d + 8147497 * e,
                    e = 2 * e;
                1E7 <= f && (d += Math.floor(f / 1E7), f %= 1E7);
                1E7 <= d && (e += Math.floor(d / 1E7), d %= 1E7);
                var g = jspb.utils.DIGITS,
                    h = !1,
                    k = "";
                (e || h) && c(e);
                (d || h) && c(d);
                (f || h) && c(f);
                return k;
            };
            jspb.utils.joinSignedDecimalString = function (a, b) {
                var c = b & 2147483648;
                c && (a = ~a + 1 >>> 0, b = ~b + (0 == a ? 1 : 0) >>> 0);
                var d = jspb.utils.joinUnsignedDecimalString(a, b);
                return c ? "-" + d : d;
            };
            jspb.utils.hash64ToDecimalString = function (a, b) {
                jspb.utils.splitHash64(a);
                var c = jspb.utils.split64Low,
                    d = jspb.utils.split64High;
                return b ? jspb.utils.joinSignedDecimalString(c, d) : jspb.utils.joinUnsignedDecimalString(c, d);
            };
            jspb.utils.hash64ArrayToDecimalStrings = function (a, b) {
                for (var c = Array(a.length), d = 0; d < a.length; d++) {
                    c[d] = jspb.utils.hash64ToDecimalString(a[d], b);
                }return c;
            };
            jspb.utils.decimalStringToHash64 = function (a) {
                function b(a, b) {
                    for (var c = 0; 8 > c && (1 !== a || 0 < b); c++) {
                        var d = a * e[c] + b;
                        e[c] = d & 255;
                        b = d >>> 8;
                    }
                }

                function c() {
                    for (var a = 0; 8 > a; a++) {
                        e[a] = ~e[a] & 255;
                    }
                }

                goog.asserts.assert(0 < a.length);
                var d = !1;
                "-" === a[0] && (d = !0, a = a.slice(1));
                for (var e = [0, 0, 0, 0, 0, 0, 0, 0], f = 0; f < a.length; f++) {
                    b(10, jspb.utils.DIGITS.indexOf(a[f]));
                }d && (c(), b(1, 1));
                return goog.crypt.byteArrayToString(e);
            };
            jspb.utils.splitDecimalString = function (a) {
                jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(a));
            };
            jspb.utils.hash64ToHexString = function (a) {
                var b = Array(18);
                b[0] = "0";
                b[1] = "x";
                for (var c = 0; 8 > c; c++) {
                    var d = a.charCodeAt(7 - c);
                    b[2 * c + 2] = jspb.utils.DIGITS[d >> 4];
                    b[2 * c + 3] = jspb.utils.DIGITS[d & 15];
                }
                return b.join("");
            };
            jspb.utils.hexStringToHash64 = function (a) {
                a = a.toLowerCase();
                goog.asserts.assert(18 == a.length);
                goog.asserts.assert("0" == a[0]);
                goog.asserts.assert("x" == a[1]);
                for (var b = "", c = 0; 8 > c; c++) {
                    var d = jspb.utils.DIGITS.indexOf(a[2 * c + 2]),
                        e = jspb.utils.DIGITS.indexOf(a[2 * c + 3]),
                        b = String.fromCharCode(16 * d + e) + b;
                }return b;
            };
            jspb.utils.hash64ToNumber = function (a, b) {
                jspb.utils.splitHash64(a);
                var c = jspb.utils.split64Low,
                    d = jspb.utils.split64High;
                return b ? jspb.utils.joinInt64(c, d) : jspb.utils.joinUint64(c, d);
            };
            jspb.utils.numberToHash64 = function (a) {
                jspb.utils.splitInt64(a);
                return jspb.utils.joinHash64(jspb.utils.split64Low, jspb.utils.split64High);
            };
            jspb.utils.countVarints = function (a, b, c) {
                for (var d = 0, e = b; e < c; e++) {
                    d += a[e] >> 7;
                }return c - b - d;
            };
            jspb.utils.countVarintFields = function (a, b, c, d) {
                var e = 0;
                d = 8 * d + jspb.BinaryConstants.WireType.VARINT;
                if (128 > d) for (; b < c && a[b++] == d;) {
                    for (e++;;) {
                        var f = a[b++];
                        if (0 == (f & 128)) break;
                    }
                } else for (; b < c;) {
                    for (f = d; 128 < f;) {
                        if (a[b] != (f & 127 | 128)) return e;
                        b++;
                        f >>= 7;
                    }
                    if (a[b++] != f) break;
                    for (e++; f = a[b++], 0 != (f & 128);) {}
                }
                return e;
            };
            jspb.utils.countFixedFields_ = function (a, b, c, d, e) {
                var f = 0;
                if (128 > d) for (; b < c && a[b++] == d;) {
                    f++, b += e;
                } else for (; b < c;) {
                    for (var g = d; 128 < g;) {
                        if (a[b++] != (g & 127 | 128)) return f;
                        g >>= 7;
                    }
                    if (a[b++] != g) break;
                    f++;
                    b += e;
                }
                return f;
            };
            jspb.utils.countFixed32Fields = function (a, b, c, d) {
                return jspb.utils.countFixedFields_(a, b, c, 8 * d + jspb.BinaryConstants.WireType.FIXED32, 4);
            };
            jspb.utils.countFixed64Fields = function (a, b, c, d) {
                return jspb.utils.countFixedFields_(a, b, c, 8 * d + jspb.BinaryConstants.WireType.FIXED64, 8);
            };
            jspb.utils.countDelimitedFields = function (a, b, c, d) {
                var e = 0;
                for (d = 8 * d + jspb.BinaryConstants.WireType.DELIMITED; b < c;) {
                    for (var f = d; 128 < f;) {
                        if (a[b++] != (f & 127 | 128)) return e;
                        f >>= 7;
                    }
                    if (a[b++] != f) break;
                    e++;
                    for (var g = 0, h = 1; f = a[b++], g += (f & 127) * h, h *= 128, 0 != (f & 128);) {}
                    b += g;
                }
                return e;
            };
            jspb.utils.debugBytesToTextFormat = function (a) {
                var b = '"';
                if (a) {
                    a = jspb.utils.byteSourceToUint8Array(a);
                    for (var c = 0; c < a.length; c++) {
                        b += "\\x", 16 > a[c] && (b += "0"), b += a[c].toString(16);
                    }
                }
                return b + '"';
            };
            jspb.utils.debugScalarToTextFormat = function (a) {
                return goog.isString(a) ? goog.string.quote(a) : a.toString();
            };
            jspb.utils.stringToByteArray = function (a) {
                for (var b = new Uint8Array(a.length), c = 0; c < a.length; c++) {
                    var d = a.charCodeAt(c);
                    if (255 < d) throw Error("Conversion error: string contains codepoint outside of byte range");
                    b[c] = d;
                }
                return b;
            };
            jspb.utils.byteSourceToUint8Array = function (a) {
                if (a.constructor === Uint8Array) return a;
                if (a.constructor === ArrayBuffer || a.constructor === Array) return new Uint8Array(a);
                if (a.constructor === String) return goog.crypt.base64.decodeStringToUint8Array(a);
                goog.asserts.fail("Type not convertible to Uint8Array.");
                return new Uint8Array(0);
            };
            jspb.BinaryEncoder = function () {
                this.buffer_ = [];
            };
            jspb.BinaryEncoder.prototype.length = function () {
                return this.buffer_.length;
            };
            jspb.BinaryEncoder.prototype.end = function () {
                var a = this.buffer_;
                this.buffer_ = [];
                return a;
            };
            jspb.BinaryEncoder.prototype.writeSplitVarint64 = function (a, b) {
                goog.asserts.assert(a == Math.floor(a));
                goog.asserts.assert(b == Math.floor(b));
                goog.asserts.assert(0 <= a && a < jspb.BinaryConstants.TWO_TO_32);
                for (goog.asserts.assert(0 <= b && b < jspb.BinaryConstants.TWO_TO_32); 0 < b || 127 < a;) {
                    this.buffer_.push(a & 127 | 128), a = (a >>> 7 | b << 25) >>> 0, b >>>= 7;
                }this.buffer_.push(a);
            };
            jspb.BinaryEncoder.prototype.writeSplitFixed64 = function (a, b) {
                goog.asserts.assert(a == Math.floor(a));
                goog.asserts.assert(b == Math.floor(b));
                goog.asserts.assert(0 <= a && a < jspb.BinaryConstants.TWO_TO_32);
                goog.asserts.assert(0 <= b && b < jspb.BinaryConstants.TWO_TO_32);
                this.writeUint32(a);
                this.writeUint32(b);
            };
            jspb.BinaryEncoder.prototype.writeUnsignedVarint32 = function (a) {
                goog.asserts.assert(a == Math.floor(a));
                for (goog.asserts.assert(0 <= a && a < jspb.BinaryConstants.TWO_TO_32); 127 < a;) {
                    this.buffer_.push(a & 127 | 128), a >>>= 7;
                }this.buffer_.push(a);
            };
            jspb.BinaryEncoder.prototype.writeSignedVarint32 = function (a) {
                goog.asserts.assert(a == Math.floor(a));
                goog.asserts.assert(a >= -jspb.BinaryConstants.TWO_TO_31 && a < jspb.BinaryConstants.TWO_TO_31);
                if (0 <= a) this.writeUnsignedVarint32(a);else {
                    for (var b = 0; 9 > b; b++) {
                        this.buffer_.push(a & 127 | 128), a >>= 7;
                    }this.buffer_.push(1);
                }
            };
            jspb.BinaryEncoder.prototype.writeUnsignedVarint64 = function (a) {
                goog.asserts.assert(a == Math.floor(a));
                goog.asserts.assert(0 <= a && a < jspb.BinaryConstants.TWO_TO_64);
                jspb.utils.splitInt64(a);
                this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
            };
            jspb.BinaryEncoder.prototype.writeSignedVarint64 = function (a) {
                goog.asserts.assert(a == Math.floor(a));
                goog.asserts.assert(a >= -jspb.BinaryConstants.TWO_TO_63 && a < jspb.BinaryConstants.TWO_TO_63);
                jspb.utils.splitInt64(a);
                this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
            };
            jspb.BinaryEncoder.prototype.writeZigzagVarint32 = function (a) {
                goog.asserts.assert(a == Math.floor(a));
                goog.asserts.assert(a >= -jspb.BinaryConstants.TWO_TO_31 && a < jspb.BinaryConstants.TWO_TO_31);
                this.writeUnsignedVarint32((a << 1 ^ a >> 31) >>> 0);
            };
            jspb.BinaryEncoder.prototype.writeZigzagVarint64 = function (a) {
                goog.asserts.assert(a == Math.floor(a));
                goog.asserts.assert(a >= -jspb.BinaryConstants.TWO_TO_63 && a < jspb.BinaryConstants.TWO_TO_63);
                jspb.utils.splitZigzag64(a);
                this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
            };
            jspb.BinaryEncoder.prototype.writeZigzagVarint64String = function (a) {
                this.writeZigzagVarint64(parseInt(a, 10));
            };
            jspb.BinaryEncoder.prototype.writeUint8 = function (a) {
                goog.asserts.assert(a == Math.floor(a));
                goog.asserts.assert(0 <= a && 256 > a);
                this.buffer_.push(a >>> 0 & 255);
            };
            jspb.BinaryEncoder.prototype.writeUint16 = function (a) {
                goog.asserts.assert(a == Math.floor(a));
                goog.asserts.assert(0 <= a && 65536 > a);
                this.buffer_.push(a >>> 0 & 255);
                this.buffer_.push(a >>> 8 & 255);
            };
            jspb.BinaryEncoder.prototype.writeUint32 = function (a) {
                goog.asserts.assert(a == Math.floor(a));
                goog.asserts.assert(0 <= a && a < jspb.BinaryConstants.TWO_TO_32);
                this.buffer_.push(a >>> 0 & 255);
                this.buffer_.push(a >>> 8 & 255);
                this.buffer_.push(a >>> 16 & 255);
                this.buffer_.push(a >>> 24 & 255);
            };
            jspb.BinaryEncoder.prototype.writeUint64 = function (a) {
                goog.asserts.assert(a == Math.floor(a));
                goog.asserts.assert(0 <= a && a < jspb.BinaryConstants.TWO_TO_64);
                jspb.utils.splitUint64(a);
                this.writeUint32(jspb.utils.split64Low);
                this.writeUint32(jspb.utils.split64High);
            };
            jspb.BinaryEncoder.prototype.writeInt8 = function (a) {
                goog.asserts.assert(a == Math.floor(a));
                goog.asserts.assert(-128 <= a && 128 > a);
                this.buffer_.push(a >>> 0 & 255);
            };
            jspb.BinaryEncoder.prototype.writeInt16 = function (a) {
                goog.asserts.assert(a == Math.floor(a));
                goog.asserts.assert(-32768 <= a && 32768 > a);
                this.buffer_.push(a >>> 0 & 255);
                this.buffer_.push(a >>> 8 & 255);
            };
            jspb.BinaryEncoder.prototype.writeInt32 = function (a) {
                goog.asserts.assert(a == Math.floor(a));
                goog.asserts.assert(a >= -jspb.BinaryConstants.TWO_TO_31 && a < jspb.BinaryConstants.TWO_TO_31);
                this.buffer_.push(a >>> 0 & 255);
                this.buffer_.push(a >>> 8 & 255);
                this.buffer_.push(a >>> 16 & 255);
                this.buffer_.push(a >>> 24 & 255);
            };
            jspb.BinaryEncoder.prototype.writeInt64 = function (a) {
                goog.asserts.assert(a == Math.floor(a));
                goog.asserts.assert(a >= -jspb.BinaryConstants.TWO_TO_63 && a < jspb.BinaryConstants.TWO_TO_63);
                jspb.utils.splitInt64(a);
                this.writeSplitFixed64(jspb.utils.split64Low, jspb.utils.split64High);
            };
            jspb.BinaryEncoder.prototype.writeInt64String = function (a) {
                goog.asserts.assert(a == Math.floor(a));
                goog.asserts.assert(+a >= -jspb.BinaryConstants.TWO_TO_63 && +a < jspb.BinaryConstants.TWO_TO_63);
                jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(a));
                this.writeSplitFixed64(jspb.utils.split64Low, jspb.utils.split64High);
            };
            jspb.BinaryEncoder.prototype.writeFloat = function (a) {
                goog.asserts.assert(a >= -jspb.BinaryConstants.FLOAT32_MAX && a <= jspb.BinaryConstants.FLOAT32_MAX);
                jspb.utils.splitFloat32(a);
                this.writeUint32(jspb.utils.split64Low);
            };
            jspb.BinaryEncoder.prototype.writeDouble = function (a) {
                goog.asserts.assert(a >= -jspb.BinaryConstants.FLOAT64_MAX && a <= jspb.BinaryConstants.FLOAT64_MAX);
                jspb.utils.splitFloat64(a);
                this.writeUint32(jspb.utils.split64Low);
                this.writeUint32(jspb.utils.split64High);
            };
            jspb.BinaryEncoder.prototype.writeBool = function (a) {
                goog.asserts.assert(goog.isBoolean(a) || goog.isNumber(a));
                this.buffer_.push(a ? 1 : 0);
            };
            jspb.BinaryEncoder.prototype.writeEnum = function (a) {
                goog.asserts.assert(a == Math.floor(a));
                goog.asserts.assert(a >= -jspb.BinaryConstants.TWO_TO_31 && a < jspb.BinaryConstants.TWO_TO_31);
                this.writeSignedVarint32(a);
            };
            jspb.BinaryEncoder.prototype.writeBytes = function (a) {
                this.buffer_.push.apply(this.buffer_, a);
            };
            jspb.BinaryEncoder.prototype.writeVarintHash64 = function (a) {
                jspb.utils.splitHash64(a);
                this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
            };
            jspb.BinaryEncoder.prototype.writeFixedHash64 = function (a) {
                jspb.utils.splitHash64(a);
                this.writeUint32(jspb.utils.split64Low);
                this.writeUint32(jspb.utils.split64High);
            };
            jspb.BinaryEncoder.prototype.writeString = function (a) {
                for (var b = this.buffer_.length, c = 0; c < a.length; c++) {
                    var d = a.charCodeAt(c);
                    if (128 > d) this.buffer_.push(d);else if (2048 > d) this.buffer_.push(d >> 6 | 192), this.buffer_.push(d & 63 | 128);else if (65536 > d) if (55296 <= d && 56319 >= d && c + 1 < a.length) {
                        var e = a.charCodeAt(c + 1);
                        56320 <= e && 57343 >= e && (d = 1024 * (d - 55296) + e - 56320 + 65536, this.buffer_.push(d >> 18 | 240), this.buffer_.push(d >> 12 & 63 | 128), this.buffer_.push(d >> 6 & 63 | 128), this.buffer_.push(d & 63 | 128), c++);
                    } else this.buffer_.push(d >> 12 | 224), this.buffer_.push(d >> 6 & 63 | 128), this.buffer_.push(d & 63 | 128);
                }
                return this.buffer_.length - b;
            };
            jspb.BinaryWriter = function () {
                this.blocks_ = [];
                this.totalLength_ = 0;
                this.encoder_ = new jspb.BinaryEncoder();
                this.bookmarks_ = [];
            };
            jspb.BinaryWriter.prototype.appendUint8Array_ = function (a) {
                var b = this.encoder_.end();
                this.blocks_.push(b);
                this.blocks_.push(a);
                this.totalLength_ += b.length + a.length;
            };
            jspb.BinaryWriter.prototype.beginDelimited_ = function (a) {
                this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.DELIMITED);
                a = this.encoder_.end();
                this.blocks_.push(a);
                this.totalLength_ += a.length;
                a.push(this.totalLength_);
                return a;
            };
            jspb.BinaryWriter.prototype.endDelimited_ = function (a) {
                var b = a.pop(),
                    b = this.totalLength_ + this.encoder_.length() - b;
                for (goog.asserts.assert(0 <= b); 127 < b;) {
                    a.push(b & 127 | 128), b >>>= 7, this.totalLength_++;
                }a.push(b);
                this.totalLength_++;
            };
            jspb.BinaryWriter.prototype.writeSerializedMessage = function (a, b, c) {
                this.appendUint8Array_(a.subarray(b, c));
            };
            jspb.BinaryWriter.prototype.maybeWriteSerializedMessage = function (a, b, c) {
                null != a && null != b && null != c && this.writeSerializedMessage(a, b, c);
            };
            jspb.BinaryWriter.prototype.reset = function () {
                this.blocks_ = [];
                this.encoder_.end();
                this.totalLength_ = 0;
                this.bookmarks_ = [];
            };
            jspb.BinaryWriter.prototype.getResultBuffer = function () {
                goog.asserts.assert(0 == this.bookmarks_.length);
                for (var a = new Uint8Array(this.totalLength_ + this.encoder_.length()), b = this.blocks_, c = b.length, d = 0, e = 0; e < c; e++) {
                    var f = b[e];
                    a.set(f, d);
                    d += f.length;
                }
                b = this.encoder_.end();
                a.set(b, d);
                d += b.length;
                goog.asserts.assert(d == a.length);
                this.blocks_ = [a];
                return a;
            };
            jspb.BinaryWriter.prototype.getResultBase64String = function () {
                return goog.crypt.base64.encodeByteArray(this.getResultBuffer());
            };
            jspb.BinaryWriter.prototype.beginSubMessage = function (a) {
                this.bookmarks_.push(this.beginDelimited_(a));
            };
            jspb.BinaryWriter.prototype.endSubMessage = function () {
                goog.asserts.assert(0 <= this.bookmarks_.length);
                this.endDelimited_(this.bookmarks_.pop());
            };
            jspb.BinaryWriter.prototype.writeFieldHeader_ = function (a, b) {
                goog.asserts.assert(1 <= a && a == Math.floor(a));
                this.encoder_.writeUnsignedVarint32(8 * a + b);
            };
            jspb.BinaryWriter.prototype.writeAny = function (a, b, c) {
                var d = jspb.BinaryConstants.FieldType;
                switch (a) {
                    case d.DOUBLE:
                        this.writeDouble(b, c);
                        break;
                    case d.FLOAT:
                        this.writeFloat(b, c);
                        break;
                    case d.INT64:
                        this.writeInt64(b, c);
                        break;
                    case d.UINT64:
                        this.writeUint64(b, c);
                        break;
                    case d.INT32:
                        this.writeInt32(b, c);
                        break;
                    case d.FIXED64:
                        this.writeFixed64(b, c);
                        break;
                    case d.FIXED32:
                        this.writeFixed32(b, c);
                        break;
                    case d.BOOL:
                        this.writeBool(b, c);
                        break;
                    case d.STRING:
                        this.writeString(b, c);
                        break;
                    case d.GROUP:
                        goog.asserts.fail("Group field type not supported in writeAny()");
                        break;
                    case d.MESSAGE:
                        goog.asserts.fail("Message field type not supported in writeAny()");
                        break;
                    case d.BYTES:
                        this.writeBytes(b, c);
                        break;
                    case d.UINT32:
                        this.writeUint32(b, c);
                        break;
                    case d.ENUM:
                        this.writeEnum(b, c);
                        break;
                    case d.SFIXED32:
                        this.writeSfixed32(b, c);
                        break;
                    case d.SFIXED64:
                        this.writeSfixed64(b, c);
                        break;
                    case d.SINT32:
                        this.writeSint32(b, c);
                        break;
                    case d.SINT64:
                        this.writeSint64(b, c);
                        break;
                    case d.FHASH64:
                        this.writeFixedHash64(b, c);
                        break;
                    case d.VHASH64:
                        this.writeVarintHash64(b, c);
                        break;
                    default:
                        goog.asserts.fail("Invalid field type in writeAny()");
                }
            };
            jspb.BinaryWriter.prototype.writeUnsignedVarint32_ = function (a, b) {
                null != b && (this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeUnsignedVarint32(b));
            };
            jspb.BinaryWriter.prototype.writeSignedVarint32_ = function (a, b) {
                null != b && (this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint32(b));
            };
            jspb.BinaryWriter.prototype.writeUnsignedVarint64_ = function (a, b) {
                null != b && (this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeUnsignedVarint64(b));
            };
            jspb.BinaryWriter.prototype.writeSignedVarint64_ = function (a, b) {
                null != b && (this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint64(b));
            };
            jspb.BinaryWriter.prototype.writeZigzagVarint32_ = function (a, b) {
                null != b && (this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarint32(b));
            };
            jspb.BinaryWriter.prototype.writeZigzagVarint64_ = function (a, b) {
                null != b && (this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarint64(b));
            };
            jspb.BinaryWriter.prototype.writeZigzagVarint64String_ = function (a, b) {
                null != b && (this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarint64String(b));
            };
            jspb.BinaryWriter.prototype.writeInt32 = function (a, b) {
                null != b && (goog.asserts.assert(b >= -jspb.BinaryConstants.TWO_TO_31 && b < jspb.BinaryConstants.TWO_TO_31), this.writeSignedVarint32_(a, b));
            };
            jspb.BinaryWriter.prototype.writeInt32String = function (a, b) {
                if (null != b) {
                    var c = parseInt(b, 10);
                    goog.asserts.assert(c >= -jspb.BinaryConstants.TWO_TO_31 && c < jspb.BinaryConstants.TWO_TO_31);
                    this.writeSignedVarint32_(a, c);
                }
            };
            jspb.BinaryWriter.prototype.writeInt64 = function (a, b) {
                null != b && (goog.asserts.assert(b >= -jspb.BinaryConstants.TWO_TO_63 && b < jspb.BinaryConstants.TWO_TO_63), this.writeSignedVarint64_(a, b));
            };
            jspb.BinaryWriter.prototype.writeInt64String = function (a, b) {
                if (null != b) {
                    var c = jspb.arith.Int64.fromString(b);
                    this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.VARINT);
                    this.encoder_.writeSplitVarint64(c.lo, c.hi);
                }
            };
            jspb.BinaryWriter.prototype.writeUint32 = function (a, b) {
                null != b && (goog.asserts.assert(0 <= b && b < jspb.BinaryConstants.TWO_TO_32), this.writeUnsignedVarint32_(a, b));
            };
            jspb.BinaryWriter.prototype.writeUint32String = function (a, b) {
                if (null != b) {
                    var c = parseInt(b, 10);
                    goog.asserts.assert(0 <= c && c < jspb.BinaryConstants.TWO_TO_32);
                    this.writeUnsignedVarint32_(a, c);
                }
            };
            jspb.BinaryWriter.prototype.writeUint64 = function (a, b) {
                null != b && (goog.asserts.assert(0 <= b && b < jspb.BinaryConstants.TWO_TO_64), this.writeUnsignedVarint64_(a, b));
            };
            jspb.BinaryWriter.prototype.writeUint64String = function (a, b) {
                if (null != b) {
                    var c = jspb.arith.UInt64.fromString(b);
                    this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.VARINT);
                    this.encoder_.writeSplitVarint64(c.lo, c.hi);
                }
            };
            jspb.BinaryWriter.prototype.writeSint32 = function (a, b) {
                null != b && (goog.asserts.assert(b >= -jspb.BinaryConstants.TWO_TO_31 && b < jspb.BinaryConstants.TWO_TO_31), this.writeZigzagVarint32_(a, b));
            };
            jspb.BinaryWriter.prototype.writeSint64 = function (a, b) {
                null != b && (goog.asserts.assert(b >= -jspb.BinaryConstants.TWO_TO_63 && b < jspb.BinaryConstants.TWO_TO_63), this.writeZigzagVarint64_(a, b));
            };
            jspb.BinaryWriter.prototype.writeSint64String = function (a, b) {
                null != b && (goog.asserts.assert(+b >= -jspb.BinaryConstants.TWO_TO_63 && +b < jspb.BinaryConstants.TWO_TO_63), this.writeZigzagVarint64String_(a, b));
            };
            jspb.BinaryWriter.prototype.writeFixed32 = function (a, b) {
                null != b && (goog.asserts.assert(0 <= b && b < jspb.BinaryConstants.TWO_TO_32), this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.FIXED32), this.encoder_.writeUint32(b));
            };
            jspb.BinaryWriter.prototype.writeFixed64 = function (a, b) {
                null != b && (goog.asserts.assert(0 <= b && b < jspb.BinaryConstants.TWO_TO_64), this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeUint64(b));
            };
            jspb.BinaryWriter.prototype.writeFixed64String = function (a, b) {
                if (null != b) {
                    var c = jspb.arith.UInt64.fromString(b);
                    this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.FIXED64);
                    this.encoder_.writeSplitFixed64(c.lo, c.hi);
                }
            };
            jspb.BinaryWriter.prototype.writeSfixed32 = function (a, b) {
                null != b && (goog.asserts.assert(b >= -jspb.BinaryConstants.TWO_TO_31 && b < jspb.BinaryConstants.TWO_TO_31), this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.FIXED32), this.encoder_.writeInt32(b));
            };
            jspb.BinaryWriter.prototype.writeSfixed64 = function (a, b) {
                null != b && (goog.asserts.assert(b >= -jspb.BinaryConstants.TWO_TO_63 && b < jspb.BinaryConstants.TWO_TO_63), this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeInt64(b));
            };
            jspb.BinaryWriter.prototype.writeSfixed64String = function (a, b) {
                if (null != b) {
                    var c = jspb.arith.Int64.fromString(b);
                    this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.FIXED64);
                    this.encoder_.writeSplitFixed64(c.lo, c.hi);
                }
            };
            jspb.BinaryWriter.prototype.writeFloat = function (a, b) {
                null != b && (this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.FIXED32), this.encoder_.writeFloat(b));
            };
            jspb.BinaryWriter.prototype.writeDouble = function (a, b) {
                null != b && (this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeDouble(b));
            };
            jspb.BinaryWriter.prototype.writeBool = function (a, b) {
                null != b && (goog.asserts.assert(goog.isBoolean(b) || goog.isNumber(b)), this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeBool(b));
            };
            jspb.BinaryWriter.prototype.writeEnum = function (a, b) {
                null != b && (goog.asserts.assert(b >= -jspb.BinaryConstants.TWO_TO_31 && b < jspb.BinaryConstants.TWO_TO_31), this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint32(b));
            };
            jspb.BinaryWriter.prototype.writeString = function (a, b) {
                if (null != b) {
                    var c = this.beginDelimited_(a);
                    this.encoder_.writeString(b);
                    this.endDelimited_(c);
                }
            };
            jspb.BinaryWriter.prototype.writeBytes = function (a, b) {
                if (null != b) {
                    var c = jspb.utils.byteSourceToUint8Array(b);
                    this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.DELIMITED);
                    this.encoder_.writeUnsignedVarint32(c.length);
                    this.appendUint8Array_(c);
                }
            };
            jspb.BinaryWriter.prototype.writeMessage = function (a, b, c) {
                null != b && (a = this.beginDelimited_(a), c(b, this), this.endDelimited_(a));
            };
            jspb.BinaryWriter.prototype.writeGroup = function (a, b, c) {
                null != b && (this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.START_GROUP), c(b, this), this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.END_GROUP));
            };
            jspb.BinaryWriter.prototype.writeFixedHash64 = function (a, b) {
                null != b && (goog.asserts.assert(8 == b.length), this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeFixedHash64(b));
            };
            jspb.BinaryWriter.prototype.writeVarintHash64 = function (a, b) {
                null != b && (goog.asserts.assert(8 == b.length), this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeVarintHash64(b));
            };
            jspb.BinaryWriter.prototype.writeRepeatedInt32 = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeSignedVarint32_(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedInt32String = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeInt32String(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedInt64 = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeSignedVarint64_(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedInt64String = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeInt64String(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedUint32 = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeUnsignedVarint32_(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedUint32String = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeUint32String(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedUint64 = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeUnsignedVarint64_(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedUint64String = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeUint64String(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedSint32 = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeZigzagVarint32_(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedSint64 = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeZigzagVarint64_(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedSint64String = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeZigzagVarint64String_(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedFixed32 = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeFixed32(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedFixed64 = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeFixed64(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedFixed64String = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeFixed64String(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedSfixed32 = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeSfixed32(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedSfixed64 = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeSfixed64(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedSfixed64String = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeSfixed64String(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedFloat = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeFloat(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedDouble = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeDouble(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedBool = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeBool(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedEnum = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeEnum(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedString = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeString(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedBytes = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeBytes(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedMessage = function (a, b, c) {
                if (null != b) for (var d = 0; d < b.length; d++) {
                    var e = this.beginDelimited_(a);
                    c(b[d], this);
                    this.endDelimited_(e);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedGroup = function (a, b, c) {
                if (null != b) for (var d = 0; d < b.length; d++) {
                    this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.START_GROUP), c(b[d], this), this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.END_GROUP);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedFixedHash64 = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeFixedHash64(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writeRepeatedVarintHash64 = function (a, b) {
                if (null != b) for (var c = 0; c < b.length; c++) {
                    this.writeVarintHash64(a, b[c]);
                }
            };
            jspb.BinaryWriter.prototype.writePackedInt32 = function (a, b) {
                if (null != b && b.length) {
                    for (var c = this.beginDelimited_(a), d = 0; d < b.length; d++) {
                        this.encoder_.writeSignedVarint32(b[d]);
                    }this.endDelimited_(c);
                }
            };
            jspb.BinaryWriter.prototype.writePackedInt32String = function (a, b) {
                if (null != b && b.length) {
                    for (var c = this.beginDelimited_(a), d = 0; d < b.length; d++) {
                        this.encoder_.writeSignedVarint32(parseInt(b[d], 10));
                    }this.endDelimited_(c);
                }
            };
            jspb.BinaryWriter.prototype.writePackedInt64 = function (a, b) {
                if (null != b && b.length) {
                    for (var c = this.beginDelimited_(a), d = 0; d < b.length; d++) {
                        this.encoder_.writeSignedVarint64(b[d]);
                    }this.endDelimited_(c);
                }
            };
            jspb.BinaryWriter.prototype.writePackedInt64String = function (a, b) {
                if (null != b && b.length) {
                    for (var c = this.beginDelimited_(a), d = 0; d < b.length; d++) {
                        var e = jspb.arith.Int64.fromString(b[d]);
                        this.encoder_.writeSplitVarint64(e.lo, e.hi);
                    }
                    this.endDelimited_(c);
                }
            };
            jspb.BinaryWriter.prototype.writePackedUint32 = function (a, b) {
                if (null != b && b.length) {
                    for (var c = this.beginDelimited_(a), d = 0; d < b.length; d++) {
                        this.encoder_.writeUnsignedVarint32(b[d]);
                    }this.endDelimited_(c);
                }
            };
            jspb.BinaryWriter.prototype.writePackedUint32String = function (a, b) {
                if (null != b && b.length) {
                    for (var c = this.beginDelimited_(a), d = 0; d < b.length; d++) {
                        this.encoder_.writeUnsignedVarint32(parseInt(b[d], 10));
                    }this.endDelimited_(c);
                }
            };
            jspb.BinaryWriter.prototype.writePackedUint64 = function (a, b) {
                if (null != b && b.length) {
                    for (var c = this.beginDelimited_(a), d = 0; d < b.length; d++) {
                        this.encoder_.writeUnsignedVarint64(b[d]);
                    }this.endDelimited_(c);
                }
            };
            jspb.BinaryWriter.prototype.writePackedUint64String = function (a, b) {
                if (null != b && b.length) {
                    for (var c = this.beginDelimited_(a), d = 0; d < b.length; d++) {
                        var e = jspb.arith.UInt64.fromString(b[d]);
                        this.encoder_.writeSplitVarint64(e.lo, e.hi);
                    }
                    this.endDelimited_(c);
                }
            };
            jspb.BinaryWriter.prototype.writePackedSint32 = function (a, b) {
                if (null != b && b.length) {
                    for (var c = this.beginDelimited_(a), d = 0; d < b.length; d++) {
                        this.encoder_.writeZigzagVarint32(b[d]);
                    }this.endDelimited_(c);
                }
            };
            jspb.BinaryWriter.prototype.writePackedSint64 = function (a, b) {
                if (null != b && b.length) {
                    for (var c = this.beginDelimited_(a), d = 0; d < b.length; d++) {
                        this.encoder_.writeZigzagVarint64(b[d]);
                    }this.endDelimited_(c);
                }
            };
            jspb.BinaryWriter.prototype.writePackedSint64String = function (a, b) {
                if (null != b && b.length) {
                    for (var c = this.beginDelimited_(a), d = 0; d < b.length; d++) {
                        this.encoder_.writeZigzagVarint64(parseInt(b[d], 10));
                    }this.endDelimited_(c);
                }
            };
            jspb.BinaryWriter.prototype.writePackedFixed32 = function (a, b) {
                if (null != b && b.length) {
                    this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.DELIMITED);
                    this.encoder_.writeUnsignedVarint32(4 * b.length);
                    for (var c = 0; c < b.length; c++) {
                        this.encoder_.writeUint32(b[c]);
                    }
                }
            };
            jspb.BinaryWriter.prototype.writePackedFixed64 = function (a, b) {
                if (null != b && b.length) {
                    this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.DELIMITED);
                    this.encoder_.writeUnsignedVarint32(8 * b.length);
                    for (var c = 0; c < b.length; c++) {
                        this.encoder_.writeUint64(b[c]);
                    }
                }
            };
            jspb.BinaryWriter.prototype.writePackedFixed64String = function (a, b) {
                if (null != b && b.length) {
                    this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.DELIMITED);
                    this.encoder_.writeUnsignedVarint32(8 * b.length);
                    for (var c = 0; c < b.length; c++) {
                        var d = jspb.arith.UInt64.fromString(b[c]);
                        this.encoder_.writeSplitFixed64(d.lo, d.hi);
                    }
                }
            };
            jspb.BinaryWriter.prototype.writePackedSfixed32 = function (a, b) {
                if (null != b && b.length) {
                    this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.DELIMITED);
                    this.encoder_.writeUnsignedVarint32(4 * b.length);
                    for (var c = 0; c < b.length; c++) {
                        this.encoder_.writeInt32(b[c]);
                    }
                }
            };
            jspb.BinaryWriter.prototype.writePackedSfixed64 = function (a, b) {
                if (null != b && b.length) {
                    this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.DELIMITED);
                    this.encoder_.writeUnsignedVarint32(8 * b.length);
                    for (var c = 0; c < b.length; c++) {
                        this.encoder_.writeInt64(b[c]);
                    }
                }
            };
            jspb.BinaryWriter.prototype.writePackedSfixed64String = function (a, b) {
                if (null != b && b.length) {
                    this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.DELIMITED);
                    this.encoder_.writeUnsignedVarint32(8 * b.length);
                    for (var c = 0; c < b.length; c++) {
                        this.encoder_.writeInt64String(b[c]);
                    }
                }
            };
            jspb.BinaryWriter.prototype.writePackedFloat = function (a, b) {
                if (null != b && b.length) {
                    this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.DELIMITED);
                    this.encoder_.writeUnsignedVarint32(4 * b.length);
                    for (var c = 0; c < b.length; c++) {
                        this.encoder_.writeFloat(b[c]);
                    }
                }
            };
            jspb.BinaryWriter.prototype.writePackedDouble = function (a, b) {
                if (null != b && b.length) {
                    this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.DELIMITED);
                    this.encoder_.writeUnsignedVarint32(8 * b.length);
                    for (var c = 0; c < b.length; c++) {
                        this.encoder_.writeDouble(b[c]);
                    }
                }
            };
            jspb.BinaryWriter.prototype.writePackedBool = function (a, b) {
                if (null != b && b.length) {
                    this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.DELIMITED);
                    this.encoder_.writeUnsignedVarint32(b.length);
                    for (var c = 0; c < b.length; c++) {
                        this.encoder_.writeBool(b[c]);
                    }
                }
            };
            jspb.BinaryWriter.prototype.writePackedEnum = function (a, b) {
                if (null != b && b.length) {
                    for (var c = this.beginDelimited_(a), d = 0; d < b.length; d++) {
                        this.encoder_.writeEnum(b[d]);
                    }this.endDelimited_(c);
                }
            };
            jspb.BinaryWriter.prototype.writePackedFixedHash64 = function (a, b) {
                if (null != b && b.length) {
                    this.writeFieldHeader_(a, jspb.BinaryConstants.WireType.DELIMITED);
                    this.encoder_.writeUnsignedVarint32(8 * b.length);
                    for (var c = 0; c < b.length; c++) {
                        this.encoder_.writeFixedHash64(b[c]);
                    }
                }
            };
            jspb.BinaryWriter.prototype.writePackedVarintHash64 = function (a, b) {
                if (null != b && b.length) {
                    for (var c = this.beginDelimited_(a), d = 0; d < b.length; d++) {
                        this.encoder_.writeVarintHash64(b[d]);
                    }this.endDelimited_(c);
                }
            };
            jspb.BinaryIterator = function (a, b, c) {
                this.elements_ = this.nextMethod_ = this.decoder_ = null;
                this.cursor_ = 0;
                this.nextValue_ = null;
                this.atEnd_ = !0;
                this.init_(a, b, c);
            };
            jspb.BinaryIterator.prototype.init_ = function (a, b, c) {
                a && b && (this.decoder_ = a, this.nextMethod_ = b);
                this.elements_ = c || null;
                this.cursor_ = 0;
                this.nextValue_ = null;
                this.atEnd_ = !this.decoder_ && !this.elements_;
                this.next();
            };
            jspb.BinaryIterator.instanceCache_ = [];
            jspb.BinaryIterator.alloc = function (a, b, c) {
                if (jspb.BinaryIterator.instanceCache_.length) {
                    var d = jspb.BinaryIterator.instanceCache_.pop();
                    d.init_(a, b, c);
                    return d;
                }
                return new jspb.BinaryIterator(a, b, c);
            };
            jspb.BinaryIterator.prototype.free = function () {
                this.clear();
                100 > jspb.BinaryIterator.instanceCache_.length && jspb.BinaryIterator.instanceCache_.push(this);
            };
            jspb.BinaryIterator.prototype.clear = function () {
                this.decoder_ && this.decoder_.free();
                this.elements_ = this.nextMethod_ = this.decoder_ = null;
                this.cursor_ = 0;
                this.nextValue_ = null;
                this.atEnd_ = !0;
            };
            jspb.BinaryIterator.prototype.get = function () {
                return this.nextValue_;
            };
            jspb.BinaryIterator.prototype.atEnd = function () {
                return this.atEnd_;
            };
            jspb.BinaryIterator.prototype.next = function () {
                var a = this.nextValue_;
                this.decoder_ ? this.decoder_.atEnd() ? (this.nextValue_ = null, this.atEnd_ = !0) : this.nextValue_ = this.nextMethod_.call(this.decoder_) : this.elements_ && (this.cursor_ == this.elements_.length ? (this.nextValue_ = null, this.atEnd_ = !0) : this.nextValue_ = this.elements_[this.cursor_++]);
                return a;
            };
            jspb.BinaryDecoder = function (a, b, c) {
                this.bytes_ = null;
                this.tempHigh_ = this.tempLow_ = this.cursor_ = this.end_ = this.start_ = 0;
                this.error_ = !1;
                a && this.setBlock(a, b, c);
            };
            jspb.BinaryDecoder.instanceCache_ = [];
            jspb.BinaryDecoder.alloc = function (a, b, c) {
                if (jspb.BinaryDecoder.instanceCache_.length) {
                    var d = jspb.BinaryDecoder.instanceCache_.pop();
                    a && d.setBlock(a, b, c);
                    return d;
                }
                return new jspb.BinaryDecoder(a, b, c);
            };
            jspb.BinaryDecoder.prototype.free = function () {
                this.clear();
                100 > jspb.BinaryDecoder.instanceCache_.length && jspb.BinaryDecoder.instanceCache_.push(this);
            };
            jspb.BinaryDecoder.prototype.clone = function () {
                return jspb.BinaryDecoder.alloc(this.bytes_, this.start_, this.end_ - this.start_);
            };
            jspb.BinaryDecoder.prototype.clear = function () {
                this.bytes_ = null;
                this.cursor_ = this.end_ = this.start_ = 0;
                this.error_ = !1;
            };
            jspb.BinaryDecoder.prototype.getBuffer = function () {
                return this.bytes_;
            };
            jspb.BinaryDecoder.prototype.setBlock = function (a, b, c) {
                this.bytes_ = jspb.utils.byteSourceToUint8Array(a);
                this.start_ = goog.isDef(b) ? b : 0;
                this.end_ = goog.isDef(c) ? this.start_ + c : this.bytes_.length;
                this.cursor_ = this.start_;
            };
            jspb.BinaryDecoder.prototype.getEnd = function () {
                return this.end_;
            };
            jspb.BinaryDecoder.prototype.setEnd = function (a) {
                this.end_ = a;
            };
            jspb.BinaryDecoder.prototype.reset = function () {
                this.cursor_ = this.start_;
            };
            jspb.BinaryDecoder.prototype.getCursor = function () {
                return this.cursor_;
            };
            jspb.BinaryDecoder.prototype.setCursor = function (a) {
                this.cursor_ = a;
            };
            jspb.BinaryDecoder.prototype.advance = function (a) {
                this.cursor_ += a;
                goog.asserts.assert(this.cursor_ <= this.end_);
            };
            jspb.BinaryDecoder.prototype.atEnd = function () {
                return this.cursor_ == this.end_;
            };
            jspb.BinaryDecoder.prototype.pastEnd = function () {
                return this.cursor_ > this.end_;
            };
            jspb.BinaryDecoder.prototype.getError = function () {
                return this.error_ || 0 > this.cursor_ || this.cursor_ > this.end_;
            };
            jspb.BinaryDecoder.prototype.readSplitVarint64_ = function () {
                for (var a, b = 0, c, d = 0; 4 > d; d++) {
                    if (a = this.bytes_[this.cursor_++], b |= (a & 127) << 7 * d, 128 > a) {
                        this.tempLow_ = b >>> 0;
                        this.tempHigh_ = 0;
                        return;
                    }
                }a = this.bytes_[this.cursor_++];
                b |= (a & 127) << 28;
                c = 0 | (a & 127) >> 4;
                if (128 > a) this.tempLow_ = b >>> 0, this.tempHigh_ = c >>> 0;else {
                    for (d = 0; 5 > d; d++) {
                        if (a = this.bytes_[this.cursor_++], c |= (a & 127) << 7 * d + 3, 128 > a) {
                            this.tempLow_ = b >>> 0;
                            this.tempHigh_ = c >>> 0;
                            return;
                        }
                    }goog.asserts.fail("Failed to read varint, encoding is invalid.");
                    this.error_ = !0;
                }
            };
            jspb.BinaryDecoder.prototype.skipVarint = function () {
                for (; this.bytes_[this.cursor_] & 128;) {
                    this.cursor_++;
                }this.cursor_++;
            };
            jspb.BinaryDecoder.prototype.unskipVarint = function (a) {
                for (; 128 < a;) {
                    this.cursor_--, a >>>= 7;
                }this.cursor_--;
            };
            jspb.BinaryDecoder.prototype.readUnsignedVarint32 = function () {
                var a,
                    b = this.bytes_;
                a = b[this.cursor_ + 0];
                var c = a & 127;
                if (128 > a) return this.cursor_ += 1, goog.asserts.assert(this.cursor_ <= this.end_), c;
                a = b[this.cursor_ + 1];
                c |= (a & 127) << 7;
                if (128 > a) return this.cursor_ += 2, goog.asserts.assert(this.cursor_ <= this.end_), c;
                a = b[this.cursor_ + 2];
                c |= (a & 127) << 14;
                if (128 > a) return this.cursor_ += 3, goog.asserts.assert(this.cursor_ <= this.end_), c;
                a = b[this.cursor_ + 3];
                c |= (a & 127) << 21;
                if (128 > a) return this.cursor_ += 4, goog.asserts.assert(this.cursor_ <= this.end_), c;
                a = b[this.cursor_ + 4];
                c |= (a & 15) << 28;
                if (128 > a) return this.cursor_ += 5, goog.asserts.assert(this.cursor_ <= this.end_), c >>> 0;
                this.cursor_ += 5;
                128 <= b[this.cursor_++] && 128 <= b[this.cursor_++] && 128 <= b[this.cursor_++] && 128 <= b[this.cursor_++] && 128 <= b[this.cursor_++] && goog.asserts.assert(!1);
                goog.asserts.assert(this.cursor_ <= this.end_);
                return c;
            };
            jspb.BinaryDecoder.prototype.readSignedVarint32 = jspb.BinaryDecoder.prototype.readUnsignedVarint32;
            jspb.BinaryDecoder.prototype.readUnsignedVarint32String = function () {
                return this.readUnsignedVarint32().toString();
            };
            jspb.BinaryDecoder.prototype.readSignedVarint32String = function () {
                return this.readSignedVarint32().toString();
            };
            jspb.BinaryDecoder.prototype.readZigzagVarint32 = function () {
                var a = this.readUnsignedVarint32();
                return a >>> 1 ^ -(a & 1);
            };
            jspb.BinaryDecoder.prototype.readUnsignedVarint64 = function () {
                this.readSplitVarint64_();
                return jspb.utils.joinUint64(this.tempLow_, this.tempHigh_);
            };
            jspb.BinaryDecoder.prototype.readUnsignedVarint64String = function () {
                this.readSplitVarint64_();
                return jspb.utils.joinUnsignedDecimalString(this.tempLow_, this.tempHigh_);
            };
            jspb.BinaryDecoder.prototype.readSignedVarint64 = function () {
                this.readSplitVarint64_();
                return jspb.utils.joinInt64(this.tempLow_, this.tempHigh_);
            };
            jspb.BinaryDecoder.prototype.readSignedVarint64String = function () {
                this.readSplitVarint64_();
                return jspb.utils.joinSignedDecimalString(this.tempLow_, this.tempHigh_);
            };
            jspb.BinaryDecoder.prototype.readZigzagVarint64 = function () {
                this.readSplitVarint64_();
                return jspb.utils.joinZigzag64(this.tempLow_, this.tempHigh_);
            };
            jspb.BinaryDecoder.prototype.readZigzagVarint64String = function () {
                return this.readZigzagVarint64().toString();
            };
            jspb.BinaryDecoder.prototype.readUint8 = function () {
                var a = this.bytes_[this.cursor_ + 0];
                this.cursor_ += 1;
                goog.asserts.assert(this.cursor_ <= this.end_);
                return a;
            };
            jspb.BinaryDecoder.prototype.readUint16 = function () {
                var a = this.bytes_[this.cursor_ + 0],
                    b = this.bytes_[this.cursor_ + 1];
                this.cursor_ += 2;
                goog.asserts.assert(this.cursor_ <= this.end_);
                return a << 0 | b << 8;
            };
            jspb.BinaryDecoder.prototype.readUint32 = function () {
                var a = this.bytes_[this.cursor_ + 0],
                    b = this.bytes_[this.cursor_ + 1],
                    c = this.bytes_[this.cursor_ + 2],
                    d = this.bytes_[this.cursor_ + 3];
                this.cursor_ += 4;
                goog.asserts.assert(this.cursor_ <= this.end_);
                return (a << 0 | b << 8 | c << 16 | d << 24) >>> 0;
            };
            jspb.BinaryDecoder.prototype.readUint64 = function () {
                var a = this.readUint32(),
                    b = this.readUint32();
                return jspb.utils.joinUint64(a, b);
            };
            jspb.BinaryDecoder.prototype.readUint64String = function () {
                var a = this.readUint32(),
                    b = this.readUint32();
                return jspb.utils.joinUnsignedDecimalString(a, b);
            };
            jspb.BinaryDecoder.prototype.readInt8 = function () {
                var a = this.bytes_[this.cursor_ + 0];
                this.cursor_ += 1;
                goog.asserts.assert(this.cursor_ <= this.end_);
                return a << 24 >> 24;
            };
            jspb.BinaryDecoder.prototype.readInt16 = function () {
                var a = this.bytes_[this.cursor_ + 0],
                    b = this.bytes_[this.cursor_ + 1];
                this.cursor_ += 2;
                goog.asserts.assert(this.cursor_ <= this.end_);
                return (a << 0 | b << 8) << 16 >> 16;
            };
            jspb.BinaryDecoder.prototype.readInt32 = function () {
                var a = this.bytes_[this.cursor_ + 0],
                    b = this.bytes_[this.cursor_ + 1],
                    c = this.bytes_[this.cursor_ + 2],
                    d = this.bytes_[this.cursor_ + 3];
                this.cursor_ += 4;
                goog.asserts.assert(this.cursor_ <= this.end_);
                return a << 0 | b << 8 | c << 16 | d << 24;
            };
            jspb.BinaryDecoder.prototype.readInt64 = function () {
                var a = this.readUint32(),
                    b = this.readUint32();
                return jspb.utils.joinInt64(a, b);
            };
            jspb.BinaryDecoder.prototype.readInt64String = function () {
                var a = this.readUint32(),
                    b = this.readUint32();
                return jspb.utils.joinSignedDecimalString(a, b);
            };
            jspb.BinaryDecoder.prototype.readFloat = function () {
                var a = this.readUint32();
                return jspb.utils.joinFloat32(a, 0);
            };
            jspb.BinaryDecoder.prototype.readDouble = function () {
                var a = this.readUint32(),
                    b = this.readUint32();
                return jspb.utils.joinFloat64(a, b);
            };
            jspb.BinaryDecoder.prototype.readBool = function () {
                return !!this.bytes_[this.cursor_++];
            };
            jspb.BinaryDecoder.prototype.readEnum = function () {
                return this.readSignedVarint32();
            };
            jspb.BinaryDecoder.prototype.readString = function (a) {
                var b = this.bytes_,
                    c = this.cursor_;
                a = c + a;
                for (var d = [], e = ""; c < a;) {
                    var f = b[c++];
                    if (128 > f) d.push(f);else if (192 > f) continue;else if (224 > f) {
                        var g = b[c++];
                        d.push((f & 31) << 6 | g & 63);
                    } else if (240 > f) {
                        var g = b[c++],
                            h = b[c++];
                        d.push((f & 15) << 12 | (g & 63) << 6 | h & 63);
                    } else if (248 > f) {
                        var g = b[c++],
                            h = b[c++],
                            k = b[c++],
                            f = (f & 7) << 18 | (g & 63) << 12 | (h & 63) << 6 | k & 63,
                            f = f - 65536;
                        d.push((f >> 10 & 1023) + 55296, (f & 1023) + 56320);
                    }
                    8192 <= d.length && (e += String.fromCharCode.apply(null, d), d.length = 0);
                }
                e += goog.crypt.byteArrayToString(d);
                this.cursor_ = c;
                return e;
            };
            jspb.BinaryDecoder.prototype.readStringWithLength = function () {
                var a = this.readUnsignedVarint32();
                return this.readString(a);
            };
            jspb.BinaryDecoder.prototype.readBytes = function (a) {
                if (0 > a || this.cursor_ + a > this.bytes_.length) return this.error_ = !0, goog.asserts.fail("Invalid byte length!"), new Uint8Array(0);
                var b = this.bytes_.subarray(this.cursor_, this.cursor_ + a);
                this.cursor_ += a;
                goog.asserts.assert(this.cursor_ <= this.end_);
                return b;
            };
            jspb.BinaryDecoder.prototype.readVarintHash64 = function () {
                this.readSplitVarint64_();
                return jspb.utils.joinHash64(this.tempLow_, this.tempHigh_);
            };
            jspb.BinaryDecoder.prototype.readFixedHash64 = function () {
                var a = this.bytes_,
                    b = this.cursor_,
                    c = a[b + 0],
                    d = a[b + 1],
                    e = a[b + 2],
                    f = a[b + 3],
                    g = a[b + 4],
                    h = a[b + 5],
                    k = a[b + 6],
                    a = a[b + 7];
                this.cursor_ += 8;
                return String.fromCharCode(c, d, e, f, g, h, k, a);
            };
            jspb.BinaryReader = function (a, b, c) {
                this.decoder_ = jspb.BinaryDecoder.alloc(a, b, c);
                this.fieldCursor_ = this.decoder_.getCursor();
                this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER;
                this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID;
                this.error_ = !1;
                this.readCallbacks_ = null;
            };
            jspb.BinaryReader.instanceCache_ = [];
            jspb.BinaryReader.alloc = function (a, b, c) {
                if (jspb.BinaryReader.instanceCache_.length) {
                    var d = jspb.BinaryReader.instanceCache_.pop();
                    a && d.decoder_.setBlock(a, b, c);
                    return d;
                }
                return new jspb.BinaryReader(a, b, c);
            };
            jspb.BinaryReader.prototype.alloc = jspb.BinaryReader.alloc;
            jspb.BinaryReader.prototype.free = function () {
                this.decoder_.clear();
                this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER;
                this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID;
                this.error_ = !1;
                this.readCallbacks_ = null;
                100 > jspb.BinaryReader.instanceCache_.length && jspb.BinaryReader.instanceCache_.push(this);
            };
            jspb.BinaryReader.prototype.getFieldCursor = function () {
                return this.fieldCursor_;
            };
            jspb.BinaryReader.prototype.getCursor = function () {
                return this.decoder_.getCursor();
            };
            jspb.BinaryReader.prototype.getBuffer = function () {
                return this.decoder_.getBuffer();
            };
            jspb.BinaryReader.prototype.getFieldNumber = function () {
                return this.nextField_;
            };
            jspb.BinaryReader.prototype.getWireType = function () {
                return this.nextWireType_;
            };
            jspb.BinaryReader.prototype.isEndGroup = function () {
                return this.nextWireType_ == jspb.BinaryConstants.WireType.END_GROUP;
            };
            jspb.BinaryReader.prototype.getError = function () {
                return this.error_ || this.decoder_.getError();
            };
            jspb.BinaryReader.prototype.setBlock = function (a, b, c) {
                this.decoder_.setBlock(a, b, c);
                this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER;
                this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID;
            };
            jspb.BinaryReader.prototype.reset = function () {
                this.decoder_.reset();
                this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER;
                this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID;
            };
            jspb.BinaryReader.prototype.advance = function (a) {
                this.decoder_.advance(a);
            };
            jspb.BinaryReader.prototype.nextField = function () {
                if (this.decoder_.atEnd()) return !1;
                if (this.getError()) return goog.asserts.fail("Decoder hit an error"), !1;
                this.fieldCursor_ = this.decoder_.getCursor();
                var a = this.decoder_.readUnsignedVarint32(),
                    b = a >>> 3,
                    a = a & 7;
                if (a != jspb.BinaryConstants.WireType.VARINT && a != jspb.BinaryConstants.WireType.FIXED32 && a != jspb.BinaryConstants.WireType.FIXED64 && a != jspb.BinaryConstants.WireType.DELIMITED && a != jspb.BinaryConstants.WireType.START_GROUP && a != jspb.BinaryConstants.WireType.END_GROUP) return goog.asserts.fail("Invalid wire type"), this.error_ = !0, !1;
                this.nextField_ = b;
                this.nextWireType_ = a;
                return !0;
            };
            jspb.BinaryReader.prototype.unskipHeader = function () {
                this.decoder_.unskipVarint(this.nextField_ << 3 | this.nextWireType_);
            };
            jspb.BinaryReader.prototype.skipMatchingFields = function () {
                var a = this.nextField_;
                for (this.unskipHeader(); this.nextField() && this.getFieldNumber() == a;) {
                    this.skipField();
                }this.decoder_.atEnd() || this.unskipHeader();
            };
            jspb.BinaryReader.prototype.skipVarintField = function () {
                this.nextWireType_ != jspb.BinaryConstants.WireType.VARINT ? (goog.asserts.fail("Invalid wire type for skipVarintField"), this.skipField()) : this.decoder_.skipVarint();
            };
            jspb.BinaryReader.prototype.skipDelimitedField = function () {
                if (this.nextWireType_ != jspb.BinaryConstants.WireType.DELIMITED) goog.asserts.fail("Invalid wire type for skipDelimitedField"), this.skipField();else {
                    var a = this.decoder_.readUnsignedVarint32();
                    this.decoder_.advance(a);
                }
            };
            jspb.BinaryReader.prototype.skipFixed32Field = function () {
                this.nextWireType_ != jspb.BinaryConstants.WireType.FIXED32 ? (goog.asserts.fail("Invalid wire type for skipFixed32Field"), this.skipField()) : this.decoder_.advance(4);
            };
            jspb.BinaryReader.prototype.skipFixed64Field = function () {
                this.nextWireType_ != jspb.BinaryConstants.WireType.FIXED64 ? (goog.asserts.fail("Invalid wire type for skipFixed64Field"), this.skipField()) : this.decoder_.advance(8);
            };
            jspb.BinaryReader.prototype.skipGroup = function () {
                var a = [this.nextField_];
                do {
                    if (!this.nextField()) {
                        goog.asserts.fail("Unmatched start-group tag: stream EOF");
                        this.error_ = !0;
                        break;
                    }
                    if (this.nextWireType_ == jspb.BinaryConstants.WireType.START_GROUP) a.push(this.nextField_);else if (this.nextWireType_ == jspb.BinaryConstants.WireType.END_GROUP && this.nextField_ != a.pop()) {
                        goog.asserts.fail("Unmatched end-group tag");
                        this.error_ = !0;
                        break;
                    }
                } while (0 < a.length);
            };
            jspb.BinaryReader.prototype.skipField = function () {
                switch (this.nextWireType_) {
                    case jspb.BinaryConstants.WireType.VARINT:
                        this.skipVarintField();
                        break;
                    case jspb.BinaryConstants.WireType.FIXED64:
                        this.skipFixed64Field();
                        break;
                    case jspb.BinaryConstants.WireType.DELIMITED:
                        this.skipDelimitedField();
                        break;
                    case jspb.BinaryConstants.WireType.FIXED32:
                        this.skipFixed32Field();
                        break;
                    case jspb.BinaryConstants.WireType.START_GROUP:
                        this.skipGroup();
                        break;
                    default:
                        goog.asserts.fail("Invalid wire encoding for field.");
                }
            };
            jspb.BinaryReader.prototype.registerReadCallback = function (a, b) {
                goog.isNull(this.readCallbacks_) && (this.readCallbacks_ = {});
                goog.asserts.assert(!this.readCallbacks_[a]);
                this.readCallbacks_[a] = b;
            };
            jspb.BinaryReader.prototype.runReadCallback = function (a) {
                goog.asserts.assert(!goog.isNull(this.readCallbacks_));
                a = this.readCallbacks_[a];
                goog.asserts.assert(a);
                return a(this);
            };
            jspb.BinaryReader.prototype.readAny = function (a) {
                this.nextWireType_ = jspb.BinaryConstants.FieldTypeToWireType(a);
                var b = jspb.BinaryConstants.FieldType;
                switch (a) {
                    case b.DOUBLE:
                        return this.readDouble();
                    case b.FLOAT:
                        return this.readFloat();
                    case b.INT64:
                        return this.readInt64();
                    case b.UINT64:
                        return this.readUint64();
                    case b.INT32:
                        return this.readInt32();
                    case b.FIXED64:
                        return this.readFixed64();
                    case b.FIXED32:
                        return this.readFixed32();
                    case b.BOOL:
                        return this.readBool();
                    case b.STRING:
                        return this.readString();
                    case b.GROUP:
                        goog.asserts.fail("Group field type not supported in readAny()");
                    case b.MESSAGE:
                        goog.asserts.fail("Message field type not supported in readAny()");
                    case b.BYTES:
                        return this.readBytes();
                    case b.UINT32:
                        return this.readUint32();
                    case b.ENUM:
                        return this.readEnum();
                    case b.SFIXED32:
                        return this.readSfixed32();
                    case b.SFIXED64:
                        return this.readSfixed64();
                    case b.SINT32:
                        return this.readSint32();
                    case b.SINT64:
                        return this.readSint64();
                    case b.FHASH64:
                        return this.readFixedHash64();
                    case b.VHASH64:
                        return this.readVarintHash64();
                    default:
                        goog.asserts.fail("Invalid field type in readAny()");
                }
                return 0;
            };
            jspb.BinaryReader.prototype.readMessage = function (a, b) {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
                var c = this.decoder_.getEnd(),
                    d = this.decoder_.readUnsignedVarint32(),
                    d = this.decoder_.getCursor() + d;
                this.decoder_.setEnd(d);
                b(a, this);
                this.decoder_.setCursor(d);
                this.decoder_.setEnd(c);
            };
            jspb.BinaryReader.prototype.readGroup = function (a, b, c) {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.START_GROUP);
                goog.asserts.assert(this.nextField_ == a);
                c(b, this);
                this.error_ || this.nextWireType_ == jspb.BinaryConstants.WireType.END_GROUP || (goog.asserts.fail("Group submessage did not end with an END_GROUP tag"), this.error_ = !0);
            };
            jspb.BinaryReader.prototype.getFieldDecoder = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
                var a = this.decoder_.readUnsignedVarint32(),
                    b = this.decoder_.getCursor(),
                    c = b + a,
                    a = jspb.BinaryDecoder.alloc(this.decoder_.getBuffer(), b, a);
                this.decoder_.setCursor(c);
                return a;
            };
            jspb.BinaryReader.prototype.readInt32 = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
                return this.decoder_.readSignedVarint32();
            };
            jspb.BinaryReader.prototype.readInt32String = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
                return this.decoder_.readSignedVarint32String();
            };
            jspb.BinaryReader.prototype.readInt64 = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
                return this.decoder_.readSignedVarint64();
            };
            jspb.BinaryReader.prototype.readInt64String = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
                return this.decoder_.readSignedVarint64String();
            };
            jspb.BinaryReader.prototype.readUint32 = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
                return this.decoder_.readUnsignedVarint32();
            };
            jspb.BinaryReader.prototype.readUint32String = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
                return this.decoder_.readUnsignedVarint32String();
            };
            jspb.BinaryReader.prototype.readUint64 = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
                return this.decoder_.readUnsignedVarint64();
            };
            jspb.BinaryReader.prototype.readUint64String = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
                return this.decoder_.readUnsignedVarint64String();
            };
            jspb.BinaryReader.prototype.readSint32 = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
                return this.decoder_.readZigzagVarint32();
            };
            jspb.BinaryReader.prototype.readSint64 = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
                return this.decoder_.readZigzagVarint64();
            };
            jspb.BinaryReader.prototype.readSint64String = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
                return this.decoder_.readZigzagVarint64String();
            };
            jspb.BinaryReader.prototype.readFixed32 = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32);
                return this.decoder_.readUint32();
            };
            jspb.BinaryReader.prototype.readFixed64 = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64);
                return this.decoder_.readUint64();
            };
            jspb.BinaryReader.prototype.readFixed64String = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64);
                return this.decoder_.readUint64String();
            };
            jspb.BinaryReader.prototype.readSfixed32 = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32);
                return this.decoder_.readInt32();
            };
            jspb.BinaryReader.prototype.readSfixed32String = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32);
                return this.decoder_.readInt32().toString();
            };
            jspb.BinaryReader.prototype.readSfixed64 = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64);
                return this.decoder_.readInt64();
            };
            jspb.BinaryReader.prototype.readSfixed64String = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64);
                return this.decoder_.readInt64String();
            };
            jspb.BinaryReader.prototype.readFloat = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32);
                return this.decoder_.readFloat();
            };
            jspb.BinaryReader.prototype.readDouble = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64);
                return this.decoder_.readDouble();
            };
            jspb.BinaryReader.prototype.readBool = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
                return !!this.decoder_.readUnsignedVarint32();
            };
            jspb.BinaryReader.prototype.readEnum = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
                return this.decoder_.readSignedVarint64();
            };
            jspb.BinaryReader.prototype.readString = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
                var a = this.decoder_.readUnsignedVarint32();
                return this.decoder_.readString(a);
            };
            jspb.BinaryReader.prototype.readBytes = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
                var a = this.decoder_.readUnsignedVarint32();
                return this.decoder_.readBytes(a);
            };
            jspb.BinaryReader.prototype.readVarintHash64 = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
                return this.decoder_.readVarintHash64();
            };
            jspb.BinaryReader.prototype.readFixedHash64 = function () {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64);
                return this.decoder_.readFixedHash64();
            };
            jspb.BinaryReader.prototype.readPackedField_ = function (a) {
                goog.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
                for (var b = this.decoder_.readUnsignedVarint32(), b = this.decoder_.getCursor() + b, c = []; this.decoder_.getCursor() < b;) {
                    c.push(a.call(this.decoder_));
                }return c;
            };
            jspb.BinaryReader.prototype.readPackedInt32 = function () {
                return this.readPackedField_(this.decoder_.readSignedVarint32);
            };
            jspb.BinaryReader.prototype.readPackedInt32String = function () {
                return this.readPackedField_(this.decoder_.readSignedVarint32String);
            };
            jspb.BinaryReader.prototype.readPackedInt64 = function () {
                return this.readPackedField_(this.decoder_.readSignedVarint64);
            };
            jspb.BinaryReader.prototype.readPackedInt64String = function () {
                return this.readPackedField_(this.decoder_.readSignedVarint64String);
            };
            jspb.BinaryReader.prototype.readPackedUint32 = function () {
                return this.readPackedField_(this.decoder_.readUnsignedVarint32);
            };
            jspb.BinaryReader.prototype.readPackedUint32String = function () {
                return this.readPackedField_(this.decoder_.readUnsignedVarint32String);
            };
            jspb.BinaryReader.prototype.readPackedUint64 = function () {
                return this.readPackedField_(this.decoder_.readUnsignedVarint64);
            };
            jspb.BinaryReader.prototype.readPackedUint64String = function () {
                return this.readPackedField_(this.decoder_.readUnsignedVarint64String);
            };
            jspb.BinaryReader.prototype.readPackedSint32 = function () {
                return this.readPackedField_(this.decoder_.readZigzagVarint32);
            };
            jspb.BinaryReader.prototype.readPackedSint64 = function () {
                return this.readPackedField_(this.decoder_.readZigzagVarint64);
            };
            jspb.BinaryReader.prototype.readPackedSint64String = function () {
                return this.readPackedField_(this.decoder_.readZigzagVarint64String);
            };
            jspb.BinaryReader.prototype.readPackedFixed32 = function () {
                return this.readPackedField_(this.decoder_.readUint32);
            };
            jspb.BinaryReader.prototype.readPackedFixed64 = function () {
                return this.readPackedField_(this.decoder_.readUint64);
            };
            jspb.BinaryReader.prototype.readPackedFixed64String = function () {
                return this.readPackedField_(this.decoder_.readUint64String);
            };
            jspb.BinaryReader.prototype.readPackedSfixed32 = function () {
                return this.readPackedField_(this.decoder_.readInt32);
            };
            jspb.BinaryReader.prototype.readPackedSfixed64 = function () {
                return this.readPackedField_(this.decoder_.readInt64);
            };
            jspb.BinaryReader.prototype.readPackedSfixed64String = function () {
                return this.readPackedField_(this.decoder_.readInt64String);
            };
            jspb.BinaryReader.prototype.readPackedFloat = function () {
                return this.readPackedField_(this.decoder_.readFloat);
            };
            jspb.BinaryReader.prototype.readPackedDouble = function () {
                return this.readPackedField_(this.decoder_.readDouble);
            };
            jspb.BinaryReader.prototype.readPackedBool = function () {
                return this.readPackedField_(this.decoder_.readBool);
            };
            jspb.BinaryReader.prototype.readPackedEnum = function () {
                return this.readPackedField_(this.decoder_.readEnum);
            };
            jspb.BinaryReader.prototype.readPackedVarintHash64 = function () {
                return this.readPackedField_(this.decoder_.readVarintHash64);
            };
            jspb.BinaryReader.prototype.readPackedFixedHash64 = function () {
                return this.readPackedField_(this.decoder_.readFixedHash64);
            };
            jspb.Export = {};
            exports.Map = jspb.Map;
            exports.Message = jspb.Message;
            exports.BinaryReader = jspb.BinaryReader;
            exports.BinaryWriter = jspb.BinaryWriter;
            exports.ExtensionFieldInfo = jspb.ExtensionFieldInfo;
            exports.ExtensionFieldBinaryInfo = jspb.ExtensionFieldBinaryInfo;
            exports.exportSymbol = goog.exportSymbol;
            exports.inherits = goog.inherits;
            exports.object = { extend: goog.object.extend };
            exports.typeOf = goog.typeOf;
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 2: [function (_require, module, exports) {
        /**
         * @fileoverview
         * @enhanceable
         * @suppress {messageConventions} JS Compiler reports an error if a variable or
         *     field starts with 'MSG_' and isn't a translatable message.
         * @public
         */
        // GENERATED CODE -- DO NOT EDIT!

        var jspb = _require('google-protobuf');
        var goog = jspb;
        var global = Function('return this')();

        goog.exportSymbol('proto.stream.ErrorCode', null, global);
        /**
         * @enum {number}
         */
        proto.stream.ErrorCode = {
            NOERROR: 0,
            OK: 200,
            ACCEPTED: 202,
            NOCONTENT: 204,
            BADREQUEST: 400,
            UNAUTHORIZED: 401,
            SIGNATUREFAILED: 402,
            FORBIDDEN: 403,
            NOTFOUND: 404,
            INTERNALSERVERERROR: 500,
            NOTIMPLEMENTED: 501,
            BADGATEWAY: 502,
            SERVICEUNAVAILABLE: 503
        };

        goog.object.extend(exports, proto.stream);
    }, { "google-protobuf": 1 }], 3: [function (_require, module, exports) {
        var _module$exports;

        var myProto = _require('./sdk_pb');
        var myProto1 = _require('./gateway_pb');
        var myProto2 = _require('./errorcode_pb');
        module.exports = (_module$exports = {
            DataProto: myProto
        }, _defineProperty(_module$exports, "DataProto", myProto1), _defineProperty(_module$exports, "DataProto", myProto2), _module$exports);
    }, { "./errorcode_pb": 2, "./gateway_pb": 4, "./sdk_pb": 5 }], 4: [function (_require, module, exports) {
        /**
         * @fileoverview
         * @enhanceable
         * @suppress {messageConventions} JS Compiler reports an error if a variable or
         *     field starts with 'MSG_' and isn't a translatable message.
         * @public
         */
        // GENERATED CODE -- DO NOT EDIT!

        var jspb = _require('google-protobuf');
        var goog = jspb;
        var global = Function('return this')();

        var errorcode_pb = _require('./errorcode_pb.js');
        goog.exportSymbol('proto.stream.BookInfo', null, global);
        goog.exportSymbol('proto.stream.CmdId', null, global);
        goog.exportSymbol('proto.stream.ConnDetailV2', null, global);
        goog.exportSymbol('proto.stream.CreateRoom', null, global);
        goog.exportSymbol('proto.stream.CreateRoomRsp', null, global);
        goog.exportSymbol('proto.stream.DisconnectReq', null, global);
        goog.exportSymbol('proto.stream.DisconnectRsp', null, global);
        goog.exportSymbol('proto.stream.GetRoomList', null, global);
        goog.exportSymbol('proto.stream.GetRoomListRsp', null, global);
        goog.exportSymbol('proto.stream.HeartbeatReq', null, global);
        goog.exportSymbol('proto.stream.HeartbeatRsp', null, global);
        goog.exportSymbol('proto.stream.JoinOverReq', null, global);
        goog.exportSymbol('proto.stream.JoinOverRsp', null, global);
        goog.exportSymbol('proto.stream.JoinRoomReq', null, global);
        goog.exportSymbol('proto.stream.JoinRoomRsp', null, global);
        goog.exportSymbol('proto.stream.JoinRoomType', null, global);
        goog.exportSymbol('proto.stream.KickPlayer', null, global);
        goog.exportSymbol('proto.stream.KickPlayerNotify', null, global);
        goog.exportSymbol('proto.stream.KickPlayerRsp', null, global);
        goog.exportSymbol('proto.stream.LeaveRoomReq', null, global);
        goog.exportSymbol('proto.stream.LeaveRoomRsp', null, global);
        goog.exportSymbol('proto.stream.LoginReq', null, global);
        goog.exportSymbol('proto.stream.LoginRsp', null, global);
        goog.exportSymbol('proto.stream.LogoutRsp', null, global);
        goog.exportSymbol('proto.stream.NetworkStateNotify', null, global);
        goog.exportSymbol('proto.stream.NetworkStateReq', null, global);
        goog.exportSymbol('proto.stream.NetworkStateRsp', null, global);
        goog.exportSymbol('proto.stream.NoticeJoin', null, global);
        goog.exportSymbol('proto.stream.NoticeLeave', null, global);
        goog.exportSymbol('proto.stream.PlayerInfo', null, global);
        goog.exportSymbol('proto.stream.RoomFilter', null, global);
        goog.exportSymbol('proto.stream.RoomInfo', null, global);
        goog.exportSymbol('proto.stream.TcpProtoHeader', null, global);
        goog.exportSymbol('proto.stream.UserV2', null, global);
        goog.exportSymbol('proto.stream.keyValue', null, global);

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.LoginReq = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.LoginReq, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.LoginReq.displayName = 'proto.stream.LoginReq';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.LoginReq.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.LoginReq.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.LoginReq} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.LoginReq.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    gameid: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    appkey: jspb.Message.getFieldWithDefault(msg, 2, ""),
                    deviceid: jspb.Message.getFieldWithDefault(msg, 3, ""),
                    sign: jspb.Message.getFieldWithDefault(msg, 4, "")
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.LoginReq}
         */
        proto.stream.LoginReq.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.LoginReq();
            return proto.stream.LoginReq.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.LoginReq} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.LoginReq}
         */
        proto.stream.LoginReq.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setGameid(value);
                        break;
                    case 2:
                        var value = /** @type {string} */reader.readString();
                        msg.setAppkey(value);
                        break;
                    case 3:
                        var value = /** @type {string} */reader.readString();
                        msg.setDeviceid(value);
                        break;
                    case 4:
                        var value = /** @type {string} */reader.readString();
                        msg.setSign(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.LoginReq.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.LoginReq.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.LoginReq} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.LoginReq.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getGameid();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
            f = message.getAppkey();
            if (f.length > 0) {
                writer.writeString(2, f);
            }
            f = message.getDeviceid();
            if (f.length > 0) {
                writer.writeString(3, f);
            }
            f = message.getSign();
            if (f.length > 0) {
                writer.writeString(4, f);
            }
        };

        /**
         * optional uint32 gameID = 1;
         * @return {number}
         */
        proto.stream.LoginReq.prototype.getGameid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.LoginReq.prototype.setGameid = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * optional string appKey = 2;
         * @return {string}
         */
        proto.stream.LoginReq.prototype.getAppkey = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 2, "")
            );
        };

        /** @param {string} value */
        proto.stream.LoginReq.prototype.setAppkey = function (value) {
            jspb.Message.setProto3StringField(this, 2, value);
        };

        /**
         * optional string deviceID = 3;
         * @return {string}
         */
        proto.stream.LoginReq.prototype.getDeviceid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 3, "")
            );
        };

        /** @param {string} value */
        proto.stream.LoginReq.prototype.setDeviceid = function (value) {
            jspb.Message.setProto3StringField(this, 3, value);
        };

        /**
         * optional string sign = 4;
         * @return {string}
         */
        proto.stream.LoginReq.prototype.getSign = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 4, "")
            );
        };

        /** @param {string} value */
        proto.stream.LoginReq.prototype.setSign = function (value) {
            jspb.Message.setProto3StringField(this, 4, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.LoginRsp = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.LoginRsp, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.LoginRsp.displayName = 'proto.stream.LoginRsp';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.LoginRsp.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.LoginRsp.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.LoginRsp} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.LoginRsp.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    status: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    roomid: jspb.Message.getFieldWithDefault(msg, 2, "0")
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.LoginRsp}
         */
        proto.stream.LoginRsp.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.LoginRsp();
            return proto.stream.LoginRsp.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.LoginRsp} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.LoginRsp}
         */
        proto.stream.LoginRsp.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {!proto.stream.ErrorCode} */reader.readEnum();
                        msg.setStatus(value);
                        break;
                    case 2:
                        var value = /** @type {string} */reader.readUint64String();
                        msg.setRoomid(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.LoginRsp.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.LoginRsp.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.LoginRsp} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.LoginRsp.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getStatus();
            if (f !== 0.0) {
                writer.writeEnum(1, f);
            }
            f = message.getRoomid();
            if (parseInt(f, 10) !== 0) {
                writer.writeUint64String(2, f);
            }
        };

        /**
         * optional ErrorCode status = 1;
         * @return {!proto.stream.ErrorCode}
         */
        proto.stream.LoginRsp.prototype.getStatus = function () {
            return (/** @type {!proto.stream.ErrorCode} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {!proto.stream.ErrorCode} value */
        proto.stream.LoginRsp.prototype.setStatus = function (value) {
            jspb.Message.setProto3EnumField(this, 1, value);
        };

        /**
         * optional uint64 roomID = 2;
         * @return {string}
         */
        proto.stream.LoginRsp.prototype.getRoomid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 2, "0")
            );
        };

        /** @param {string} value */
        proto.stream.LoginRsp.prototype.setRoomid = function (value) {
            jspb.Message.setProto3StringIntField(this, 2, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.HeartbeatReq = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.HeartbeatReq, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.HeartbeatReq.displayName = 'proto.stream.HeartbeatReq';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.HeartbeatReq.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.HeartbeatReq.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.HeartbeatReq} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.HeartbeatReq.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    gameid: jspb.Message.getFieldWithDefault(msg, 1, 0)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.HeartbeatReq}
         */
        proto.stream.HeartbeatReq.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.HeartbeatReq();
            return proto.stream.HeartbeatReq.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.HeartbeatReq} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.HeartbeatReq}
         */
        proto.stream.HeartbeatReq.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setGameid(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.HeartbeatReq.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.HeartbeatReq.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.HeartbeatReq} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.HeartbeatReq.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getGameid();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
        };

        /**
         * optional uint32 gameID = 1;
         * @return {number}
         */
        proto.stream.HeartbeatReq.prototype.getGameid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.HeartbeatReq.prototype.setGameid = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.HeartbeatRsp = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.HeartbeatRsp, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.HeartbeatRsp.displayName = 'proto.stream.HeartbeatRsp';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.HeartbeatRsp.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.HeartbeatRsp.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.HeartbeatRsp} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.HeartbeatRsp.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    gameid: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    gsexist: jspb.Message.getFieldWithDefault(msg, 2, 0)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.HeartbeatRsp}
         */
        proto.stream.HeartbeatRsp.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.HeartbeatRsp();
            return proto.stream.HeartbeatRsp.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.HeartbeatRsp} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.HeartbeatRsp}
         */
        proto.stream.HeartbeatRsp.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setGameid(value);
                        break;
                    case 2:
                        var value = /** @type {number} */reader.readInt32();
                        msg.setGsexist(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.HeartbeatRsp.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.HeartbeatRsp.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.HeartbeatRsp} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.HeartbeatRsp.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getGameid();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
            f = message.getGsexist();
            if (f !== 0) {
                writer.writeInt32(2, f);
            }
        };

        /**
         * optional uint32 gameID = 1;
         * @return {number}
         */
        proto.stream.HeartbeatRsp.prototype.getGameid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.HeartbeatRsp.prototype.setGameid = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * optional int32 gsExist = 2;
         * @return {number}
         */
        proto.stream.HeartbeatRsp.prototype.getGsexist = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 2, 0)
            );
        };

        /** @param {number} value */
        proto.stream.HeartbeatRsp.prototype.setGsexist = function (value) {
            jspb.Message.setProto3IntField(this, 2, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.DisconnectReq = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.DisconnectReq, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.DisconnectReq.displayName = 'proto.stream.DisconnectReq';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.DisconnectReq.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.DisconnectReq.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.DisconnectReq} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.DisconnectReq.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    userid: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    gameid: jspb.Message.getFieldWithDefault(msg, 2, 0),
                    roomid: jspb.Message.getFieldWithDefault(msg, 3, "0")
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.DisconnectReq}
         */
        proto.stream.DisconnectReq.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.DisconnectReq();
            return proto.stream.DisconnectReq.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.DisconnectReq} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.DisconnectReq}
         */
        proto.stream.DisconnectReq.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setUserid(value);
                        break;
                    case 2:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setGameid(value);
                        break;
                    case 3:
                        var value = /** @type {string} */reader.readUint64String();
                        msg.setRoomid(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.DisconnectReq.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.DisconnectReq.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.DisconnectReq} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.DisconnectReq.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getUserid();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
            f = message.getGameid();
            if (f !== 0) {
                writer.writeUint32(2, f);
            }
            f = message.getRoomid();
            if (parseInt(f, 10) !== 0) {
                writer.writeUint64String(3, f);
            }
        };

        /**
         * optional uint32 userID = 1;
         * @return {number}
         */
        proto.stream.DisconnectReq.prototype.getUserid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.DisconnectReq.prototype.setUserid = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * optional uint32 gameID = 2;
         * @return {number}
         */
        proto.stream.DisconnectReq.prototype.getGameid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 2, 0)
            );
        };

        /** @param {number} value */
        proto.stream.DisconnectReq.prototype.setGameid = function (value) {
            jspb.Message.setProto3IntField(this, 2, value);
        };

        /**
         * optional uint64 roomId = 3;
         * @return {string}
         */
        proto.stream.DisconnectReq.prototype.getRoomid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 3, "0")
            );
        };

        /** @param {string} value */
        proto.stream.DisconnectReq.prototype.setRoomid = function (value) {
            jspb.Message.setProto3StringIntField(this, 3, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.DisconnectRsp = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.DisconnectRsp, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.DisconnectRsp.displayName = 'proto.stream.DisconnectRsp';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.DisconnectRsp.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.DisconnectRsp.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.DisconnectRsp} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.DisconnectRsp.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    status: jspb.Message.getFieldWithDefault(msg, 1, 0)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.DisconnectRsp}
         */
        proto.stream.DisconnectRsp.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.DisconnectRsp();
            return proto.stream.DisconnectRsp.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.DisconnectRsp} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.DisconnectRsp}
         */
        proto.stream.DisconnectRsp.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {!proto.stream.ErrorCode} */reader.readEnum();
                        msg.setStatus(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.DisconnectRsp.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.DisconnectRsp.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.DisconnectRsp} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.DisconnectRsp.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getStatus();
            if (f !== 0.0) {
                writer.writeEnum(1, f);
            }
        };

        /**
         * optional ErrorCode status = 1;
         * @return {!proto.stream.ErrorCode}
         */
        proto.stream.DisconnectRsp.prototype.getStatus = function () {
            return (/** @type {!proto.stream.ErrorCode} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {!proto.stream.ErrorCode} value */
        proto.stream.DisconnectRsp.prototype.setStatus = function (value) {
            jspb.Message.setProto3EnumField(this, 1, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.LogoutRsp = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.LogoutRsp, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.LogoutRsp.displayName = 'proto.stream.LogoutRsp';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.LogoutRsp.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.LogoutRsp.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.LogoutRsp} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.LogoutRsp.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    status: jspb.Message.getFieldWithDefault(msg, 1, 0)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.LogoutRsp}
         */
        proto.stream.LogoutRsp.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.LogoutRsp();
            return proto.stream.LogoutRsp.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.LogoutRsp} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.LogoutRsp}
         */
        proto.stream.LogoutRsp.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {!proto.stream.ErrorCode} */reader.readEnum();
                        msg.setStatus(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.LogoutRsp.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.LogoutRsp.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.LogoutRsp} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.LogoutRsp.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getStatus();
            if (f !== 0.0) {
                writer.writeEnum(1, f);
            }
        };

        /**
         * optional ErrorCode status = 1;
         * @return {!proto.stream.ErrorCode}
         */
        proto.stream.LogoutRsp.prototype.getStatus = function () {
            return (/** @type {!proto.stream.ErrorCode} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {!proto.stream.ErrorCode} value */
        proto.stream.LogoutRsp.prototype.setStatus = function (value) {
            jspb.Message.setProto3EnumField(this, 1, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.keyValue = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.keyValue, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.keyValue.displayName = 'proto.stream.keyValue';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.keyValue.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.keyValue.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.keyValue} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.keyValue.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    key: jspb.Message.getFieldWithDefault(msg, 1, ""),
                    value: jspb.Message.getFieldWithDefault(msg, 2, "")
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.keyValue}
         */
        proto.stream.keyValue.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.keyValue();
            return proto.stream.keyValue.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.keyValue} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.keyValue}
         */
        proto.stream.keyValue.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {string} */reader.readString();
                        msg.setKey(value);
                        break;
                    case 2:
                        var value = /** @type {string} */reader.readString();
                        msg.setValue(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.keyValue.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.keyValue.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.keyValue} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.keyValue.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getKey();
            if (f.length > 0) {
                writer.writeString(1, f);
            }
            f = message.getValue();
            if (f.length > 0) {
                writer.writeString(2, f);
            }
        };

        /**
         * optional string key = 1;
         * @return {string}
         */
        proto.stream.keyValue.prototype.getKey = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 1, "")
            );
        };

        /** @param {string} value */
        proto.stream.keyValue.prototype.setKey = function (value) {
            jspb.Message.setProto3StringField(this, 1, value);
        };

        /**
         * optional string value = 2;
         * @return {string}
         */
        proto.stream.keyValue.prototype.getValue = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 2, "")
            );
        };

        /** @param {string} value */
        proto.stream.keyValue.prototype.setValue = function (value) {
            jspb.Message.setProto3StringField(this, 2, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.PlayerInfo = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.PlayerInfo, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.PlayerInfo.displayName = 'proto.stream.PlayerInfo';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.PlayerInfo.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.PlayerInfo.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.PlayerInfo} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.PlayerInfo.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    userid: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    userprofile: msg.getUserprofile_asB64()
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.PlayerInfo}
         */
        proto.stream.PlayerInfo.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.PlayerInfo();
            return proto.stream.PlayerInfo.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.PlayerInfo} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.PlayerInfo}
         */
        proto.stream.PlayerInfo.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setUserid(value);
                        break;
                    case 2:
                        var value = /** @type {!Uint8Array} */reader.readBytes();
                        msg.setUserprofile(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.PlayerInfo.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.PlayerInfo.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.PlayerInfo} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.PlayerInfo.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getUserid();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
            f = message.getUserprofile_asU8();
            if (f.length > 0) {
                writer.writeBytes(2, f);
            }
        };

        /**
         * optional uint32 userID = 1;
         * @return {number}
         */
        proto.stream.PlayerInfo.prototype.getUserid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.PlayerInfo.prototype.setUserid = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * optional bytes userProfile = 2;
         * @return {!(string|Uint8Array)}
         */
        proto.stream.PlayerInfo.prototype.getUserprofile = function () {
            return (/** @type {!(string|Uint8Array)} */jspb.Message.getFieldWithDefault(this, 2, "")
            );
        };

        /**
         * optional bytes userProfile = 2;
         * This is a type-conversion wrapper around `getUserprofile()`
         * @return {string}
         */
        proto.stream.PlayerInfo.prototype.getUserprofile_asB64 = function () {
            return (/** @type {string} */jspb.Message.bytesAsB64(this.getUserprofile())
            );
        };

        /**
         * optional bytes userProfile = 2;
         * Note that Uint8Array is not supported on all browsers.
         * @see http://caniuse.com/Uint8Array
         * This is a type-conversion wrapper around `getUserprofile()`
         * @return {!Uint8Array}
         */
        proto.stream.PlayerInfo.prototype.getUserprofile_asU8 = function () {
            return (/** @type {!Uint8Array} */jspb.Message.bytesAsU8(this.getUserprofile())
            );
        };

        /** @param {!(string|Uint8Array)} value */
        proto.stream.PlayerInfo.prototype.setUserprofile = function (value) {
            jspb.Message.setProto3BytesField(this, 2, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.BookInfo = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.BookInfo, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.BookInfo.displayName = 'proto.stream.BookInfo';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.BookInfo.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.BookInfo.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.BookInfo} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.BookInfo.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    bookid: jspb.Message.getFieldWithDefault(msg, 1, ""),
                    bookkey: jspb.Message.getFieldWithDefault(msg, 2, ""),
                    hoteladdr: jspb.Message.getFieldWithDefault(msg, 3, "")
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.BookInfo}
         */
        proto.stream.BookInfo.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.BookInfo();
            return proto.stream.BookInfo.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.BookInfo} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.BookInfo}
         */
        proto.stream.BookInfo.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {string} */reader.readString();
                        msg.setBookid(value);
                        break;
                    case 2:
                        var value = /** @type {string} */reader.readString();
                        msg.setBookkey(value);
                        break;
                    case 3:
                        var value = /** @type {string} */reader.readString();
                        msg.setHoteladdr(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.BookInfo.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.BookInfo.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.BookInfo} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.BookInfo.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getBookid();
            if (f.length > 0) {
                writer.writeString(1, f);
            }
            f = message.getBookkey();
            if (f.length > 0) {
                writer.writeString(2, f);
            }
            f = message.getHoteladdr();
            if (f.length > 0) {
                writer.writeString(3, f);
            }
        };

        /**
         * optional string bookID = 1;
         * @return {string}
         */
        proto.stream.BookInfo.prototype.getBookid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 1, "")
            );
        };

        /** @param {string} value */
        proto.stream.BookInfo.prototype.setBookid = function (value) {
            jspb.Message.setProto3StringField(this, 1, value);
        };

        /**
         * optional string bookKey = 2;
         * @return {string}
         */
        proto.stream.BookInfo.prototype.getBookkey = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 2, "")
            );
        };

        /** @param {string} value */
        proto.stream.BookInfo.prototype.setBookkey = function (value) {
            jspb.Message.setProto3StringField(this, 2, value);
        };

        /**
         * optional string hotelAddr = 3;
         * @return {string}
         */
        proto.stream.BookInfo.prototype.getHoteladdr = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 3, "")
            );
        };

        /** @param {string} value */
        proto.stream.BookInfo.prototype.setHoteladdr = function (value) {
            jspb.Message.setProto3StringField(this, 3, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.RoomInfo = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.RoomInfo, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.RoomInfo.displayName = 'proto.stream.RoomInfo';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.RoomInfo.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.RoomInfo.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.RoomInfo} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.RoomInfo.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    roomid: jspb.Message.getFieldWithDefault(msg, 1, "0"),
                    roomname: jspb.Message.getFieldWithDefault(msg, 2, ""),
                    maxplayer: jspb.Message.getFieldWithDefault(msg, 3, 0),
                    mode: jspb.Message.getFieldWithDefault(msg, 4, 0),
                    canwatch: jspb.Message.getFieldWithDefault(msg, 5, 0),
                    visibility: jspb.Message.getFieldWithDefault(msg, 6, 0),
                    roomproperty: msg.getRoomproperty_asB64(),
                    owner: jspb.Message.getFieldWithDefault(msg, 8, 0)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.RoomInfo}
         */
        proto.stream.RoomInfo.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.RoomInfo();
            return proto.stream.RoomInfo.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.RoomInfo} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.RoomInfo}
         */
        proto.stream.RoomInfo.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {string} */reader.readUint64String();
                        msg.setRoomid(value);
                        break;
                    case 2:
                        var value = /** @type {string} */reader.readString();
                        msg.setRoomname(value);
                        break;
                    case 3:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setMaxplayer(value);
                        break;
                    case 4:
                        var value = /** @type {number} */reader.readInt32();
                        msg.setMode(value);
                        break;
                    case 5:
                        var value = /** @type {number} */reader.readInt32();
                        msg.setCanwatch(value);
                        break;
                    case 6:
                        var value = /** @type {number} */reader.readInt32();
                        msg.setVisibility(value);
                        break;
                    case 7:
                        var value = /** @type {!Uint8Array} */reader.readBytes();
                        msg.setRoomproperty(value);
                        break;
                    case 8:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setOwner(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.RoomInfo.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.RoomInfo.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.RoomInfo} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.RoomInfo.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getRoomid();
            if (parseInt(f, 10) !== 0) {
                writer.writeUint64String(1, f);
            }
            f = message.getRoomname();
            if (f.length > 0) {
                writer.writeString(2, f);
            }
            f = message.getMaxplayer();
            if (f !== 0) {
                writer.writeUint32(3, f);
            }
            f = message.getMode();
            if (f !== 0) {
                writer.writeInt32(4, f);
            }
            f = message.getCanwatch();
            if (f !== 0) {
                writer.writeInt32(5, f);
            }
            f = message.getVisibility();
            if (f !== 0) {
                writer.writeInt32(6, f);
            }
            f = message.getRoomproperty_asU8();
            if (f.length > 0) {
                writer.writeBytes(7, f);
            }
            f = message.getOwner();
            if (f !== 0) {
                writer.writeUint32(8, f);
            }
        };

        /**
         * optional uint64 roomID = 1;
         * @return {string}
         */
        proto.stream.RoomInfo.prototype.getRoomid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 1, "0")
            );
        };

        /** @param {string} value */
        proto.stream.RoomInfo.prototype.setRoomid = function (value) {
            jspb.Message.setProto3StringIntField(this, 1, value);
        };

        /**
         * optional string roomName = 2;
         * @return {string}
         */
        proto.stream.RoomInfo.prototype.getRoomname = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 2, "")
            );
        };

        /** @param {string} value */
        proto.stream.RoomInfo.prototype.setRoomname = function (value) {
            jspb.Message.setProto3StringField(this, 2, value);
        };

        /**
         * optional uint32 maxPlayer = 3;
         * @return {number}
         */
        proto.stream.RoomInfo.prototype.getMaxplayer = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 3, 0)
            );
        };

        /** @param {number} value */
        proto.stream.RoomInfo.prototype.setMaxplayer = function (value) {
            jspb.Message.setProto3IntField(this, 3, value);
        };

        /**
         * optional int32 mode = 4;
         * @return {number}
         */
        proto.stream.RoomInfo.prototype.getMode = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 4, 0)
            );
        };

        /** @param {number} value */
        proto.stream.RoomInfo.prototype.setMode = function (value) {
            jspb.Message.setProto3IntField(this, 4, value);
        };

        /**
         * optional int32 canWatch = 5;
         * @return {number}
         */
        proto.stream.RoomInfo.prototype.getCanwatch = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 5, 0)
            );
        };

        /** @param {number} value */
        proto.stream.RoomInfo.prototype.setCanwatch = function (value) {
            jspb.Message.setProto3IntField(this, 5, value);
        };

        /**
         * optional int32 visibility = 6;
         * @return {number}
         */
        proto.stream.RoomInfo.prototype.getVisibility = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 6, 0)
            );
        };

        /** @param {number} value */
        proto.stream.RoomInfo.prototype.setVisibility = function (value) {
            jspb.Message.setProto3IntField(this, 6, value);
        };

        /**
         * optional bytes roomProperty = 7;
         * @return {!(string|Uint8Array)}
         */
        proto.stream.RoomInfo.prototype.getRoomproperty = function () {
            return (/** @type {!(string|Uint8Array)} */jspb.Message.getFieldWithDefault(this, 7, "")
            );
        };

        /**
         * optional bytes roomProperty = 7;
         * This is a type-conversion wrapper around `getRoomproperty()`
         * @return {string}
         */
        proto.stream.RoomInfo.prototype.getRoomproperty_asB64 = function () {
            return (/** @type {string} */jspb.Message.bytesAsB64(this.getRoomproperty())
            );
        };

        /**
         * optional bytes roomProperty = 7;
         * Note that Uint8Array is not supported on all browsers.
         * @see http://caniuse.com/Uint8Array
         * This is a type-conversion wrapper around `getRoomproperty()`
         * @return {!Uint8Array}
         */
        proto.stream.RoomInfo.prototype.getRoomproperty_asU8 = function () {
            return (/** @type {!Uint8Array} */jspb.Message.bytesAsU8(this.getRoomproperty())
            );
        };

        /** @param {!(string|Uint8Array)} value */
        proto.stream.RoomInfo.prototype.setRoomproperty = function (value) {
            jspb.Message.setProto3BytesField(this, 7, value);
        };

        /**
         * optional uint32 owner = 8;
         * @return {number}
         */
        proto.stream.RoomInfo.prototype.getOwner = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 8, 0)
            );
        };

        /** @param {number} value */
        proto.stream.RoomInfo.prototype.setOwner = function (value) {
            jspb.Message.setProto3IntField(this, 8, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.JoinRoomReq = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, proto.stream.JoinRoomReq.repeatedFields_, null);
        };
        goog.inherits(proto.stream.JoinRoomReq, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.JoinRoomReq.displayName = 'proto.stream.JoinRoomReq';
        }
        /**
         * List of repeated fields within this message type.
         * @private {!Array<number>}
         * @const
         */
        proto.stream.JoinRoomReq.repeatedFields_ = [5];

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.JoinRoomReq.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.JoinRoomReq.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.JoinRoomReq} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.JoinRoomReq.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    jointype: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    playerinfo: (f = msg.getPlayerinfo()) && proto.stream.PlayerInfo.toObject(includeInstance, f),
                    gameid: jspb.Message.getFieldWithDefault(msg, 3, 0),
                    roominfo: (f = msg.getRoominfo()) && proto.stream.RoomInfo.toObject(includeInstance, f),
                    tagsList: jspb.Message.toObjectList(msg.getTagsList(), proto.stream.keyValue.toObject, includeInstance),
                    cpproto: msg.getCpproto_asB64()
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.JoinRoomReq}
         */
        proto.stream.JoinRoomReq.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.JoinRoomReq();
            return proto.stream.JoinRoomReq.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.JoinRoomReq} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.JoinRoomReq}
         */
        proto.stream.JoinRoomReq.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {!proto.stream.JoinRoomType} */reader.readEnum();
                        msg.setJointype(value);
                        break;
                    case 2:
                        var value = new proto.stream.PlayerInfo();
                        reader.readMessage(value, proto.stream.PlayerInfo.deserializeBinaryFromReader);
                        msg.setPlayerinfo(value);
                        break;
                    case 3:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setGameid(value);
                        break;
                    case 4:
                        var value = new proto.stream.RoomInfo();
                        reader.readMessage(value, proto.stream.RoomInfo.deserializeBinaryFromReader);
                        msg.setRoominfo(value);
                        break;
                    case 5:
                        var value = new proto.stream.keyValue();
                        reader.readMessage(value, proto.stream.keyValue.deserializeBinaryFromReader);
                        msg.addTags(value);
                        break;
                    case 6:
                        var value = /** @type {!Uint8Array} */reader.readBytes();
                        msg.setCpproto(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.JoinRoomReq.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.JoinRoomReq.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.JoinRoomReq} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.JoinRoomReq.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getJointype();
            if (f !== 0.0) {
                writer.writeEnum(1, f);
            }
            f = message.getPlayerinfo();
            if (f != null) {
                writer.writeMessage(2, f, proto.stream.PlayerInfo.serializeBinaryToWriter);
            }
            f = message.getGameid();
            if (f !== 0) {
                writer.writeUint32(3, f);
            }
            f = message.getRoominfo();
            if (f != null) {
                writer.writeMessage(4, f, proto.stream.RoomInfo.serializeBinaryToWriter);
            }
            f = message.getTagsList();
            if (f.length > 0) {
                writer.writeRepeatedMessage(5, f, proto.stream.keyValue.serializeBinaryToWriter);
            }
            f = message.getCpproto_asU8();
            if (f.length > 0) {
                writer.writeBytes(6, f);
            }
        };

        /**
         * optional JoinRoomType joinType = 1;
         * @return {!proto.stream.JoinRoomType}
         */
        proto.stream.JoinRoomReq.prototype.getJointype = function () {
            return (/** @type {!proto.stream.JoinRoomType} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {!proto.stream.JoinRoomType} value */
        proto.stream.JoinRoomReq.prototype.setJointype = function (value) {
            jspb.Message.setProto3EnumField(this, 1, value);
        };

        /**
         * optional PlayerInfo playerInfo = 2;
         * @return {?proto.stream.PlayerInfo}
         */
        proto.stream.JoinRoomReq.prototype.getPlayerinfo = function () {
            return (/** @type{?proto.stream.PlayerInfo} */jspb.Message.getWrapperField(this, proto.stream.PlayerInfo, 2)
            );
        };

        /** @param {?proto.stream.PlayerInfo|undefined} value */
        proto.stream.JoinRoomReq.prototype.setPlayerinfo = function (value) {
            jspb.Message.setWrapperField(this, 2, value);
        };

        proto.stream.JoinRoomReq.prototype.clearPlayerinfo = function () {
            this.setPlayerinfo(undefined);
        };

        /**
         * Returns whether this field is set.
         * @return {!boolean}
         */
        proto.stream.JoinRoomReq.prototype.hasPlayerinfo = function () {
            return jspb.Message.getField(this, 2) != null;
        };

        /**
         * optional uint32 gameID = 3;
         * @return {number}
         */
        proto.stream.JoinRoomReq.prototype.getGameid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 3, 0)
            );
        };

        /** @param {number} value */
        proto.stream.JoinRoomReq.prototype.setGameid = function (value) {
            jspb.Message.setProto3IntField(this, 3, value);
        };

        /**
         * optional RoomInfo roomInfo = 4;
         * @return {?proto.stream.RoomInfo}
         */
        proto.stream.JoinRoomReq.prototype.getRoominfo = function () {
            return (/** @type{?proto.stream.RoomInfo} */jspb.Message.getWrapperField(this, proto.stream.RoomInfo, 4)
            );
        };

        /** @param {?proto.stream.RoomInfo|undefined} value */
        proto.stream.JoinRoomReq.prototype.setRoominfo = function (value) {
            jspb.Message.setWrapperField(this, 4, value);
        };

        proto.stream.JoinRoomReq.prototype.clearRoominfo = function () {
            this.setRoominfo(undefined);
        };

        /**
         * Returns whether this field is set.
         * @return {!boolean}
         */
        proto.stream.JoinRoomReq.prototype.hasRoominfo = function () {
            return jspb.Message.getField(this, 4) != null;
        };

        /**
         * repeated keyValue tags = 5;
         * @return {!Array.<!proto.stream.keyValue>}
         */
        proto.stream.JoinRoomReq.prototype.getTagsList = function () {
            return (/** @type{!Array.<!proto.stream.keyValue>} */jspb.Message.getRepeatedWrapperField(this, proto.stream.keyValue, 5)
            );
        };

        /** @param {!Array.<!proto.stream.keyValue>} value */
        proto.stream.JoinRoomReq.prototype.setTagsList = function (value) {
            jspb.Message.setRepeatedWrapperField(this, 5, value);
        };

        /**
         * @param {!proto.stream.keyValue=} opt_value
         * @param {number=} opt_index
         * @return {!proto.stream.keyValue}
         */
        proto.stream.JoinRoomReq.prototype.addTags = function (opt_value, opt_index) {
            return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, proto.stream.keyValue, opt_index);
        };

        proto.stream.JoinRoomReq.prototype.clearTagsList = function () {
            this.setTagsList([]);
        };

        /**
         * optional bytes cpProto = 6;
         * @return {!(string|Uint8Array)}
         */
        proto.stream.JoinRoomReq.prototype.getCpproto = function () {
            return (/** @type {!(string|Uint8Array)} */jspb.Message.getFieldWithDefault(this, 6, "")
            );
        };

        /**
         * optional bytes cpProto = 6;
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {string}
         */
        proto.stream.JoinRoomReq.prototype.getCpproto_asB64 = function () {
            return (/** @type {string} */jspb.Message.bytesAsB64(this.getCpproto())
            );
        };

        /**
         * optional bytes cpProto = 6;
         * Note that Uint8Array is not supported on all browsers.
         * @see http://caniuse.com/Uint8Array
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {!Uint8Array}
         */
        proto.stream.JoinRoomReq.prototype.getCpproto_asU8 = function () {
            return (/** @type {!Uint8Array} */jspb.Message.bytesAsU8(this.getCpproto())
            );
        };

        /** @param {!(string|Uint8Array)} value */
        proto.stream.JoinRoomReq.prototype.setCpproto = function (value) {
            jspb.Message.setProto3BytesField(this, 6, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.JoinRoomRsp = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, proto.stream.JoinRoomRsp.repeatedFields_, null);
        };
        goog.inherits(proto.stream.JoinRoomRsp, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.JoinRoomRsp.displayName = 'proto.stream.JoinRoomRsp';
        }
        /**
         * List of repeated fields within this message type.
         * @private {!Array<number>}
         * @const
         */
        proto.stream.JoinRoomRsp.repeatedFields_ = [2];

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.JoinRoomRsp.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.JoinRoomRsp.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.JoinRoomRsp} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.JoinRoomRsp.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    status: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    usersList: jspb.Message.toObjectList(msg.getUsersList(), proto.stream.PlayerInfo.toObject, includeInstance),
                    roominfo: (f = msg.getRoominfo()) && proto.stream.RoomInfo.toObject(includeInstance, f),
                    bookinfo: (f = msg.getBookinfo()) && proto.stream.BookInfo.toObject(includeInstance, f),
                    cpproto: msg.getCpproto_asB64()
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.JoinRoomRsp}
         */
        proto.stream.JoinRoomRsp.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.JoinRoomRsp();
            return proto.stream.JoinRoomRsp.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.JoinRoomRsp} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.JoinRoomRsp}
         */
        proto.stream.JoinRoomRsp.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {!proto.stream.ErrorCode} */reader.readEnum();
                        msg.setStatus(value);
                        break;
                    case 2:
                        var value = new proto.stream.PlayerInfo();
                        reader.readMessage(value, proto.stream.PlayerInfo.deserializeBinaryFromReader);
                        msg.addUsers(value);
                        break;
                    case 3:
                        var value = new proto.stream.RoomInfo();
                        reader.readMessage(value, proto.stream.RoomInfo.deserializeBinaryFromReader);
                        msg.setRoominfo(value);
                        break;
                    case 4:
                        var value = new proto.stream.BookInfo();
                        reader.readMessage(value, proto.stream.BookInfo.deserializeBinaryFromReader);
                        msg.setBookinfo(value);
                        break;
                    case 5:
                        var value = /** @type {!Uint8Array} */reader.readBytes();
                        msg.setCpproto(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.JoinRoomRsp.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.JoinRoomRsp.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.JoinRoomRsp} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.JoinRoomRsp.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getStatus();
            if (f !== 0.0) {
                writer.writeEnum(1, f);
            }
            f = message.getUsersList();
            if (f.length > 0) {
                writer.writeRepeatedMessage(2, f, proto.stream.PlayerInfo.serializeBinaryToWriter);
            }
            f = message.getRoominfo();
            if (f != null) {
                writer.writeMessage(3, f, proto.stream.RoomInfo.serializeBinaryToWriter);
            }
            f = message.getBookinfo();
            if (f != null) {
                writer.writeMessage(4, f, proto.stream.BookInfo.serializeBinaryToWriter);
            }
            f = message.getCpproto_asU8();
            if (f.length > 0) {
                writer.writeBytes(5, f);
            }
        };

        /**
         * optional ErrorCode status = 1;
         * @return {!proto.stream.ErrorCode}
         */
        proto.stream.JoinRoomRsp.prototype.getStatus = function () {
            return (/** @type {!proto.stream.ErrorCode} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {!proto.stream.ErrorCode} value */
        proto.stream.JoinRoomRsp.prototype.setStatus = function (value) {
            jspb.Message.setProto3EnumField(this, 1, value);
        };

        /**
         * repeated PlayerInfo users = 2;
         * @return {!Array.<!proto.stream.PlayerInfo>}
         */
        proto.stream.JoinRoomRsp.prototype.getUsersList = function () {
            return (/** @type{!Array.<!proto.stream.PlayerInfo>} */jspb.Message.getRepeatedWrapperField(this, proto.stream.PlayerInfo, 2)
            );
        };

        /** @param {!Array.<!proto.stream.PlayerInfo>} value */
        proto.stream.JoinRoomRsp.prototype.setUsersList = function (value) {
            jspb.Message.setRepeatedWrapperField(this, 2, value);
        };

        /**
         * @param {!proto.stream.PlayerInfo=} opt_value
         * @param {number=} opt_index
         * @return {!proto.stream.PlayerInfo}
         */
        proto.stream.JoinRoomRsp.prototype.addUsers = function (opt_value, opt_index) {
            return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.stream.PlayerInfo, opt_index);
        };

        proto.stream.JoinRoomRsp.prototype.clearUsersList = function () {
            this.setUsersList([]);
        };

        /**
         * optional RoomInfo roomInfo = 3;
         * @return {?proto.stream.RoomInfo}
         */
        proto.stream.JoinRoomRsp.prototype.getRoominfo = function () {
            return (/** @type{?proto.stream.RoomInfo} */jspb.Message.getWrapperField(this, proto.stream.RoomInfo, 3)
            );
        };

        /** @param {?proto.stream.RoomInfo|undefined} value */
        proto.stream.JoinRoomRsp.prototype.setRoominfo = function (value) {
            jspb.Message.setWrapperField(this, 3, value);
        };

        proto.stream.JoinRoomRsp.prototype.clearRoominfo = function () {
            this.setRoominfo(undefined);
        };

        /**
         * Returns whether this field is set.
         * @return {!boolean}
         */
        proto.stream.JoinRoomRsp.prototype.hasRoominfo = function () {
            return jspb.Message.getField(this, 3) != null;
        };

        /**
         * optional BookInfo bookInfo = 4;
         * @return {?proto.stream.BookInfo}
         */
        proto.stream.JoinRoomRsp.prototype.getBookinfo = function () {
            return (/** @type{?proto.stream.BookInfo} */jspb.Message.getWrapperField(this, proto.stream.BookInfo, 4)
            );
        };

        /** @param {?proto.stream.BookInfo|undefined} value */
        proto.stream.JoinRoomRsp.prototype.setBookinfo = function (value) {
            jspb.Message.setWrapperField(this, 4, value);
        };

        proto.stream.JoinRoomRsp.prototype.clearBookinfo = function () {
            this.setBookinfo(undefined);
        };

        /**
         * Returns whether this field is set.
         * @return {!boolean}
         */
        proto.stream.JoinRoomRsp.prototype.hasBookinfo = function () {
            return jspb.Message.getField(this, 4) != null;
        };

        /**
         * optional bytes cpProto = 5;
         * @return {!(string|Uint8Array)}
         */
        proto.stream.JoinRoomRsp.prototype.getCpproto = function () {
            return (/** @type {!(string|Uint8Array)} */jspb.Message.getFieldWithDefault(this, 5, "")
            );
        };

        /**
         * optional bytes cpProto = 5;
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {string}
         */
        proto.stream.JoinRoomRsp.prototype.getCpproto_asB64 = function () {
            return (/** @type {string} */jspb.Message.bytesAsB64(this.getCpproto())
            );
        };

        /**
         * optional bytes cpProto = 5;
         * Note that Uint8Array is not supported on all browsers.
         * @see http://caniuse.com/Uint8Array
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {!Uint8Array}
         */
        proto.stream.JoinRoomRsp.prototype.getCpproto_asU8 = function () {
            return (/** @type {!Uint8Array} */jspb.Message.bytesAsU8(this.getCpproto())
            );
        };

        /** @param {!(string|Uint8Array)} value */
        proto.stream.JoinRoomRsp.prototype.setCpproto = function (value) {
            jspb.Message.setProto3BytesField(this, 5, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.NoticeJoin = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.NoticeJoin, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.NoticeJoin.displayName = 'proto.stream.NoticeJoin';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.NoticeJoin.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.NoticeJoin.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.NoticeJoin} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.NoticeJoin.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    user: (f = msg.getUser()) && proto.stream.PlayerInfo.toObject(includeInstance, f)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.NoticeJoin}
         */
        proto.stream.NoticeJoin.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.NoticeJoin();
            return proto.stream.NoticeJoin.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.NoticeJoin} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.NoticeJoin}
         */
        proto.stream.NoticeJoin.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = new proto.stream.PlayerInfo();
                        reader.readMessage(value, proto.stream.PlayerInfo.deserializeBinaryFromReader);
                        msg.setUser(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.NoticeJoin.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.NoticeJoin.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.NoticeJoin} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.NoticeJoin.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getUser();
            if (f != null) {
                writer.writeMessage(1, f, proto.stream.PlayerInfo.serializeBinaryToWriter);
            }
        };

        /**
         * optional PlayerInfo user = 1;
         * @return {?proto.stream.PlayerInfo}
         */
        proto.stream.NoticeJoin.prototype.getUser = function () {
            return (/** @type{?proto.stream.PlayerInfo} */jspb.Message.getWrapperField(this, proto.stream.PlayerInfo, 1)
            );
        };

        /** @param {?proto.stream.PlayerInfo|undefined} value */
        proto.stream.NoticeJoin.prototype.setUser = function (value) {
            jspb.Message.setWrapperField(this, 1, value);
        };

        proto.stream.NoticeJoin.prototype.clearUser = function () {
            this.setUser(undefined);
        };

        /**
         * Returns whether this field is set.
         * @return {!boolean}
         */
        proto.stream.NoticeJoin.prototype.hasUser = function () {
            return jspb.Message.getField(this, 1) != null;
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.NoticeLeave = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.NoticeLeave, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.NoticeLeave.displayName = 'proto.stream.NoticeLeave';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.NoticeLeave.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.NoticeLeave.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.NoticeLeave} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.NoticeLeave.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    userid: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    roomid: jspb.Message.getFieldWithDefault(msg, 2, "0"),
                    owner: jspb.Message.getFieldWithDefault(msg, 3, 0)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.NoticeLeave}
         */
        proto.stream.NoticeLeave.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.NoticeLeave();
            return proto.stream.NoticeLeave.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.NoticeLeave} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.NoticeLeave}
         */
        proto.stream.NoticeLeave.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setUserid(value);
                        break;
                    case 2:
                        var value = /** @type {string} */reader.readUint64String();
                        msg.setRoomid(value);
                        break;
                    case 3:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setOwner(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.NoticeLeave.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.NoticeLeave.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.NoticeLeave} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.NoticeLeave.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getUserid();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
            f = message.getRoomid();
            if (parseInt(f, 10) !== 0) {
                writer.writeUint64String(2, f);
            }
            f = message.getOwner();
            if (f !== 0) {
                writer.writeUint32(3, f);
            }
        };

        /**
         * optional uint32 userID = 1;
         * @return {number}
         */
        proto.stream.NoticeLeave.prototype.getUserid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.NoticeLeave.prototype.setUserid = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * optional uint64 roomID = 2;
         * @return {string}
         */
        proto.stream.NoticeLeave.prototype.getRoomid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 2, "0")
            );
        };

        /** @param {string} value */
        proto.stream.NoticeLeave.prototype.setRoomid = function (value) {
            jspb.Message.setProto3StringIntField(this, 2, value);
        };

        /**
         * optional uint32 owner = 3;
         * @return {number}
         */
        proto.stream.NoticeLeave.prototype.getOwner = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 3, 0)
            );
        };

        /** @param {number} value */
        proto.stream.NoticeLeave.prototype.setOwner = function (value) {
            jspb.Message.setProto3IntField(this, 3, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.JoinOverReq = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.JoinOverReq, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.JoinOverReq.displayName = 'proto.stream.JoinOverReq';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.JoinOverReq.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.JoinOverReq.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.JoinOverReq} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.JoinOverReq.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    roomid: jspb.Message.getFieldWithDefault(msg, 1, "0"),
                    gameid: jspb.Message.getFieldWithDefault(msg, 2, 0),
                    cpproto: msg.getCpproto_asB64(),
                    userid: jspb.Message.getFieldWithDefault(msg, 4, 0)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.JoinOverReq}
         */
        proto.stream.JoinOverReq.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.JoinOverReq();
            return proto.stream.JoinOverReq.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.JoinOverReq} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.JoinOverReq}
         */
        proto.stream.JoinOverReq.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {string} */reader.readUint64String();
                        msg.setRoomid(value);
                        break;
                    case 2:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setGameid(value);
                        break;
                    case 3:
                        var value = /** @type {!Uint8Array} */reader.readBytes();
                        msg.setCpproto(value);
                        break;
                    case 4:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setUserid(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.JoinOverReq.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.JoinOverReq.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.JoinOverReq} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.JoinOverReq.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getRoomid();
            if (parseInt(f, 10) !== 0) {
                writer.writeUint64String(1, f);
            }
            f = message.getGameid();
            if (f !== 0) {
                writer.writeUint32(2, f);
            }
            f = message.getCpproto_asU8();
            if (f.length > 0) {
                writer.writeBytes(3, f);
            }
            f = message.getUserid();
            if (f !== 0) {
                writer.writeUint32(4, f);
            }
        };

        /**
         * optional uint64 roomID = 1;
         * @return {string}
         */
        proto.stream.JoinOverReq.prototype.getRoomid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 1, "0")
            );
        };

        /** @param {string} value */
        proto.stream.JoinOverReq.prototype.setRoomid = function (value) {
            jspb.Message.setProto3StringIntField(this, 1, value);
        };

        /**
         * optional uint32 gameID = 2;
         * @return {number}
         */
        proto.stream.JoinOverReq.prototype.getGameid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 2, 0)
            );
        };

        /** @param {number} value */
        proto.stream.JoinOverReq.prototype.setGameid = function (value) {
            jspb.Message.setProto3IntField(this, 2, value);
        };

        /**
         * optional bytes cpProto = 3;
         * @return {!(string|Uint8Array)}
         */
        proto.stream.JoinOverReq.prototype.getCpproto = function () {
            return (/** @type {!(string|Uint8Array)} */jspb.Message.getFieldWithDefault(this, 3, "")
            );
        };

        /**
         * optional bytes cpProto = 3;
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {string}
         */
        proto.stream.JoinOverReq.prototype.getCpproto_asB64 = function () {
            return (/** @type {string} */jspb.Message.bytesAsB64(this.getCpproto())
            );
        };

        /**
         * optional bytes cpProto = 3;
         * Note that Uint8Array is not supported on all browsers.
         * @see http://caniuse.com/Uint8Array
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {!Uint8Array}
         */
        proto.stream.JoinOverReq.prototype.getCpproto_asU8 = function () {
            return (/** @type {!Uint8Array} */jspb.Message.bytesAsU8(this.getCpproto())
            );
        };

        /** @param {!(string|Uint8Array)} value */
        proto.stream.JoinOverReq.prototype.setCpproto = function (value) {
            jspb.Message.setProto3BytesField(this, 3, value);
        };

        /**
         * optional uint32 userID = 4;
         * @return {number}
         */
        proto.stream.JoinOverReq.prototype.getUserid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 4, 0)
            );
        };

        /** @param {number} value */
        proto.stream.JoinOverReq.prototype.setUserid = function (value) {
            jspb.Message.setProto3IntField(this, 4, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.JoinOverRsp = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.JoinOverRsp, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.JoinOverRsp.displayName = 'proto.stream.JoinOverRsp';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.JoinOverRsp.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.JoinOverRsp.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.JoinOverRsp} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.JoinOverRsp.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    status: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    cpproto: msg.getCpproto_asB64()
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.JoinOverRsp}
         */
        proto.stream.JoinOverRsp.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.JoinOverRsp();
            return proto.stream.JoinOverRsp.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.JoinOverRsp} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.JoinOverRsp}
         */
        proto.stream.JoinOverRsp.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {!proto.stream.ErrorCode} */reader.readEnum();
                        msg.setStatus(value);
                        break;
                    case 2:
                        var value = /** @type {!Uint8Array} */reader.readBytes();
                        msg.setCpproto(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.JoinOverRsp.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.JoinOverRsp.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.JoinOverRsp} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.JoinOverRsp.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getStatus();
            if (f !== 0.0) {
                writer.writeEnum(1, f);
            }
            f = message.getCpproto_asU8();
            if (f.length > 0) {
                writer.writeBytes(2, f);
            }
        };

        /**
         * optional ErrorCode status = 1;
         * @return {!proto.stream.ErrorCode}
         */
        proto.stream.JoinOverRsp.prototype.getStatus = function () {
            return (/** @type {!proto.stream.ErrorCode} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {!proto.stream.ErrorCode} value */
        proto.stream.JoinOverRsp.prototype.setStatus = function (value) {
            jspb.Message.setProto3EnumField(this, 1, value);
        };

        /**
         * optional bytes cpProto = 2;
         * @return {!(string|Uint8Array)}
         */
        proto.stream.JoinOverRsp.prototype.getCpproto = function () {
            return (/** @type {!(string|Uint8Array)} */jspb.Message.getFieldWithDefault(this, 2, "")
            );
        };

        /**
         * optional bytes cpProto = 2;
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {string}
         */
        proto.stream.JoinOverRsp.prototype.getCpproto_asB64 = function () {
            return (/** @type {string} */jspb.Message.bytesAsB64(this.getCpproto())
            );
        };

        /**
         * optional bytes cpProto = 2;
         * Note that Uint8Array is not supported on all browsers.
         * @see http://caniuse.com/Uint8Array
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {!Uint8Array}
         */
        proto.stream.JoinOverRsp.prototype.getCpproto_asU8 = function () {
            return (/** @type {!Uint8Array} */jspb.Message.bytesAsU8(this.getCpproto())
            );
        };

        /** @param {!(string|Uint8Array)} value */
        proto.stream.JoinOverRsp.prototype.setCpproto = function (value) {
            jspb.Message.setProto3BytesField(this, 2, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.LeaveRoomReq = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.LeaveRoomReq, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.LeaveRoomReq.displayName = 'proto.stream.LeaveRoomReq';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.LeaveRoomReq.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.LeaveRoomReq.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.LeaveRoomReq} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.LeaveRoomReq.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    userid: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    gameid: jspb.Message.getFieldWithDefault(msg, 2, 0),
                    roomid: jspb.Message.getFieldWithDefault(msg, 3, "0"),
                    cpproto: msg.getCpproto_asB64()
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.LeaveRoomReq}
         */
        proto.stream.LeaveRoomReq.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.LeaveRoomReq();
            return proto.stream.LeaveRoomReq.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.LeaveRoomReq} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.LeaveRoomReq}
         */
        proto.stream.LeaveRoomReq.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setUserid(value);
                        break;
                    case 2:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setGameid(value);
                        break;
                    case 3:
                        var value = /** @type {string} */reader.readUint64String();
                        msg.setRoomid(value);
                        break;
                    case 4:
                        var value = /** @type {!Uint8Array} */reader.readBytes();
                        msg.setCpproto(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.LeaveRoomReq.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.LeaveRoomReq.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.LeaveRoomReq} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.LeaveRoomReq.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getUserid();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
            f = message.getGameid();
            if (f !== 0) {
                writer.writeUint32(2, f);
            }
            f = message.getRoomid();
            if (parseInt(f, 10) !== 0) {
                writer.writeUint64String(3, f);
            }
            f = message.getCpproto_asU8();
            if (f.length > 0) {
                writer.writeBytes(4, f);
            }
        };

        /**
         * optional uint32 userID = 1;
         * @return {number}
         */
        proto.stream.LeaveRoomReq.prototype.getUserid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.LeaveRoomReq.prototype.setUserid = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * optional uint32 gameID = 2;
         * @return {number}
         */
        proto.stream.LeaveRoomReq.prototype.getGameid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 2, 0)
            );
        };

        /** @param {number} value */
        proto.stream.LeaveRoomReq.prototype.setGameid = function (value) {
            jspb.Message.setProto3IntField(this, 2, value);
        };

        /**
         * optional uint64 roomID = 3;
         * @return {string}
         */
        proto.stream.LeaveRoomReq.prototype.getRoomid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 3, "0")
            );
        };

        /** @param {string} value */
        proto.stream.LeaveRoomReq.prototype.setRoomid = function (value) {
            jspb.Message.setProto3StringIntField(this, 3, value);
        };

        /**
         * optional bytes cpProto = 4;
         * @return {!(string|Uint8Array)}
         */
        proto.stream.LeaveRoomReq.prototype.getCpproto = function () {
            return (/** @type {!(string|Uint8Array)} */jspb.Message.getFieldWithDefault(this, 4, "")
            );
        };

        /**
         * optional bytes cpProto = 4;
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {string}
         */
        proto.stream.LeaveRoomReq.prototype.getCpproto_asB64 = function () {
            return (/** @type {string} */jspb.Message.bytesAsB64(this.getCpproto())
            );
        };

        /**
         * optional bytes cpProto = 4;
         * Note that Uint8Array is not supported on all browsers.
         * @see http://caniuse.com/Uint8Array
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {!Uint8Array}
         */
        proto.stream.LeaveRoomReq.prototype.getCpproto_asU8 = function () {
            return (/** @type {!Uint8Array} */jspb.Message.bytesAsU8(this.getCpproto())
            );
        };

        /** @param {!(string|Uint8Array)} value */
        proto.stream.LeaveRoomReq.prototype.setCpproto = function (value) {
            jspb.Message.setProto3BytesField(this, 4, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.LeaveRoomRsp = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.LeaveRoomRsp, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.LeaveRoomRsp.displayName = 'proto.stream.LeaveRoomRsp';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.LeaveRoomRsp.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.LeaveRoomRsp.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.LeaveRoomRsp} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.LeaveRoomRsp.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    status: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    roomid: jspb.Message.getFieldWithDefault(msg, 2, "0"),
                    userid: jspb.Message.getFieldWithDefault(msg, 3, 0),
                    cpproto: msg.getCpproto_asB64()
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.LeaveRoomRsp}
         */
        proto.stream.LeaveRoomRsp.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.LeaveRoomRsp();
            return proto.stream.LeaveRoomRsp.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.LeaveRoomRsp} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.LeaveRoomRsp}
         */
        proto.stream.LeaveRoomRsp.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {!proto.stream.ErrorCode} */reader.readEnum();
                        msg.setStatus(value);
                        break;
                    case 2:
                        var value = /** @type {string} */reader.readUint64String();
                        msg.setRoomid(value);
                        break;
                    case 3:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setUserid(value);
                        break;
                    case 4:
                        var value = /** @type {!Uint8Array} */reader.readBytes();
                        msg.setCpproto(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.LeaveRoomRsp.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.LeaveRoomRsp.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.LeaveRoomRsp} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.LeaveRoomRsp.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getStatus();
            if (f !== 0.0) {
                writer.writeEnum(1, f);
            }
            f = message.getRoomid();
            if (parseInt(f, 10) !== 0) {
                writer.writeUint64String(2, f);
            }
            f = message.getUserid();
            if (f !== 0) {
                writer.writeUint32(3, f);
            }
            f = message.getCpproto_asU8();
            if (f.length > 0) {
                writer.writeBytes(4, f);
            }
        };

        /**
         * optional ErrorCode status = 1;
         * @return {!proto.stream.ErrorCode}
         */
        proto.stream.LeaveRoomRsp.prototype.getStatus = function () {
            return (/** @type {!proto.stream.ErrorCode} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {!proto.stream.ErrorCode} value */
        proto.stream.LeaveRoomRsp.prototype.setStatus = function (value) {
            jspb.Message.setProto3EnumField(this, 1, value);
        };

        /**
         * optional uint64 roomID = 2;
         * @return {string}
         */
        proto.stream.LeaveRoomRsp.prototype.getRoomid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 2, "0")
            );
        };

        /** @param {string} value */
        proto.stream.LeaveRoomRsp.prototype.setRoomid = function (value) {
            jspb.Message.setProto3StringIntField(this, 2, value);
        };

        /**
         * optional uint32 userID = 3;
         * @return {number}
         */
        proto.stream.LeaveRoomRsp.prototype.getUserid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 3, 0)
            );
        };

        /** @param {number} value */
        proto.stream.LeaveRoomRsp.prototype.setUserid = function (value) {
            jspb.Message.setProto3IntField(this, 3, value);
        };

        /**
         * optional bytes cpProto = 4;
         * @return {!(string|Uint8Array)}
         */
        proto.stream.LeaveRoomRsp.prototype.getCpproto = function () {
            return (/** @type {!(string|Uint8Array)} */jspb.Message.getFieldWithDefault(this, 4, "")
            );
        };

        /**
         * optional bytes cpProto = 4;
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {string}
         */
        proto.stream.LeaveRoomRsp.prototype.getCpproto_asB64 = function () {
            return (/** @type {string} */jspb.Message.bytesAsB64(this.getCpproto())
            );
        };

        /**
         * optional bytes cpProto = 4;
         * Note that Uint8Array is not supported on all browsers.
         * @see http://caniuse.com/Uint8Array
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {!Uint8Array}
         */
        proto.stream.LeaveRoomRsp.prototype.getCpproto_asU8 = function () {
            return (/** @type {!Uint8Array} */jspb.Message.bytesAsU8(this.getCpproto())
            );
        };

        /** @param {!(string|Uint8Array)} value */
        proto.stream.LeaveRoomRsp.prototype.setCpproto = function (value) {
            jspb.Message.setProto3BytesField(this, 4, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.TcpProtoHeader = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.TcpProtoHeader, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.TcpProtoHeader.displayName = 'proto.stream.TcpProtoHeader';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.TcpProtoHeader.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.TcpProtoHeader.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.TcpProtoHeader} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.TcpProtoHeader.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    size: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    seq: jspb.Message.getFieldWithDefault(msg, 2, 0),
                    cmd: jspb.Message.getFieldWithDefault(msg, 3, 0),
                    version: jspb.Message.getFieldWithDefault(msg, 4, 0),
                    userid: jspb.Message.getFieldWithDefault(msg, 5, 0)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.TcpProtoHeader}
         */
        proto.stream.TcpProtoHeader.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.TcpProtoHeader();
            return proto.stream.TcpProtoHeader.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.TcpProtoHeader} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.TcpProtoHeader}
         */
        proto.stream.TcpProtoHeader.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setSize(value);
                        break;
                    case 2:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setSeq(value);
                        break;
                    case 3:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setCmd(value);
                        break;
                    case 4:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setVersion(value);
                        break;
                    case 5:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setUserid(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.TcpProtoHeader.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.TcpProtoHeader.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.TcpProtoHeader} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.TcpProtoHeader.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getSize();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
            f = message.getSeq();
            if (f !== 0) {
                writer.writeUint32(2, f);
            }
            f = message.getCmd();
            if (f !== 0) {
                writer.writeUint32(3, f);
            }
            f = message.getVersion();
            if (f !== 0) {
                writer.writeUint32(4, f);
            }
            f = message.getUserid();
            if (f !== 0) {
                writer.writeUint32(5, f);
            }
        };

        /**
         * optional uint32 size = 1;
         * @return {number}
         */
        proto.stream.TcpProtoHeader.prototype.getSize = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.TcpProtoHeader.prototype.setSize = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * optional uint32 seq = 2;
         * @return {number}
         */
        proto.stream.TcpProtoHeader.prototype.getSeq = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 2, 0)
            );
        };

        /** @param {number} value */
        proto.stream.TcpProtoHeader.prototype.setSeq = function (value) {
            jspb.Message.setProto3IntField(this, 2, value);
        };

        /**
         * optional uint32 cmd = 3;
         * @return {number}
         */
        proto.stream.TcpProtoHeader.prototype.getCmd = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 3, 0)
            );
        };

        /** @param {number} value */
        proto.stream.TcpProtoHeader.prototype.setCmd = function (value) {
            jspb.Message.setProto3IntField(this, 3, value);
        };

        /**
         * optional uint32 version = 4;
         * @return {number}
         */
        proto.stream.TcpProtoHeader.prototype.getVersion = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 4, 0)
            );
        };

        /** @param {number} value */
        proto.stream.TcpProtoHeader.prototype.setVersion = function (value) {
            jspb.Message.setProto3IntField(this, 4, value);
        };

        /**
         * optional uint32 userID = 5;
         * @return {number}
         */
        proto.stream.TcpProtoHeader.prototype.getUserid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 5, 0)
            );
        };

        /** @param {number} value */
        proto.stream.TcpProtoHeader.prototype.setUserid = function (value) {
            jspb.Message.setProto3IntField(this, 5, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.ConnDetailV2 = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.ConnDetailV2, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.ConnDetailV2.displayName = 'proto.stream.ConnDetailV2';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.ConnDetailV2.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.ConnDetailV2.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.ConnDetailV2} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.ConnDetailV2.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    userid: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    gameid: jspb.Message.getFieldWithDefault(msg, 2, 0),
                    fieldid: jspb.Message.getFieldWithDefault(msg, 3, 0),
                    roomid: jspb.Message.getFieldWithDefault(msg, 4, "0"),
                    heartbeattime: jspb.Message.getFieldWithDefault(msg, 5, "0"),
                    version: jspb.Message.getFieldWithDefault(msg, 6, 0)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.ConnDetailV2}
         */
        proto.stream.ConnDetailV2.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.ConnDetailV2();
            return proto.stream.ConnDetailV2.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.ConnDetailV2} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.ConnDetailV2}
         */
        proto.stream.ConnDetailV2.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setUserid(value);
                        break;
                    case 2:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setGameid(value);
                        break;
                    case 3:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setFieldid(value);
                        break;
                    case 4:
                        var value = /** @type {string} */reader.readUint64String();
                        msg.setRoomid(value);
                        break;
                    case 5:
                        var value = /** @type {string} */reader.readUint64String();
                        msg.setHeartbeattime(value);
                        break;
                    case 6:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setVersion(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.ConnDetailV2.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.ConnDetailV2.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.ConnDetailV2} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.ConnDetailV2.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getUserid();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
            f = message.getGameid();
            if (f !== 0) {
                writer.writeUint32(2, f);
            }
            f = message.getFieldid();
            if (f !== 0) {
                writer.writeUint32(3, f);
            }
            f = message.getRoomid();
            if (parseInt(f, 10) !== 0) {
                writer.writeUint64String(4, f);
            }
            f = message.getHeartbeattime();
            if (parseInt(f, 10) !== 0) {
                writer.writeUint64String(5, f);
            }
            f = message.getVersion();
            if (f !== 0) {
                writer.writeUint32(6, f);
            }
        };

        /**
         * optional uint32 userID = 1;
         * @return {number}
         */
        proto.stream.ConnDetailV2.prototype.getUserid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.ConnDetailV2.prototype.setUserid = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * optional uint32 gameID = 2;
         * @return {number}
         */
        proto.stream.ConnDetailV2.prototype.getGameid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 2, 0)
            );
        };

        /** @param {number} value */
        proto.stream.ConnDetailV2.prototype.setGameid = function (value) {
            jspb.Message.setProto3IntField(this, 2, value);
        };

        /**
         * optional uint32 fieldID = 3;
         * @return {number}
         */
        proto.stream.ConnDetailV2.prototype.getFieldid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 3, 0)
            );
        };

        /** @param {number} value */
        proto.stream.ConnDetailV2.prototype.setFieldid = function (value) {
            jspb.Message.setProto3IntField(this, 3, value);
        };

        /**
         * optional uint64 roomID = 4;
         * @return {string}
         */
        proto.stream.ConnDetailV2.prototype.getRoomid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 4, "0")
            );
        };

        /** @param {string} value */
        proto.stream.ConnDetailV2.prototype.setRoomid = function (value) {
            jspb.Message.setProto3StringIntField(this, 4, value);
        };

        /**
         * optional uint64 heartBeatTime = 5;
         * @return {string}
         */
        proto.stream.ConnDetailV2.prototype.getHeartbeattime = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 5, "0")
            );
        };

        /** @param {string} value */
        proto.stream.ConnDetailV2.prototype.setHeartbeattime = function (value) {
            jspb.Message.setProto3StringIntField(this, 5, value);
        };

        /**
         * optional uint32 version = 6;
         * @return {number}
         */
        proto.stream.ConnDetailV2.prototype.getVersion = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 6, 0)
            );
        };

        /** @param {number} value */
        proto.stream.ConnDetailV2.prototype.setVersion = function (value) {
            jspb.Message.setProto3IntField(this, 6, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.UserV2 = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.UserV2, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.UserV2.displayName = 'proto.stream.UserV2';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.UserV2.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.UserV2.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.UserV2} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.UserV2.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    userId: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    gameId: jspb.Message.getFieldWithDefault(msg, 2, 0),
                    versionSdk: jspb.Message.getFieldWithDefault(msg, 3, 0),
                    connectionId: jspb.Message.getFieldWithDefault(msg, 4, "0"),
                    serviceId: jspb.Message.getFieldWithDefault(msg, 5, 0),
                    roomId: jspb.Message.getFieldWithDefault(msg, 6, "0"),
                    deviceId: jspb.Message.getFieldWithDefault(msg, 7, ""),
                    connStatus: jspb.Message.getFieldWithDefault(msg, 8, 0)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.UserV2}
         */
        proto.stream.UserV2.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.UserV2();
            return proto.stream.UserV2.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.UserV2} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.UserV2}
         */
        proto.stream.UserV2.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setUserId(value);
                        break;
                    case 2:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setGameId(value);
                        break;
                    case 3:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setVersionSdk(value);
                        break;
                    case 4:
                        var value = /** @type {string} */reader.readUint64String();
                        msg.setConnectionId(value);
                        break;
                    case 5:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setServiceId(value);
                        break;
                    case 6:
                        var value = /** @type {string} */reader.readUint64String();
                        msg.setRoomId(value);
                        break;
                    case 7:
                        var value = /** @type {string} */reader.readString();
                        msg.setDeviceId(value);
                        break;
                    case 8:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setConnStatus(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.UserV2.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.UserV2.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.UserV2} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.UserV2.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getUserId();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
            f = message.getGameId();
            if (f !== 0) {
                writer.writeUint32(2, f);
            }
            f = message.getVersionSdk();
            if (f !== 0) {
                writer.writeUint32(3, f);
            }
            f = message.getConnectionId();
            if (parseInt(f, 10) !== 0) {
                writer.writeUint64String(4, f);
            }
            f = message.getServiceId();
            if (f !== 0) {
                writer.writeUint32(5, f);
            }
            f = message.getRoomId();
            if (parseInt(f, 10) !== 0) {
                writer.writeUint64String(6, f);
            }
            f = message.getDeviceId();
            if (f.length > 0) {
                writer.writeString(7, f);
            }
            f = message.getConnStatus();
            if (f !== 0) {
                writer.writeUint32(8, f);
            }
        };

        /**
         * optional uint32 user_id = 1;
         * @return {number}
         */
        proto.stream.UserV2.prototype.getUserId = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.UserV2.prototype.setUserId = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * optional uint32 game_id = 2;
         * @return {number}
         */
        proto.stream.UserV2.prototype.getGameId = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 2, 0)
            );
        };

        /** @param {number} value */
        proto.stream.UserV2.prototype.setGameId = function (value) {
            jspb.Message.setProto3IntField(this, 2, value);
        };

        /**
         * optional uint32 version_sdk = 3;
         * @return {number}
         */
        proto.stream.UserV2.prototype.getVersionSdk = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 3, 0)
            );
        };

        /** @param {number} value */
        proto.stream.UserV2.prototype.setVersionSdk = function (value) {
            jspb.Message.setProto3IntField(this, 3, value);
        };

        /**
         * optional uint64 connection_id = 4;
         * @return {string}
         */
        proto.stream.UserV2.prototype.getConnectionId = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 4, "0")
            );
        };

        /** @param {string} value */
        proto.stream.UserV2.prototype.setConnectionId = function (value) {
            jspb.Message.setProto3StringIntField(this, 4, value);
        };

        /**
         * optional uint32 service_id = 5;
         * @return {number}
         */
        proto.stream.UserV2.prototype.getServiceId = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 5, 0)
            );
        };

        /** @param {number} value */
        proto.stream.UserV2.prototype.setServiceId = function (value) {
            jspb.Message.setProto3IntField(this, 5, value);
        };

        /**
         * optional uint64 room_id = 6;
         * @return {string}
         */
        proto.stream.UserV2.prototype.getRoomId = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 6, "0")
            );
        };

        /** @param {string} value */
        proto.stream.UserV2.prototype.setRoomId = function (value) {
            jspb.Message.setProto3StringIntField(this, 6, value);
        };

        /**
         * optional string device_id = 7;
         * @return {string}
         */
        proto.stream.UserV2.prototype.getDeviceId = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 7, "")
            );
        };

        /** @param {string} value */
        proto.stream.UserV2.prototype.setDeviceId = function (value) {
            jspb.Message.setProto3StringField(this, 7, value);
        };

        /**
         * optional uint32 conn_status = 8;
         * @return {number}
         */
        proto.stream.UserV2.prototype.getConnStatus = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 8, 0)
            );
        };

        /** @param {number} value */
        proto.stream.UserV2.prototype.setConnStatus = function (value) {
            jspb.Message.setProto3IntField(this, 8, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.NetworkStateReq = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.NetworkStateReq, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.NetworkStateReq.displayName = 'proto.stream.NetworkStateReq';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.NetworkStateReq.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.NetworkStateReq.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.NetworkStateReq} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.NetworkStateReq.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    gameid: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    roomid: jspb.Message.getFieldWithDefault(msg, 2, "0"),
                    userid: jspb.Message.getFieldWithDefault(msg, 3, 0),
                    state: jspb.Message.getFieldWithDefault(msg, 4, 0)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.NetworkStateReq}
         */
        proto.stream.NetworkStateReq.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.NetworkStateReq();
            return proto.stream.NetworkStateReq.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.NetworkStateReq} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.NetworkStateReq}
         */
        proto.stream.NetworkStateReq.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setGameid(value);
                        break;
                    case 2:
                        var value = /** @type {string} */reader.readUint64String();
                        msg.setRoomid(value);
                        break;
                    case 3:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setUserid(value);
                        break;
                    case 4:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setState(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.NetworkStateReq.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.NetworkStateReq.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.NetworkStateReq} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.NetworkStateReq.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getGameid();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
            f = message.getRoomid();
            if (parseInt(f, 10) !== 0) {
                writer.writeUint64String(2, f);
            }
            f = message.getUserid();
            if (f !== 0) {
                writer.writeUint32(3, f);
            }
            f = message.getState();
            if (f !== 0) {
                writer.writeUint32(4, f);
            }
        };

        /**
         * optional uint32 gameID = 1;
         * @return {number}
         */
        proto.stream.NetworkStateReq.prototype.getGameid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.NetworkStateReq.prototype.setGameid = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * optional uint64 roomID = 2;
         * @return {string}
         */
        proto.stream.NetworkStateReq.prototype.getRoomid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 2, "0")
            );
        };

        /** @param {string} value */
        proto.stream.NetworkStateReq.prototype.setRoomid = function (value) {
            jspb.Message.setProto3StringIntField(this, 2, value);
        };

        /**
         * optional uint32 UserID = 3;
         * @return {number}
         */
        proto.stream.NetworkStateReq.prototype.getUserid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 3, 0)
            );
        };

        /** @param {number} value */
        proto.stream.NetworkStateReq.prototype.setUserid = function (value) {
            jspb.Message.setProto3IntField(this, 3, value);
        };

        /**
         * optional uint32 state = 4;
         * @return {number}
         */
        proto.stream.NetworkStateReq.prototype.getState = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 4, 0)
            );
        };

        /** @param {number} value */
        proto.stream.NetworkStateReq.prototype.setState = function (value) {
            jspb.Message.setProto3IntField(this, 4, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.NetworkStateRsp = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.NetworkStateRsp, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.NetworkStateRsp.displayName = 'proto.stream.NetworkStateRsp';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.NetworkStateRsp.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.NetworkStateRsp.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.NetworkStateRsp} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.NetworkStateRsp.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    status: jspb.Message.getFieldWithDefault(msg, 1, 0)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.NetworkStateRsp}
         */
        proto.stream.NetworkStateRsp.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.NetworkStateRsp();
            return proto.stream.NetworkStateRsp.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.NetworkStateRsp} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.NetworkStateRsp}
         */
        proto.stream.NetworkStateRsp.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setStatus(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.NetworkStateRsp.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.NetworkStateRsp.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.NetworkStateRsp} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.NetworkStateRsp.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getStatus();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
        };

        /**
         * optional uint32 status = 1;
         * @return {number}
         */
        proto.stream.NetworkStateRsp.prototype.getStatus = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.NetworkStateRsp.prototype.setStatus = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.NetworkStateNotify = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.NetworkStateNotify, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.NetworkStateNotify.displayName = 'proto.stream.NetworkStateNotify';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.NetworkStateNotify.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.NetworkStateNotify.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.NetworkStateNotify} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.NetworkStateNotify.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    roomid: jspb.Message.getFieldWithDefault(msg, 1, "0"),
                    userid: jspb.Message.getFieldWithDefault(msg, 2, 0),
                    state: jspb.Message.getFieldWithDefault(msg, 3, 0),
                    owner: jspb.Message.getFieldWithDefault(msg, 4, 0)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.NetworkStateNotify}
         */
        proto.stream.NetworkStateNotify.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.NetworkStateNotify();
            return proto.stream.NetworkStateNotify.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.NetworkStateNotify} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.NetworkStateNotify}
         */
        proto.stream.NetworkStateNotify.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {string} */reader.readUint64String();
                        msg.setRoomid(value);
                        break;
                    case 2:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setUserid(value);
                        break;
                    case 3:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setState(value);
                        break;
                    case 4:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setOwner(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.NetworkStateNotify.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.NetworkStateNotify.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.NetworkStateNotify} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.NetworkStateNotify.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getRoomid();
            if (parseInt(f, 10) !== 0) {
                writer.writeUint64String(1, f);
            }
            f = message.getUserid();
            if (f !== 0) {
                writer.writeUint32(2, f);
            }
            f = message.getState();
            if (f !== 0) {
                writer.writeUint32(3, f);
            }
            f = message.getOwner();
            if (f !== 0) {
                writer.writeUint32(4, f);
            }
        };

        /**
         * optional uint64 roomID = 1;
         * @return {string}
         */
        proto.stream.NetworkStateNotify.prototype.getRoomid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 1, "0")
            );
        };

        /** @param {string} value */
        proto.stream.NetworkStateNotify.prototype.setRoomid = function (value) {
            jspb.Message.setProto3StringIntField(this, 1, value);
        };

        /**
         * optional uint32 UserID = 2;
         * @return {number}
         */
        proto.stream.NetworkStateNotify.prototype.getUserid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 2, 0)
            );
        };

        /** @param {number} value */
        proto.stream.NetworkStateNotify.prototype.setUserid = function (value) {
            jspb.Message.setProto3IntField(this, 2, value);
        };

        /**
         * optional uint32 state = 3;
         * @return {number}
         */
        proto.stream.NetworkStateNotify.prototype.getState = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 3, 0)
            );
        };

        /** @param {number} value */
        proto.stream.NetworkStateNotify.prototype.setState = function (value) {
            jspb.Message.setProto3IntField(this, 3, value);
        };

        /**
         * optional uint32 owner = 4;
         * @return {number}
         */
        proto.stream.NetworkStateNotify.prototype.getOwner = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 4, 0)
            );
        };

        /** @param {number} value */
        proto.stream.NetworkStateNotify.prototype.setOwner = function (value) {
            jspb.Message.setProto3IntField(this, 4, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.CreateRoom = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.CreateRoom, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.CreateRoom.displayName = 'proto.stream.CreateRoom';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.CreateRoom.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.CreateRoom.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.CreateRoom} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.CreateRoom.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    playerinfo: (f = msg.getPlayerinfo()) && proto.stream.PlayerInfo.toObject(includeInstance, f),
                    gameid: jspb.Message.getFieldWithDefault(msg, 2, 0),
                    roominfo: (f = msg.getRoominfo()) && proto.stream.RoomInfo.toObject(includeInstance, f)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.CreateRoom}
         */
        proto.stream.CreateRoom.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.CreateRoom();
            return proto.stream.CreateRoom.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.CreateRoom} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.CreateRoom}
         */
        proto.stream.CreateRoom.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = new proto.stream.PlayerInfo();
                        reader.readMessage(value, proto.stream.PlayerInfo.deserializeBinaryFromReader);
                        msg.setPlayerinfo(value);
                        break;
                    case 2:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setGameid(value);
                        break;
                    case 3:
                        var value = new proto.stream.RoomInfo();
                        reader.readMessage(value, proto.stream.RoomInfo.deserializeBinaryFromReader);
                        msg.setRoominfo(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.CreateRoom.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.CreateRoom.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.CreateRoom} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.CreateRoom.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getPlayerinfo();
            if (f != null) {
                writer.writeMessage(1, f, proto.stream.PlayerInfo.serializeBinaryToWriter);
            }
            f = message.getGameid();
            if (f !== 0) {
                writer.writeUint32(2, f);
            }
            f = message.getRoominfo();
            if (f != null) {
                writer.writeMessage(3, f, proto.stream.RoomInfo.serializeBinaryToWriter);
            }
        };

        /**
         * optional PlayerInfo playerInfo = 1;
         * @return {?proto.stream.PlayerInfo}
         */
        proto.stream.CreateRoom.prototype.getPlayerinfo = function () {
            return (/** @type{?proto.stream.PlayerInfo} */jspb.Message.getWrapperField(this, proto.stream.PlayerInfo, 1)
            );
        };

        /** @param {?proto.stream.PlayerInfo|undefined} value */
        proto.stream.CreateRoom.prototype.setPlayerinfo = function (value) {
            jspb.Message.setWrapperField(this, 1, value);
        };

        proto.stream.CreateRoom.prototype.clearPlayerinfo = function () {
            this.setPlayerinfo(undefined);
        };

        /**
         * Returns whether this field is set.
         * @return {!boolean}
         */
        proto.stream.CreateRoom.prototype.hasPlayerinfo = function () {
            return jspb.Message.getField(this, 1) != null;
        };

        /**
         * optional uint32 gameID = 2;
         * @return {number}
         */
        proto.stream.CreateRoom.prototype.getGameid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 2, 0)
            );
        };

        /** @param {number} value */
        proto.stream.CreateRoom.prototype.setGameid = function (value) {
            jspb.Message.setProto3IntField(this, 2, value);
        };

        /**
         * optional RoomInfo roomInfo = 3;
         * @return {?proto.stream.RoomInfo}
         */
        proto.stream.CreateRoom.prototype.getRoominfo = function () {
            return (/** @type{?proto.stream.RoomInfo} */jspb.Message.getWrapperField(this, proto.stream.RoomInfo, 3)
            );
        };

        /** @param {?proto.stream.RoomInfo|undefined} value */
        proto.stream.CreateRoom.prototype.setRoominfo = function (value) {
            jspb.Message.setWrapperField(this, 3, value);
        };

        proto.stream.CreateRoom.prototype.clearRoominfo = function () {
            this.setRoominfo(undefined);
        };

        /**
         * Returns whether this field is set.
         * @return {!boolean}
         */
        proto.stream.CreateRoom.prototype.hasRoominfo = function () {
            return jspb.Message.getField(this, 3) != null;
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.CreateRoomRsp = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.CreateRoomRsp, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.CreateRoomRsp.displayName = 'proto.stream.CreateRoomRsp';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.CreateRoomRsp.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.CreateRoomRsp.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.CreateRoomRsp} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.CreateRoomRsp.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    status: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    roomid: jspb.Message.getFieldWithDefault(msg, 2, "0"),
                    bookinfo: (f = msg.getBookinfo()) && proto.stream.BookInfo.toObject(includeInstance, f),
                    owner: jspb.Message.getFieldWithDefault(msg, 4, 0)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.CreateRoomRsp}
         */
        proto.stream.CreateRoomRsp.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.CreateRoomRsp();
            return proto.stream.CreateRoomRsp.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.CreateRoomRsp} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.CreateRoomRsp}
         */
        proto.stream.CreateRoomRsp.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {!proto.stream.ErrorCode} */reader.readEnum();
                        msg.setStatus(value);
                        break;
                    case 2:
                        var value = /** @type {string} */reader.readUint64String();
                        msg.setRoomid(value);
                        break;
                    case 3:
                        var value = new proto.stream.BookInfo();
                        reader.readMessage(value, proto.stream.BookInfo.deserializeBinaryFromReader);
                        msg.setBookinfo(value);
                        break;
                    case 4:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setOwner(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.CreateRoomRsp.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.CreateRoomRsp.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.CreateRoomRsp} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.CreateRoomRsp.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getStatus();
            if (f !== 0.0) {
                writer.writeEnum(1, f);
            }
            f = message.getRoomid();
            if (parseInt(f, 10) !== 0) {
                writer.writeUint64String(2, f);
            }
            f = message.getBookinfo();
            if (f != null) {
                writer.writeMessage(3, f, proto.stream.BookInfo.serializeBinaryToWriter);
            }
            f = message.getOwner();
            if (f !== 0) {
                writer.writeUint32(4, f);
            }
        };

        /**
         * optional ErrorCode status = 1;
         * @return {!proto.stream.ErrorCode}
         */
        proto.stream.CreateRoomRsp.prototype.getStatus = function () {
            return (/** @type {!proto.stream.ErrorCode} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {!proto.stream.ErrorCode} value */
        proto.stream.CreateRoomRsp.prototype.setStatus = function (value) {
            jspb.Message.setProto3EnumField(this, 1, value);
        };

        /**
         * optional uint64 roomID = 2;
         * @return {string}
         */
        proto.stream.CreateRoomRsp.prototype.getRoomid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 2, "0")
            );
        };

        /** @param {string} value */
        proto.stream.CreateRoomRsp.prototype.setRoomid = function (value) {
            jspb.Message.setProto3StringIntField(this, 2, value);
        };

        /**
         * optional BookInfo bookInfo = 3;
         * @return {?proto.stream.BookInfo}
         */
        proto.stream.CreateRoomRsp.prototype.getBookinfo = function () {
            return (/** @type{?proto.stream.BookInfo} */jspb.Message.getWrapperField(this, proto.stream.BookInfo, 3)
            );
        };

        /** @param {?proto.stream.BookInfo|undefined} value */
        proto.stream.CreateRoomRsp.prototype.setBookinfo = function (value) {
            jspb.Message.setWrapperField(this, 3, value);
        };

        proto.stream.CreateRoomRsp.prototype.clearBookinfo = function () {
            this.setBookinfo(undefined);
        };

        /**
         * Returns whether this field is set.
         * @return {!boolean}
         */
        proto.stream.CreateRoomRsp.prototype.hasBookinfo = function () {
            return jspb.Message.getField(this, 3) != null;
        };

        /**
         * optional uint32 owner = 4;
         * @return {number}
         */
        proto.stream.CreateRoomRsp.prototype.getOwner = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 4, 0)
            );
        };

        /** @param {number} value */
        proto.stream.CreateRoomRsp.prototype.setOwner = function (value) {
            jspb.Message.setProto3IntField(this, 4, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.GetRoomList = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.GetRoomList, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.GetRoomList.displayName = 'proto.stream.GetRoomList';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.GetRoomList.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.GetRoomList.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.GetRoomList} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.GetRoomList.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    gameid: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    roomfilter: (f = msg.getRoomfilter()) && proto.stream.RoomFilter.toObject(includeInstance, f)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.GetRoomList}
         */
        proto.stream.GetRoomList.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.GetRoomList();
            return proto.stream.GetRoomList.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.GetRoomList} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.GetRoomList}
         */
        proto.stream.GetRoomList.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setGameid(value);
                        break;
                    case 2:
                        var value = new proto.stream.RoomFilter();
                        reader.readMessage(value, proto.stream.RoomFilter.deserializeBinaryFromReader);
                        msg.setRoomfilter(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.GetRoomList.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.GetRoomList.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.GetRoomList} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.GetRoomList.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getGameid();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
            f = message.getRoomfilter();
            if (f != null) {
                writer.writeMessage(2, f, proto.stream.RoomFilter.serializeBinaryToWriter);
            }
        };

        /**
         * optional uint32 gameID = 1;
         * @return {number}
         */
        proto.stream.GetRoomList.prototype.getGameid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.GetRoomList.prototype.setGameid = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * optional RoomFilter roomFilter = 2;
         * @return {?proto.stream.RoomFilter}
         */
        proto.stream.GetRoomList.prototype.getRoomfilter = function () {
            return (/** @type{?proto.stream.RoomFilter} */jspb.Message.getWrapperField(this, proto.stream.RoomFilter, 2)
            );
        };

        /** @param {?proto.stream.RoomFilter|undefined} value */
        proto.stream.GetRoomList.prototype.setRoomfilter = function (value) {
            jspb.Message.setWrapperField(this, 2, value);
        };

        proto.stream.GetRoomList.prototype.clearRoomfilter = function () {
            this.setRoomfilter(undefined);
        };

        /**
         * Returns whether this field is set.
         * @return {!boolean}
         */
        proto.stream.GetRoomList.prototype.hasRoomfilter = function () {
            return jspb.Message.getField(this, 2) != null;
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.RoomFilter = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.RoomFilter, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.RoomFilter.displayName = 'proto.stream.RoomFilter';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.RoomFilter.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.RoomFilter.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.RoomFilter} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.RoomFilter.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    maxplayer: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    mode: jspb.Message.getFieldWithDefault(msg, 2, 0),
                    canwatch: jspb.Message.getFieldWithDefault(msg, 3, 0),
                    roomproperty: msg.getRoomproperty_asB64()
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.RoomFilter}
         */
        proto.stream.RoomFilter.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.RoomFilter();
            return proto.stream.RoomFilter.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.RoomFilter} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.RoomFilter}
         */
        proto.stream.RoomFilter.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setMaxplayer(value);
                        break;
                    case 2:
                        var value = /** @type {number} */reader.readInt32();
                        msg.setMode(value);
                        break;
                    case 3:
                        var value = /** @type {number} */reader.readInt32();
                        msg.setCanwatch(value);
                        break;
                    case 4:
                        var value = /** @type {!Uint8Array} */reader.readBytes();
                        msg.setRoomproperty(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.RoomFilter.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.RoomFilter.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.RoomFilter} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.RoomFilter.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getMaxplayer();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
            f = message.getMode();
            if (f !== 0) {
                writer.writeInt32(2, f);
            }
            f = message.getCanwatch();
            if (f !== 0) {
                writer.writeInt32(3, f);
            }
            f = message.getRoomproperty_asU8();
            if (f.length > 0) {
                writer.writeBytes(4, f);
            }
        };

        /**
         * optional uint32 maxPlayer = 1;
         * @return {number}
         */
        proto.stream.RoomFilter.prototype.getMaxplayer = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.RoomFilter.prototype.setMaxplayer = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * optional int32 mode = 2;
         * @return {number}
         */
        proto.stream.RoomFilter.prototype.getMode = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 2, 0)
            );
        };

        /** @param {number} value */
        proto.stream.RoomFilter.prototype.setMode = function (value) {
            jspb.Message.setProto3IntField(this, 2, value);
        };

        /**
         * optional int32 canWatch = 3;
         * @return {number}
         */
        proto.stream.RoomFilter.prototype.getCanwatch = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 3, 0)
            );
        };

        /** @param {number} value */
        proto.stream.RoomFilter.prototype.setCanwatch = function (value) {
            jspb.Message.setProto3IntField(this, 3, value);
        };

        /**
         * optional bytes roomProperty = 4;
         * @return {!(string|Uint8Array)}
         */
        proto.stream.RoomFilter.prototype.getRoomproperty = function () {
            return (/** @type {!(string|Uint8Array)} */jspb.Message.getFieldWithDefault(this, 4, "")
            );
        };

        /**
         * optional bytes roomProperty = 4;
         * This is a type-conversion wrapper around `getRoomproperty()`
         * @return {string}
         */
        proto.stream.RoomFilter.prototype.getRoomproperty_asB64 = function () {
            return (/** @type {string} */jspb.Message.bytesAsB64(this.getRoomproperty())
            );
        };

        /**
         * optional bytes roomProperty = 4;
         * Note that Uint8Array is not supported on all browsers.
         * @see http://caniuse.com/Uint8Array
         * This is a type-conversion wrapper around `getRoomproperty()`
         * @return {!Uint8Array}
         */
        proto.stream.RoomFilter.prototype.getRoomproperty_asU8 = function () {
            return (/** @type {!Uint8Array} */jspb.Message.bytesAsU8(this.getRoomproperty())
            );
        };

        /** @param {!(string|Uint8Array)} value */
        proto.stream.RoomFilter.prototype.setRoomproperty = function (value) {
            jspb.Message.setProto3BytesField(this, 4, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.GetRoomListRsp = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, proto.stream.GetRoomListRsp.repeatedFields_, null);
        };
        goog.inherits(proto.stream.GetRoomListRsp, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.GetRoomListRsp.displayName = 'proto.stream.GetRoomListRsp';
        }
        /**
         * List of repeated fields within this message type.
         * @private {!Array<number>}
         * @const
         */
        proto.stream.GetRoomListRsp.repeatedFields_ = [2];

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.GetRoomListRsp.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.GetRoomListRsp.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.GetRoomListRsp} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.GetRoomListRsp.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    status: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    roominfoList: jspb.Message.toObjectList(msg.getRoominfoList(), proto.stream.RoomInfo.toObject, includeInstance)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.GetRoomListRsp}
         */
        proto.stream.GetRoomListRsp.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.GetRoomListRsp();
            return proto.stream.GetRoomListRsp.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.GetRoomListRsp} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.GetRoomListRsp}
         */
        proto.stream.GetRoomListRsp.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {!proto.stream.ErrorCode} */reader.readEnum();
                        msg.setStatus(value);
                        break;
                    case 2:
                        var value = new proto.stream.RoomInfo();
                        reader.readMessage(value, proto.stream.RoomInfo.deserializeBinaryFromReader);
                        msg.addRoominfo(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.GetRoomListRsp.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.GetRoomListRsp.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.GetRoomListRsp} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.GetRoomListRsp.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getStatus();
            if (f !== 0.0) {
                writer.writeEnum(1, f);
            }
            f = message.getRoominfoList();
            if (f.length > 0) {
                writer.writeRepeatedMessage(2, f, proto.stream.RoomInfo.serializeBinaryToWriter);
            }
        };

        /**
         * optional ErrorCode status = 1;
         * @return {!proto.stream.ErrorCode}
         */
        proto.stream.GetRoomListRsp.prototype.getStatus = function () {
            return (/** @type {!proto.stream.ErrorCode} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {!proto.stream.ErrorCode} value */
        proto.stream.GetRoomListRsp.prototype.setStatus = function (value) {
            jspb.Message.setProto3EnumField(this, 1, value);
        };

        /**
         * repeated RoomInfo roomInfo = 2;
         * @return {!Array.<!proto.stream.RoomInfo>}
         */
        proto.stream.GetRoomListRsp.prototype.getRoominfoList = function () {
            return (/** @type{!Array.<!proto.stream.RoomInfo>} */jspb.Message.getRepeatedWrapperField(this, proto.stream.RoomInfo, 2)
            );
        };

        /** @param {!Array.<!proto.stream.RoomInfo>} value */
        proto.stream.GetRoomListRsp.prototype.setRoominfoList = function (value) {
            jspb.Message.setRepeatedWrapperField(this, 2, value);
        };

        /**
         * @param {!proto.stream.RoomInfo=} opt_value
         * @param {number=} opt_index
         * @return {!proto.stream.RoomInfo}
         */
        proto.stream.GetRoomListRsp.prototype.addRoominfo = function (opt_value, opt_index) {
            return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.stream.RoomInfo, opt_index);
        };

        proto.stream.GetRoomListRsp.prototype.clearRoominfoList = function () {
            this.setRoominfoList([]);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.KickPlayer = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.KickPlayer, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.KickPlayer.displayName = 'proto.stream.KickPlayer';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.KickPlayer.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.KickPlayer.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.KickPlayer} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.KickPlayer.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    roomid: jspb.Message.getFieldWithDefault(msg, 1, "0"),
                    srcuserid: jspb.Message.getFieldWithDefault(msg, 2, 0),
                    userid: jspb.Message.getFieldWithDefault(msg, 3, 0),
                    cpproto: msg.getCpproto_asB64()
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.KickPlayer}
         */
        proto.stream.KickPlayer.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.KickPlayer();
            return proto.stream.KickPlayer.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.KickPlayer} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.KickPlayer}
         */
        proto.stream.KickPlayer.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {string} */reader.readUint64String();
                        msg.setRoomid(value);
                        break;
                    case 2:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setSrcuserid(value);
                        break;
                    case 3:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setUserid(value);
                        break;
                    case 4:
                        var value = /** @type {!Uint8Array} */reader.readBytes();
                        msg.setCpproto(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.KickPlayer.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.KickPlayer.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.KickPlayer} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.KickPlayer.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getRoomid();
            if (parseInt(f, 10) !== 0) {
                writer.writeUint64String(1, f);
            }
            f = message.getSrcuserid();
            if (f !== 0) {
                writer.writeUint32(2, f);
            }
            f = message.getUserid();
            if (f !== 0) {
                writer.writeUint32(3, f);
            }
            f = message.getCpproto_asU8();
            if (f.length > 0) {
                writer.writeBytes(4, f);
            }
        };

        /**
         * optional uint64 roomID = 1;
         * @return {string}
         */
        proto.stream.KickPlayer.prototype.getRoomid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 1, "0")
            );
        };

        /** @param {string} value */
        proto.stream.KickPlayer.prototype.setRoomid = function (value) {
            jspb.Message.setProto3StringIntField(this, 1, value);
        };

        /**
         * optional uint32 srcUserID = 2;
         * @return {number}
         */
        proto.stream.KickPlayer.prototype.getSrcuserid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 2, 0)
            );
        };

        /** @param {number} value */
        proto.stream.KickPlayer.prototype.setSrcuserid = function (value) {
            jspb.Message.setProto3IntField(this, 2, value);
        };

        /**
         * optional uint32 userID = 3;
         * @return {number}
         */
        proto.stream.KickPlayer.prototype.getUserid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 3, 0)
            );
        };

        /** @param {number} value */
        proto.stream.KickPlayer.prototype.setUserid = function (value) {
            jspb.Message.setProto3IntField(this, 3, value);
        };

        /**
         * optional bytes cpProto = 4;
         * @return {!(string|Uint8Array)}
         */
        proto.stream.KickPlayer.prototype.getCpproto = function () {
            return (/** @type {!(string|Uint8Array)} */jspb.Message.getFieldWithDefault(this, 4, "")
            );
        };

        /**
         * optional bytes cpProto = 4;
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {string}
         */
        proto.stream.KickPlayer.prototype.getCpproto_asB64 = function () {
            return (/** @type {string} */jspb.Message.bytesAsB64(this.getCpproto())
            );
        };

        /**
         * optional bytes cpProto = 4;
         * Note that Uint8Array is not supported on all browsers.
         * @see http://caniuse.com/Uint8Array
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {!Uint8Array}
         */
        proto.stream.KickPlayer.prototype.getCpproto_asU8 = function () {
            return (/** @type {!Uint8Array} */jspb.Message.bytesAsU8(this.getCpproto())
            );
        };

        /** @param {!(string|Uint8Array)} value */
        proto.stream.KickPlayer.prototype.setCpproto = function (value) {
            jspb.Message.setProto3BytesField(this, 4, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.KickPlayerRsp = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.KickPlayerRsp, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.KickPlayerRsp.displayName = 'proto.stream.KickPlayerRsp';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.KickPlayerRsp.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.KickPlayerRsp.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.KickPlayerRsp} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.KickPlayerRsp.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    status: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    userid: jspb.Message.getFieldWithDefault(msg, 2, 0),
                    roomid: jspb.Message.getFieldWithDefault(msg, 3, "0"),
                    owner: jspb.Message.getFieldWithDefault(msg, 4, 0)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.KickPlayerRsp}
         */
        proto.stream.KickPlayerRsp.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.KickPlayerRsp();
            return proto.stream.KickPlayerRsp.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.KickPlayerRsp} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.KickPlayerRsp}
         */
        proto.stream.KickPlayerRsp.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {!proto.stream.ErrorCode} */reader.readEnum();
                        msg.setStatus(value);
                        break;
                    case 2:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setUserid(value);
                        break;
                    case 3:
                        var value = /** @type {string} */reader.readUint64String();
                        msg.setRoomid(value);
                        break;
                    case 4:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setOwner(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.KickPlayerRsp.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.KickPlayerRsp.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.KickPlayerRsp} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.KickPlayerRsp.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getStatus();
            if (f !== 0.0) {
                writer.writeEnum(1, f);
            }
            f = message.getUserid();
            if (f !== 0) {
                writer.writeUint32(2, f);
            }
            f = message.getRoomid();
            if (parseInt(f, 10) !== 0) {
                writer.writeUint64String(3, f);
            }
            f = message.getOwner();
            if (f !== 0) {
                writer.writeUint32(4, f);
            }
        };

        /**
         * optional ErrorCode status = 1;
         * @return {!proto.stream.ErrorCode}
         */
        proto.stream.KickPlayerRsp.prototype.getStatus = function () {
            return (/** @type {!proto.stream.ErrorCode} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {!proto.stream.ErrorCode} value */
        proto.stream.KickPlayerRsp.prototype.setStatus = function (value) {
            jspb.Message.setProto3EnumField(this, 1, value);
        };

        /**
         * optional uint32 userID = 2;
         * @return {number}
         */
        proto.stream.KickPlayerRsp.prototype.getUserid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 2, 0)
            );
        };

        /** @param {number} value */
        proto.stream.KickPlayerRsp.prototype.setUserid = function (value) {
            jspb.Message.setProto3IntField(this, 2, value);
        };

        /**
         * optional uint64 roomID = 3;
         * @return {string}
         */
        proto.stream.KickPlayerRsp.prototype.getRoomid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 3, "0")
            );
        };

        /** @param {string} value */
        proto.stream.KickPlayerRsp.prototype.setRoomid = function (value) {
            jspb.Message.setProto3StringIntField(this, 3, value);
        };

        /**
         * optional uint32 owner = 4;
         * @return {number}
         */
        proto.stream.KickPlayerRsp.prototype.getOwner = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 4, 0)
            );
        };

        /** @param {number} value */
        proto.stream.KickPlayerRsp.prototype.setOwner = function (value) {
            jspb.Message.setProto3IntField(this, 4, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.KickPlayerNotify = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.KickPlayerNotify, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.KickPlayerNotify.displayName = 'proto.stream.KickPlayerNotify';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.KickPlayerNotify.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.KickPlayerNotify.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.KickPlayerNotify} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.KickPlayerNotify.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    srcuserid: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    userid: jspb.Message.getFieldWithDefault(msg, 2, 0),
                    cpproto: msg.getCpproto_asB64(),
                    owner: jspb.Message.getFieldWithDefault(msg, 4, 0)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.KickPlayerNotify}
         */
        proto.stream.KickPlayerNotify.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.KickPlayerNotify();
            return proto.stream.KickPlayerNotify.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.KickPlayerNotify} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.KickPlayerNotify}
         */
        proto.stream.KickPlayerNotify.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setSrcuserid(value);
                        break;
                    case 2:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setUserid(value);
                        break;
                    case 3:
                        var value = /** @type {!Uint8Array} */reader.readBytes();
                        msg.setCpproto(value);
                        break;
                    case 4:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setOwner(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.KickPlayerNotify.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.KickPlayerNotify.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.KickPlayerNotify} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.KickPlayerNotify.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getSrcuserid();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
            f = message.getUserid();
            if (f !== 0) {
                writer.writeUint32(2, f);
            }
            f = message.getCpproto_asU8();
            if (f.length > 0) {
                writer.writeBytes(3, f);
            }
            f = message.getOwner();
            if (f !== 0) {
                writer.writeUint32(4, f);
            }
        };

        /**
         * optional uint32 srcUserID = 1;
         * @return {number}
         */
        proto.stream.KickPlayerNotify.prototype.getSrcuserid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.KickPlayerNotify.prototype.setSrcuserid = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * optional uint32 userID = 2;
         * @return {number}
         */
        proto.stream.KickPlayerNotify.prototype.getUserid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 2, 0)
            );
        };

        /** @param {number} value */
        proto.stream.KickPlayerNotify.prototype.setUserid = function (value) {
            jspb.Message.setProto3IntField(this, 2, value);
        };

        /**
         * optional bytes cpProto = 3;
         * @return {!(string|Uint8Array)}
         */
        proto.stream.KickPlayerNotify.prototype.getCpproto = function () {
            return (/** @type {!(string|Uint8Array)} */jspb.Message.getFieldWithDefault(this, 3, "")
            );
        };

        /**
         * optional bytes cpProto = 3;
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {string}
         */
        proto.stream.KickPlayerNotify.prototype.getCpproto_asB64 = function () {
            return (/** @type {string} */jspb.Message.bytesAsB64(this.getCpproto())
            );
        };

        /**
         * optional bytes cpProto = 3;
         * Note that Uint8Array is not supported on all browsers.
         * @see http://caniuse.com/Uint8Array
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {!Uint8Array}
         */
        proto.stream.KickPlayerNotify.prototype.getCpproto_asU8 = function () {
            return (/** @type {!Uint8Array} */jspb.Message.bytesAsU8(this.getCpproto())
            );
        };

        /** @param {!(string|Uint8Array)} value */
        proto.stream.KickPlayerNotify.prototype.setCpproto = function (value) {
            jspb.Message.setProto3BytesField(this, 3, value);
        };

        /**
         * optional uint32 owner = 4;
         * @return {number}
         */
        proto.stream.KickPlayerNotify.prototype.getOwner = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 4, 0)
            );
        };

        /** @param {number} value */
        proto.stream.KickPlayerNotify.prototype.setOwner = function (value) {
            jspb.Message.setProto3IntField(this, 4, value);
        };

        /**
         * @enum {number}
         */
        proto.stream.CmdId = {
            NOCMD: 0,
            LOGINREQ: 1101,
            LOGINRSP: 1102,
            LOGOUTREQ: 1105,
            LOGOUTRSP: 1106,
            HEARTBEATREQ: 1103,
            NETWORKSTATEREQ: 1120,
            NETWORKSTATERSP: 1121,
            NOTICENETWORKSTATEREQ: 1122,
            CREATEROOMREQ: 1203,
            CREATEROOMRSP: 1204,
            GETROOMLISTREQ: 1207,
            GETROOMLISTRSP: 1208,
            JOINROOMREQ: 1201,
            JOINROOMRSP: 1202,
            NOTICEUSERJOINREQ: 1301,
            LEAVEROOMREQ: 1205,
            LEAVEROOMRSP: 1206,
            NOTICEUSERLEAVEREQ: 1302,
            JOINOVERREQ: 1213,
            JOINOVERRSP: 1214,
            DISCONNECTREQ: 1107,
            DISCONNECTRSP: 1108,
            KICKPLAYERREQ: 1303,
            KICKPLAYERRSP: 1304,
            KICKPLAYERNOTIFY: 1305
        };

        /**
         * @enum {number}
         */
        proto.stream.JoinRoomType = {
            NOJOIN: 0,
            JOINSPECIALROOM: 1,
            JOINROOMWITHPROPERTY: 2,
            JOINRANDOMROOM: 3
        };

        goog.object.extend(exports, proto.stream);
    }, { "./errorcode_pb.js": 2, "google-protobuf": 1 }], 5: [function (_require, module, exports) {
        /**
         * @fileoverview
         * @enhanceable
         * @suppress {messageConventions} JS Compiler reports an error if a variable or
         *     field starts with 'MSG_' and isn't a translatable message.
         * @public
         */
        // GENERATED CODE -- DO NOT EDIT!

        var jspb = _require('google-protobuf');
        var goog = jspb;
        var global = Function('return this')();

        goog.exportSymbol('proto.stream.Broadcast', null, global);
        goog.exportSymbol('proto.stream.BroadcastAck', null, global);
        goog.exportSymbol('proto.stream.CheckIn', null, global);
        goog.exportSymbol('proto.stream.CheckInAck', null, global);
        goog.exportSymbol('proto.stream.CheckInNotify', null, global);
        goog.exportSymbol('proto.stream.Heartbeat', null, global);
        goog.exportSymbol('proto.stream.HeartbeatAck', null, global);
        goog.exportSymbol('proto.stream.Notify', null, global);
        goog.exportSymbol('proto.stream.Publish', null, global);
        goog.exportSymbol('proto.stream.PublishAck', null, global);
        goog.exportSymbol('proto.stream.PublishNotify', null, global);
        goog.exportSymbol('proto.stream.SDKHotelCmdID', null, global);
        goog.exportSymbol('proto.stream.Subscribe', null, global);
        goog.exportSymbol('proto.stream.SubscribeAck', null, global);

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.CheckIn = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.CheckIn, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.CheckIn.displayName = 'proto.stream.CheckIn';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.CheckIn.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.CheckIn.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.CheckIn} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.CheckIn.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    gameid: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    roomid: jspb.Message.getFieldWithDefault(msg, 2, "0"),
                    userid: jspb.Message.getFieldWithDefault(msg, 3, 0),
                    bookid: jspb.Message.getFieldWithDefault(msg, 4, ""),
                    key: jspb.Message.getFieldWithDefault(msg, 5, "")
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.CheckIn}
         */
        proto.stream.CheckIn.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.CheckIn();
            return proto.stream.CheckIn.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.CheckIn} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.CheckIn}
         */
        proto.stream.CheckIn.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setGameid(value);
                        break;
                    case 2:
                        var value = /** @type {string} */reader.readUint64String();
                        msg.setRoomid(value);
                        break;
                    case 3:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setUserid(value);
                        break;
                    case 4:
                        var value = /** @type {string} */reader.readString();
                        msg.setBookid(value);
                        break;
                    case 5:
                        var value = /** @type {string} */reader.readString();
                        msg.setKey(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.CheckIn.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.CheckIn.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.CheckIn} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.CheckIn.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getGameid();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
            f = message.getRoomid();
            if (parseInt(f, 10) !== 0) {
                writer.writeUint64String(2, f);
            }
            f = message.getUserid();
            if (f !== 0) {
                writer.writeUint32(3, f);
            }
            f = message.getBookid();
            if (f.length > 0) {
                writer.writeString(4, f);
            }
            f = message.getKey();
            if (f.length > 0) {
                writer.writeString(5, f);
            }
        };

        /**
         * optional uint32 gameID = 1;
         * @return {number}
         */
        proto.stream.CheckIn.prototype.getGameid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.CheckIn.prototype.setGameid = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * optional uint64 roomID = 2;
         * @return {string}
         */
        proto.stream.CheckIn.prototype.getRoomid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 2, "0")
            );
        };

        /** @param {string} value */
        proto.stream.CheckIn.prototype.setRoomid = function (value) {
            jspb.Message.setProto3StringIntField(this, 2, value);
        };

        /**
         * optional uint32 userID = 3;
         * @return {number}
         */
        proto.stream.CheckIn.prototype.getUserid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 3, 0)
            );
        };

        /** @param {number} value */
        proto.stream.CheckIn.prototype.setUserid = function (value) {
            jspb.Message.setProto3IntField(this, 3, value);
        };

        /**
         * optional string bookID = 4;
         * @return {string}
         */
        proto.stream.CheckIn.prototype.getBookid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 4, "")
            );
        };

        /** @param {string} value */
        proto.stream.CheckIn.prototype.setBookid = function (value) {
            jspb.Message.setProto3StringField(this, 4, value);
        };

        /**
         * optional string key = 5;
         * @return {string}
         */
        proto.stream.CheckIn.prototype.getKey = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 5, "")
            );
        };

        /** @param {string} value */
        proto.stream.CheckIn.prototype.setKey = function (value) {
            jspb.Message.setProto3StringField(this, 5, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.CheckInAck = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, proto.stream.CheckInAck.repeatedFields_, null);
        };
        goog.inherits(proto.stream.CheckInAck, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.CheckInAck.displayName = 'proto.stream.CheckInAck';
        }
        /**
         * List of repeated fields within this message type.
         * @private {!Array<number>}
         * @const
         */
        proto.stream.CheckInAck.repeatedFields_ = [3, 4];

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.CheckInAck.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.CheckInAck.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.CheckInAck} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.CheckInAck.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    status: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    bookid: jspb.Message.getFieldWithDefault(msg, 2, ""),
                    checkinsList: jspb.Message.getRepeatedField(msg, 3),
                    playersList: jspb.Message.getRepeatedField(msg, 4),
                    maxplayers: jspb.Message.getFieldWithDefault(msg, 5, 0)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.CheckInAck}
         */
        proto.stream.CheckInAck.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.CheckInAck();
            return proto.stream.CheckInAck.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.CheckInAck} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.CheckInAck}
         */
        proto.stream.CheckInAck.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setStatus(value);
                        break;
                    case 2:
                        var value = /** @type {string} */reader.readString();
                        msg.setBookid(value);
                        break;
                    case 3:
                        var value = /** @type {!Array.<number>} */reader.readPackedUint32();
                        msg.setCheckinsList(value);
                        break;
                    case 4:
                        var value = /** @type {!Array.<number>} */reader.readPackedUint32();
                        msg.setPlayersList(value);
                        break;
                    case 5:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setMaxplayers(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.CheckInAck.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.CheckInAck.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.CheckInAck} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.CheckInAck.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getStatus();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
            f = message.getBookid();
            if (f.length > 0) {
                writer.writeString(2, f);
            }
            f = message.getCheckinsList();
            if (f.length > 0) {
                writer.writePackedUint32(3, f);
            }
            f = message.getPlayersList();
            if (f.length > 0) {
                writer.writePackedUint32(4, f);
            }
            f = message.getMaxplayers();
            if (f !== 0) {
                writer.writeUint32(5, f);
            }
        };

        /**
         * optional uint32 status = 1;
         * @return {number}
         */
        proto.stream.CheckInAck.prototype.getStatus = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.CheckInAck.prototype.setStatus = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * optional string bookID = 2;
         * @return {string}
         */
        proto.stream.CheckInAck.prototype.getBookid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 2, "")
            );
        };

        /** @param {string} value */
        proto.stream.CheckInAck.prototype.setBookid = function (value) {
            jspb.Message.setProto3StringField(this, 2, value);
        };

        /**
         * repeated uint32 checkins = 3;
         * @return {!Array.<number>}
         */
        proto.stream.CheckInAck.prototype.getCheckinsList = function () {
            return (/** @type {!Array.<number>} */jspb.Message.getRepeatedField(this, 3)
            );
        };

        /** @param {!Array.<number>} value */
        proto.stream.CheckInAck.prototype.setCheckinsList = function (value) {
            jspb.Message.setField(this, 3, value || []);
        };

        /**
         * @param {!number} value
         * @param {number=} opt_index
         */
        proto.stream.CheckInAck.prototype.addCheckins = function (value, opt_index) {
            jspb.Message.addToRepeatedField(this, 3, value, opt_index);
        };

        proto.stream.CheckInAck.prototype.clearCheckinsList = function () {
            this.setCheckinsList([]);
        };

        /**
         * repeated uint32 players = 4;
         * @return {!Array.<number>}
         */
        proto.stream.CheckInAck.prototype.getPlayersList = function () {
            return (/** @type {!Array.<number>} */jspb.Message.getRepeatedField(this, 4)
            );
        };

        /** @param {!Array.<number>} value */
        proto.stream.CheckInAck.prototype.setPlayersList = function (value) {
            jspb.Message.setField(this, 4, value || []);
        };

        /**
         * @param {!number} value
         * @param {number=} opt_index
         */
        proto.stream.CheckInAck.prototype.addPlayers = function (value, opt_index) {
            jspb.Message.addToRepeatedField(this, 4, value, opt_index);
        };

        proto.stream.CheckInAck.prototype.clearPlayersList = function () {
            this.setPlayersList([]);
        };

        /**
         * optional uint32 maxPlayers = 5;
         * @return {number}
         */
        proto.stream.CheckInAck.prototype.getMaxplayers = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 5, 0)
            );
        };

        /** @param {number} value */
        proto.stream.CheckInAck.prototype.setMaxplayers = function (value) {
            jspb.Message.setProto3IntField(this, 5, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.Heartbeat = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.Heartbeat, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.Heartbeat.displayName = 'proto.stream.Heartbeat';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.Heartbeat.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.Heartbeat.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.Heartbeat} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.Heartbeat.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    gameid: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    roomid: jspb.Message.getFieldWithDefault(msg, 2, "0"),
                    userid: jspb.Message.getFieldWithDefault(msg, 3, 0)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.Heartbeat}
         */
        proto.stream.Heartbeat.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.Heartbeat();
            return proto.stream.Heartbeat.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.Heartbeat} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.Heartbeat}
         */
        proto.stream.Heartbeat.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setGameid(value);
                        break;
                    case 2:
                        var value = /** @type {string} */reader.readUint64String();
                        msg.setRoomid(value);
                        break;
                    case 3:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setUserid(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.Heartbeat.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.Heartbeat.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.Heartbeat} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.Heartbeat.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getGameid();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
            f = message.getRoomid();
            if (parseInt(f, 10) !== 0) {
                writer.writeUint64String(2, f);
            }
            f = message.getUserid();
            if (f !== 0) {
                writer.writeUint32(3, f);
            }
        };

        /**
         * optional uint32 gameID = 1;
         * @return {number}
         */
        proto.stream.Heartbeat.prototype.getGameid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.Heartbeat.prototype.setGameid = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * optional uint64 roomID = 2;
         * @return {string}
         */
        proto.stream.Heartbeat.prototype.getRoomid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 2, "0")
            );
        };

        /** @param {string} value */
        proto.stream.Heartbeat.prototype.setRoomid = function (value) {
            jspb.Message.setProto3StringIntField(this, 2, value);
        };

        /**
         * optional uint32 userID = 3;
         * @return {number}
         */
        proto.stream.Heartbeat.prototype.getUserid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 3, 0)
            );
        };

        /** @param {number} value */
        proto.stream.Heartbeat.prototype.setUserid = function (value) {
            jspb.Message.setProto3IntField(this, 3, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.HeartbeatAck = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.HeartbeatAck, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.HeartbeatAck.displayName = 'proto.stream.HeartbeatAck';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.HeartbeatAck.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.HeartbeatAck.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.HeartbeatAck} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.HeartbeatAck.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    status: jspb.Message.getFieldWithDefault(msg, 1, 0)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.HeartbeatAck}
         */
        proto.stream.HeartbeatAck.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.HeartbeatAck();
            return proto.stream.HeartbeatAck.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.HeartbeatAck} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.HeartbeatAck}
         */
        proto.stream.HeartbeatAck.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setStatus(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.HeartbeatAck.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.HeartbeatAck.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.HeartbeatAck} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.HeartbeatAck.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getStatus();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
        };

        /**
         * optional uint32 status = 1;
         * @return {number}
         */
        proto.stream.HeartbeatAck.prototype.getStatus = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.HeartbeatAck.prototype.setStatus = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.Broadcast = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, proto.stream.Broadcast.repeatedFields_, null);
        };
        goog.inherits(proto.stream.Broadcast, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.Broadcast.displayName = 'proto.stream.Broadcast';
        }
        /**
         * List of repeated fields within this message type.
         * @private {!Array<number>}
         * @const
         */
        proto.stream.Broadcast.repeatedFields_ = [3];

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.Broadcast.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.Broadcast.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.Broadcast} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.Broadcast.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    roomid: jspb.Message.getFieldWithDefault(msg, 1, "0"),
                    flag: jspb.Message.getFieldWithDefault(msg, 2, 0),
                    dstuidsList: jspb.Message.getRepeatedField(msg, 3),
                    cpproto: msg.getCpproto_asB64()
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.Broadcast}
         */
        proto.stream.Broadcast.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.Broadcast();
            return proto.stream.Broadcast.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.Broadcast} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.Broadcast}
         */
        proto.stream.Broadcast.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {string} */reader.readUint64String();
                        msg.setRoomid(value);
                        break;
                    case 2:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setFlag(value);
                        break;
                    case 3:
                        var value = /** @type {!Array.<number>} */reader.readPackedUint32();
                        msg.setDstuidsList(value);
                        break;
                    case 4:
                        var value = /** @type {!Uint8Array} */reader.readBytes();
                        msg.setCpproto(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.Broadcast.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.Broadcast.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.Broadcast} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.Broadcast.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getRoomid();
            if (parseInt(f, 10) !== 0) {
                writer.writeUint64String(1, f);
            }
            f = message.getFlag();
            if (f !== 0) {
                writer.writeUint32(2, f);
            }
            f = message.getDstuidsList();
            if (f.length > 0) {
                writer.writePackedUint32(3, f);
            }
            f = message.getCpproto_asU8();
            if (f.length > 0) {
                writer.writeBytes(4, f);
            }
        };

        /**
         * optional uint64 roomID = 1;
         * @return {string}
         */
        proto.stream.Broadcast.prototype.getRoomid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 1, "0")
            );
        };

        /** @param {string} value */
        proto.stream.Broadcast.prototype.setRoomid = function (value) {
            jspb.Message.setProto3StringIntField(this, 1, value);
        };

        /**
         * optional uint32 flag = 2;
         * @return {number}
         */
        proto.stream.Broadcast.prototype.getFlag = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 2, 0)
            );
        };

        /** @param {number} value */
        proto.stream.Broadcast.prototype.setFlag = function (value) {
            jspb.Message.setProto3IntField(this, 2, value);
        };

        /**
         * repeated uint32 dstUids = 3;
         * @return {!Array.<number>}
         */
        proto.stream.Broadcast.prototype.getDstuidsList = function () {
            return (/** @type {!Array.<number>} */jspb.Message.getRepeatedField(this, 3)
            );
        };

        /** @param {!Array.<number>} value */
        proto.stream.Broadcast.prototype.setDstuidsList = function (value) {
            jspb.Message.setField(this, 3, value || []);
        };

        /**
         * @param {!number} value
         * @param {number=} opt_index
         */
        proto.stream.Broadcast.prototype.addDstuids = function (value, opt_index) {
            jspb.Message.addToRepeatedField(this, 3, value, opt_index);
        };

        proto.stream.Broadcast.prototype.clearDstuidsList = function () {
            this.setDstuidsList([]);
        };

        /**
         * optional bytes cpProto = 4;
         * @return {!(string|Uint8Array)}
         */
        proto.stream.Broadcast.prototype.getCpproto = function () {
            return (/** @type {!(string|Uint8Array)} */jspb.Message.getFieldWithDefault(this, 4, "")
            );
        };

        /**
         * optional bytes cpProto = 4;
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {string}
         */
        proto.stream.Broadcast.prototype.getCpproto_asB64 = function () {
            return (/** @type {string} */jspb.Message.bytesAsB64(this.getCpproto())
            );
        };

        /**
         * optional bytes cpProto = 4;
         * Note that Uint8Array is not supported on all browsers.
         * @see http://caniuse.com/Uint8Array
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {!Uint8Array}
         */
        proto.stream.Broadcast.prototype.getCpproto_asU8 = function () {
            return (/** @type {!Uint8Array} */jspb.Message.bytesAsU8(this.getCpproto())
            );
        };

        /** @param {!(string|Uint8Array)} value */
        proto.stream.Broadcast.prototype.setCpproto = function (value) {
            jspb.Message.setProto3BytesField(this, 4, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.BroadcastAck = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.BroadcastAck, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.BroadcastAck.displayName = 'proto.stream.BroadcastAck';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.BroadcastAck.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.BroadcastAck.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.BroadcastAck} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.BroadcastAck.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    status: jspb.Message.getFieldWithDefault(msg, 1, 0)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.BroadcastAck}
         */
        proto.stream.BroadcastAck.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.BroadcastAck();
            return proto.stream.BroadcastAck.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.BroadcastAck} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.BroadcastAck}
         */
        proto.stream.BroadcastAck.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setStatus(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.BroadcastAck.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.BroadcastAck.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.BroadcastAck} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.BroadcastAck.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getStatus();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
        };

        /**
         * optional uint32 status = 1;
         * @return {number}
         */
        proto.stream.BroadcastAck.prototype.getStatus = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.BroadcastAck.prototype.setStatus = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.CheckInNotify = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, proto.stream.CheckInNotify.repeatedFields_, null);
        };
        goog.inherits(proto.stream.CheckInNotify, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.CheckInNotify.displayName = 'proto.stream.CheckInNotify';
        }
        /**
         * List of repeated fields within this message type.
         * @private {!Array<number>}
         * @const
         */
        proto.stream.CheckInNotify.repeatedFields_ = [3, 4];

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.CheckInNotify.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.CheckInNotify.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.CheckInNotify} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.CheckInNotify.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    userid: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    bookid: jspb.Message.getFieldWithDefault(msg, 2, ""),
                    checkinsList: jspb.Message.getRepeatedField(msg, 3),
                    playersList: jspb.Message.getRepeatedField(msg, 4),
                    maxplayers: jspb.Message.getFieldWithDefault(msg, 5, 0)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.CheckInNotify}
         */
        proto.stream.CheckInNotify.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.CheckInNotify();
            return proto.stream.CheckInNotify.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.CheckInNotify} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.CheckInNotify}
         */
        proto.stream.CheckInNotify.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setUserid(value);
                        break;
                    case 2:
                        var value = /** @type {string} */reader.readString();
                        msg.setBookid(value);
                        break;
                    case 3:
                        var value = /** @type {!Array.<number>} */reader.readPackedUint32();
                        msg.setCheckinsList(value);
                        break;
                    case 4:
                        var value = /** @type {!Array.<number>} */reader.readPackedUint32();
                        msg.setPlayersList(value);
                        break;
                    case 5:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setMaxplayers(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.CheckInNotify.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.CheckInNotify.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.CheckInNotify} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.CheckInNotify.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getUserid();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
            f = message.getBookid();
            if (f.length > 0) {
                writer.writeString(2, f);
            }
            f = message.getCheckinsList();
            if (f.length > 0) {
                writer.writePackedUint32(3, f);
            }
            f = message.getPlayersList();
            if (f.length > 0) {
                writer.writePackedUint32(4, f);
            }
            f = message.getMaxplayers();
            if (f !== 0) {
                writer.writeUint32(5, f);
            }
        };

        /**
         * optional uint32 userID = 1;
         * @return {number}
         */
        proto.stream.CheckInNotify.prototype.getUserid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.CheckInNotify.prototype.setUserid = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * optional string bookID = 2;
         * @return {string}
         */
        proto.stream.CheckInNotify.prototype.getBookid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 2, "")
            );
        };

        /** @param {string} value */
        proto.stream.CheckInNotify.prototype.setBookid = function (value) {
            jspb.Message.setProto3StringField(this, 2, value);
        };

        /**
         * repeated uint32 checkins = 3;
         * @return {!Array.<number>}
         */
        proto.stream.CheckInNotify.prototype.getCheckinsList = function () {
            return (/** @type {!Array.<number>} */jspb.Message.getRepeatedField(this, 3)
            );
        };

        /** @param {!Array.<number>} value */
        proto.stream.CheckInNotify.prototype.setCheckinsList = function (value) {
            jspb.Message.setField(this, 3, value || []);
        };

        /**
         * @param {!number} value
         * @param {number=} opt_index
         */
        proto.stream.CheckInNotify.prototype.addCheckins = function (value, opt_index) {
            jspb.Message.addToRepeatedField(this, 3, value, opt_index);
        };

        proto.stream.CheckInNotify.prototype.clearCheckinsList = function () {
            this.setCheckinsList([]);
        };

        /**
         * repeated uint32 players = 4;
         * @return {!Array.<number>}
         */
        proto.stream.CheckInNotify.prototype.getPlayersList = function () {
            return (/** @type {!Array.<number>} */jspb.Message.getRepeatedField(this, 4)
            );
        };

        /** @param {!Array.<number>} value */
        proto.stream.CheckInNotify.prototype.setPlayersList = function (value) {
            jspb.Message.setField(this, 4, value || []);
        };

        /**
         * @param {!number} value
         * @param {number=} opt_index
         */
        proto.stream.CheckInNotify.prototype.addPlayers = function (value, opt_index) {
            jspb.Message.addToRepeatedField(this, 4, value, opt_index);
        };

        proto.stream.CheckInNotify.prototype.clearPlayersList = function () {
            this.setPlayersList([]);
        };

        /**
         * optional uint32 maxPlayers = 5;
         * @return {number}
         */
        proto.stream.CheckInNotify.prototype.getMaxplayers = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 5, 0)
            );
        };

        /** @param {number} value */
        proto.stream.CheckInNotify.prototype.setMaxplayers = function (value) {
            jspb.Message.setProto3IntField(this, 5, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.Notify = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.Notify, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.Notify.displayName = 'proto.stream.Notify';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.Notify.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.Notify.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.Notify} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.Notify.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    srcuid: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    priority: jspb.Message.getFieldWithDefault(msg, 2, 0),
                    cpproto: msg.getCpproto_asB64()
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.Notify}
         */
        proto.stream.Notify.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.Notify();
            return proto.stream.Notify.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.Notify} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.Notify}
         */
        proto.stream.Notify.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setSrcuid(value);
                        break;
                    case 2:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setPriority(value);
                        break;
                    case 3:
                        var value = /** @type {!Uint8Array} */reader.readBytes();
                        msg.setCpproto(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.Notify.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.Notify.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.Notify} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.Notify.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getSrcuid();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
            f = message.getPriority();
            if (f !== 0) {
                writer.writeUint32(2, f);
            }
            f = message.getCpproto_asU8();
            if (f.length > 0) {
                writer.writeBytes(3, f);
            }
        };

        /**
         * optional uint32 srcUid = 1;
         * @return {number}
         */
        proto.stream.Notify.prototype.getSrcuid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.Notify.prototype.setSrcuid = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * optional uint32 priority = 2;
         * @return {number}
         */
        proto.stream.Notify.prototype.getPriority = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 2, 0)
            );
        };

        /** @param {number} value */
        proto.stream.Notify.prototype.setPriority = function (value) {
            jspb.Message.setProto3IntField(this, 2, value);
        };

        /**
         * optional bytes cpProto = 3;
         * @return {!(string|Uint8Array)}
         */
        proto.stream.Notify.prototype.getCpproto = function () {
            return (/** @type {!(string|Uint8Array)} */jspb.Message.getFieldWithDefault(this, 3, "")
            );
        };

        /**
         * optional bytes cpProto = 3;
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {string}
         */
        proto.stream.Notify.prototype.getCpproto_asB64 = function () {
            return (/** @type {string} */jspb.Message.bytesAsB64(this.getCpproto())
            );
        };

        /**
         * optional bytes cpProto = 3;
         * Note that Uint8Array is not supported on all browsers.
         * @see http://caniuse.com/Uint8Array
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {!Uint8Array}
         */
        proto.stream.Notify.prototype.getCpproto_asU8 = function () {
            return (/** @type {!Uint8Array} */jspb.Message.bytesAsU8(this.getCpproto())
            );
        };

        /** @param {!(string|Uint8Array)} value */
        proto.stream.Notify.prototype.setCpproto = function (value) {
            jspb.Message.setProto3BytesField(this, 3, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.Subscribe = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, proto.stream.Subscribe.repeatedFields_, null);
        };
        goog.inherits(proto.stream.Subscribe, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.Subscribe.displayName = 'proto.stream.Subscribe';
        }
        /**
         * List of repeated fields within this message type.
         * @private {!Array<number>}
         * @const
         */
        proto.stream.Subscribe.repeatedFields_ = [3, 4];

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.Subscribe.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.Subscribe.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.Subscribe} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.Subscribe.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    gameid: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    roomid: jspb.Message.getFieldWithDefault(msg, 2, "0"),
                    confirmsList: jspb.Message.getRepeatedField(msg, 3),
                    cancelsList: jspb.Message.getRepeatedField(msg, 4)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.Subscribe}
         */
        proto.stream.Subscribe.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.Subscribe();
            return proto.stream.Subscribe.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.Subscribe} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.Subscribe}
         */
        proto.stream.Subscribe.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setGameid(value);
                        break;
                    case 2:
                        var value = /** @type {string} */reader.readUint64String();
                        msg.setRoomid(value);
                        break;
                    case 3:
                        var value = /** @type {string} */reader.readString();
                        msg.addConfirms(value);
                        break;
                    case 4:
                        var value = /** @type {string} */reader.readString();
                        msg.addCancels(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.Subscribe.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.Subscribe.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.Subscribe} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.Subscribe.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getGameid();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
            f = message.getRoomid();
            if (parseInt(f, 10) !== 0) {
                writer.writeUint64String(2, f);
            }
            f = message.getConfirmsList();
            if (f.length > 0) {
                writer.writeRepeatedString(3, f);
            }
            f = message.getCancelsList();
            if (f.length > 0) {
                writer.writeRepeatedString(4, f);
            }
        };

        /**
         * optional uint32 gameID = 1;
         * @return {number}
         */
        proto.stream.Subscribe.prototype.getGameid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.Subscribe.prototype.setGameid = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * optional uint64 roomID = 2;
         * @return {string}
         */
        proto.stream.Subscribe.prototype.getRoomid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 2, "0")
            );
        };

        /** @param {string} value */
        proto.stream.Subscribe.prototype.setRoomid = function (value) {
            jspb.Message.setProto3StringIntField(this, 2, value);
        };

        /**
         * repeated string confirms = 3;
         * @return {!Array.<string>}
         */
        proto.stream.Subscribe.prototype.getConfirmsList = function () {
            return (/** @type {!Array.<string>} */jspb.Message.getRepeatedField(this, 3)
            );
        };

        /** @param {!Array.<string>} value */
        proto.stream.Subscribe.prototype.setConfirmsList = function (value) {
            jspb.Message.setField(this, 3, value || []);
        };

        /**
         * @param {!string} value
         * @param {number=} opt_index
         */
        proto.stream.Subscribe.prototype.addConfirms = function (value, opt_index) {
            jspb.Message.addToRepeatedField(this, 3, value, opt_index);
        };

        proto.stream.Subscribe.prototype.clearConfirmsList = function () {
            this.setConfirmsList([]);
        };

        /**
         * repeated string cancels = 4;
         * @return {!Array.<string>}
         */
        proto.stream.Subscribe.prototype.getCancelsList = function () {
            return (/** @type {!Array.<string>} */jspb.Message.getRepeatedField(this, 4)
            );
        };

        /** @param {!Array.<string>} value */
        proto.stream.Subscribe.prototype.setCancelsList = function (value) {
            jspb.Message.setField(this, 4, value || []);
        };

        /**
         * @param {!string} value
         * @param {number=} opt_index
         */
        proto.stream.Subscribe.prototype.addCancels = function (value, opt_index) {
            jspb.Message.addToRepeatedField(this, 4, value, opt_index);
        };

        proto.stream.Subscribe.prototype.clearCancelsList = function () {
            this.setCancelsList([]);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.SubscribeAck = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, proto.stream.SubscribeAck.repeatedFields_, null);
        };
        goog.inherits(proto.stream.SubscribeAck, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.SubscribeAck.displayName = 'proto.stream.SubscribeAck';
        }
        /**
         * List of repeated fields within this message type.
         * @private {!Array<number>}
         * @const
         */
        proto.stream.SubscribeAck.repeatedFields_ = [2];

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.SubscribeAck.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.SubscribeAck.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.SubscribeAck} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.SubscribeAck.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    status: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    groupsList: jspb.Message.getRepeatedField(msg, 2)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.SubscribeAck}
         */
        proto.stream.SubscribeAck.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.SubscribeAck();
            return proto.stream.SubscribeAck.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.SubscribeAck} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.SubscribeAck}
         */
        proto.stream.SubscribeAck.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setStatus(value);
                        break;
                    case 2:
                        var value = /** @type {string} */reader.readString();
                        msg.addGroups(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.SubscribeAck.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.SubscribeAck.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.SubscribeAck} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.SubscribeAck.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getStatus();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
            f = message.getGroupsList();
            if (f.length > 0) {
                writer.writeRepeatedString(2, f);
            }
        };

        /**
         * optional uint32 status = 1;
         * @return {number}
         */
        proto.stream.SubscribeAck.prototype.getStatus = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.SubscribeAck.prototype.setStatus = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * repeated string groups = 2;
         * @return {!Array.<string>}
         */
        proto.stream.SubscribeAck.prototype.getGroupsList = function () {
            return (/** @type {!Array.<string>} */jspb.Message.getRepeatedField(this, 2)
            );
        };

        /** @param {!Array.<string>} value */
        proto.stream.SubscribeAck.prototype.setGroupsList = function (value) {
            jspb.Message.setField(this, 2, value || []);
        };

        /**
         * @param {!string} value
         * @param {number=} opt_index
         */
        proto.stream.SubscribeAck.prototype.addGroups = function (value, opt_index) {
            jspb.Message.addToRepeatedField(this, 2, value, opt_index);
        };

        proto.stream.SubscribeAck.prototype.clearGroupsList = function () {
            this.setGroupsList([]);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.Publish = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, proto.stream.Publish.repeatedFields_, null);
        };
        goog.inherits(proto.stream.Publish, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.Publish.displayName = 'proto.stream.Publish';
        }
        /**
         * List of repeated fields within this message type.
         * @private {!Array<number>}
         * @const
         */
        proto.stream.Publish.repeatedFields_ = [3];

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.Publish.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.Publish.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.Publish} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.Publish.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    roomid: jspb.Message.getFieldWithDefault(msg, 1, "0"),
                    priority: jspb.Message.getFieldWithDefault(msg, 2, 0),
                    groupsList: jspb.Message.getRepeatedField(msg, 3),
                    cpproto: msg.getCpproto_asB64()
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.Publish}
         */
        proto.stream.Publish.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.Publish();
            return proto.stream.Publish.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.Publish} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.Publish}
         */
        proto.stream.Publish.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {string} */reader.readUint64String();
                        msg.setRoomid(value);
                        break;
                    case 2:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setPriority(value);
                        break;
                    case 3:
                        var value = /** @type {string} */reader.readString();
                        msg.addGroups(value);
                        break;
                    case 4:
                        var value = /** @type {!Uint8Array} */reader.readBytes();
                        msg.setCpproto(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.Publish.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.Publish.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.Publish} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.Publish.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getRoomid();
            if (parseInt(f, 10) !== 0) {
                writer.writeUint64String(1, f);
            }
            f = message.getPriority();
            if (f !== 0) {
                writer.writeUint32(2, f);
            }
            f = message.getGroupsList();
            if (f.length > 0) {
                writer.writeRepeatedString(3, f);
            }
            f = message.getCpproto_asU8();
            if (f.length > 0) {
                writer.writeBytes(4, f);
            }
        };

        /**
         * optional uint64 roomID = 1;
         * @return {string}
         */
        proto.stream.Publish.prototype.getRoomid = function () {
            return (/** @type {string} */jspb.Message.getFieldWithDefault(this, 1, "0")
            );
        };

        /** @param {string} value */
        proto.stream.Publish.prototype.setRoomid = function (value) {
            jspb.Message.setProto3StringIntField(this, 1, value);
        };

        /**
         * optional uint32 priority = 2;
         * @return {number}
         */
        proto.stream.Publish.prototype.getPriority = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 2, 0)
            );
        };

        /** @param {number} value */
        proto.stream.Publish.prototype.setPriority = function (value) {
            jspb.Message.setProto3IntField(this, 2, value);
        };

        /**
         * repeated string groups = 3;
         * @return {!Array.<string>}
         */
        proto.stream.Publish.prototype.getGroupsList = function () {
            return (/** @type {!Array.<string>} */jspb.Message.getRepeatedField(this, 3)
            );
        };

        /** @param {!Array.<string>} value */
        proto.stream.Publish.prototype.setGroupsList = function (value) {
            jspb.Message.setField(this, 3, value || []);
        };

        /**
         * @param {!string} value
         * @param {number=} opt_index
         */
        proto.stream.Publish.prototype.addGroups = function (value, opt_index) {
            jspb.Message.addToRepeatedField(this, 3, value, opt_index);
        };

        proto.stream.Publish.prototype.clearGroupsList = function () {
            this.setGroupsList([]);
        };

        /**
         * optional bytes cpProto = 4;
         * @return {!(string|Uint8Array)}
         */
        proto.stream.Publish.prototype.getCpproto = function () {
            return (/** @type {!(string|Uint8Array)} */jspb.Message.getFieldWithDefault(this, 4, "")
            );
        };

        /**
         * optional bytes cpProto = 4;
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {string}
         */
        proto.stream.Publish.prototype.getCpproto_asB64 = function () {
            return (/** @type {string} */jspb.Message.bytesAsB64(this.getCpproto())
            );
        };

        /**
         * optional bytes cpProto = 4;
         * Note that Uint8Array is not supported on all browsers.
         * @see http://caniuse.com/Uint8Array
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {!Uint8Array}
         */
        proto.stream.Publish.prototype.getCpproto_asU8 = function () {
            return (/** @type {!Uint8Array} */jspb.Message.bytesAsU8(this.getCpproto())
            );
        };

        /** @param {!(string|Uint8Array)} value */
        proto.stream.Publish.prototype.setCpproto = function (value) {
            jspb.Message.setProto3BytesField(this, 4, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.PublishAck = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, null, null);
        };
        goog.inherits(proto.stream.PublishAck, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.PublishAck.displayName = 'proto.stream.PublishAck';
        }

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.PublishAck.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.PublishAck.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.PublishAck} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.PublishAck.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    status: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    dstnum: jspb.Message.getFieldWithDefault(msg, 2, 0)
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.PublishAck}
         */
        proto.stream.PublishAck.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.PublishAck();
            return proto.stream.PublishAck.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.PublishAck} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.PublishAck}
         */
        proto.stream.PublishAck.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setStatus(value);
                        break;
                    case 2:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setDstnum(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.PublishAck.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.PublishAck.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.PublishAck} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.PublishAck.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getStatus();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
            f = message.getDstnum();
            if (f !== 0) {
                writer.writeUint32(2, f);
            }
        };

        /**
         * optional uint32 status = 1;
         * @return {number}
         */
        proto.stream.PublishAck.prototype.getStatus = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.PublishAck.prototype.setStatus = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * optional uint32 dstNum = 2;
         * @return {number}
         */
        proto.stream.PublishAck.prototype.getDstnum = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 2, 0)
            );
        };

        /** @param {number} value */
        proto.stream.PublishAck.prototype.setDstnum = function (value) {
            jspb.Message.setProto3IntField(this, 2, value);
        };

        /**
         * Generated by JsPbCodeGenerator.
         * @param {Array=} opt_data Optional initial data array, typically from a
         * server response, or constructed directly in Javascript. The array is used
         * in place and becomes part of the constructed object. It is not cloned.
         * If no data is provided, the constructed object will be empty, but still
         * valid.
         * @extends {jspb.Message}
         * @constructor
         */
        proto.stream.PublishNotify = function (opt_data) {
            jspb.Message.initialize(this, opt_data, 0, -1, proto.stream.PublishNotify.repeatedFields_, null);
        };
        goog.inherits(proto.stream.PublishNotify, jspb.Message);
        if (goog.DEBUG && !COMPILED) {
            proto.stream.PublishNotify.displayName = 'proto.stream.PublishNotify';
        }
        /**
         * List of repeated fields within this message type.
         * @private {!Array<number>}
         * @const
         */
        proto.stream.PublishNotify.repeatedFields_ = [3];

        if (jspb.Message.GENERATE_TO_OBJECT) {
            /**
             * Creates an object representation of this proto suitable for use in Soy templates.
             * Field names that are reserved in JavaScript and will be renamed to pb_name.
             * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
             * For the list of reserved names please see:
             *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
             * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
             *     for transitional soy proto support: http://goto/soy-param-migration
             * @return {!Object}
             */
            proto.stream.PublishNotify.prototype.toObject = function (opt_includeInstance) {
                return proto.stream.PublishNotify.toObject(opt_includeInstance, this);
            };

            /**
             * Static version of the {@see toObject} method.
             * @param {boolean|undefined} includeInstance Whether to include the JSPB
             *     instance for transitional soy proto support:
             *     http://goto/soy-param-migration
             * @param {!proto.stream.PublishNotify} msg The msg instance to transform.
             * @return {!Object}
             * @suppress {unusedLocalVariables} f is only used for nested messages
             */
            proto.stream.PublishNotify.toObject = function (includeInstance, msg) {
                var f,
                    obj = {
                    srcuid: jspb.Message.getFieldWithDefault(msg, 1, 0),
                    priority: jspb.Message.getFieldWithDefault(msg, 2, 0),
                    groupsList: jspb.Message.getRepeatedField(msg, 3),
                    cpproto: msg.getCpproto_asB64()
                };

                if (includeInstance) {
                    obj.$jspbMessageInstance = msg;
                }
                return obj;
            };
        }

        /**
         * Deserializes binary data (in protobuf wire format).
         * @param {jspb.ByteSource} bytes The bytes to deserialize.
         * @return {!proto.stream.PublishNotify}
         */
        proto.stream.PublishNotify.deserializeBinary = function (bytes) {
            var reader = new jspb.BinaryReader(bytes);
            var msg = new proto.stream.PublishNotify();
            return proto.stream.PublishNotify.deserializeBinaryFromReader(msg, reader);
        };

        /**
         * Deserializes binary data (in protobuf wire format) from the
         * given reader into the given message object.
         * @param {!proto.stream.PublishNotify} msg The message object to deserialize into.
         * @param {!jspb.BinaryReader} reader The BinaryReader to use.
         * @return {!proto.stream.PublishNotify}
         */
        proto.stream.PublishNotify.deserializeBinaryFromReader = function (msg, reader) {
            while (reader.nextField()) {
                if (reader.isEndGroup()) {
                    break;
                }
                var field = reader.getFieldNumber();
                switch (field) {
                    case 1:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setSrcuid(value);
                        break;
                    case 2:
                        var value = /** @type {number} */reader.readUint32();
                        msg.setPriority(value);
                        break;
                    case 3:
                        var value = /** @type {string} */reader.readString();
                        msg.addGroups(value);
                        break;
                    case 4:
                        var value = /** @type {!Uint8Array} */reader.readBytes();
                        msg.setCpproto(value);
                        break;
                    default:
                        reader.skipField();
                        break;
                }
            }
            return msg;
        };

        /**
         * Serializes the message to binary data (in protobuf wire format).
         * @return {!Uint8Array}
         */
        proto.stream.PublishNotify.prototype.serializeBinary = function () {
            var writer = new jspb.BinaryWriter();
            proto.stream.PublishNotify.serializeBinaryToWriter(this, writer);
            return writer.getResultBuffer();
        };

        /**
         * Serializes the given message to binary data (in protobuf wire
         * format), writing to the given BinaryWriter.
         * @param {!proto.stream.PublishNotify} message
         * @param {!jspb.BinaryWriter} writer
         * @suppress {unusedLocalVariables} f is only used for nested messages
         */
        proto.stream.PublishNotify.serializeBinaryToWriter = function (message, writer) {
            var f = undefined;
            f = message.getSrcuid();
            if (f !== 0) {
                writer.writeUint32(1, f);
            }
            f = message.getPriority();
            if (f !== 0) {
                writer.writeUint32(2, f);
            }
            f = message.getGroupsList();
            if (f.length > 0) {
                writer.writeRepeatedString(3, f);
            }
            f = message.getCpproto_asU8();
            if (f.length > 0) {
                writer.writeBytes(4, f);
            }
        };

        /**
         * optional uint32 srcUid = 1;
         * @return {number}
         */
        proto.stream.PublishNotify.prototype.getSrcuid = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 1, 0)
            );
        };

        /** @param {number} value */
        proto.stream.PublishNotify.prototype.setSrcuid = function (value) {
            jspb.Message.setProto3IntField(this, 1, value);
        };

        /**
         * optional uint32 priority = 2;
         * @return {number}
         */
        proto.stream.PublishNotify.prototype.getPriority = function () {
            return (/** @type {number} */jspb.Message.getFieldWithDefault(this, 2, 0)
            );
        };

        /** @param {number} value */
        proto.stream.PublishNotify.prototype.setPriority = function (value) {
            jspb.Message.setProto3IntField(this, 2, value);
        };

        /**
         * repeated string groups = 3;
         * @return {!Array.<string>}
         */
        proto.stream.PublishNotify.prototype.getGroupsList = function () {
            return (/** @type {!Array.<string>} */jspb.Message.getRepeatedField(this, 3)
            );
        };

        /** @param {!Array.<string>} value */
        proto.stream.PublishNotify.prototype.setGroupsList = function (value) {
            jspb.Message.setField(this, 3, value || []);
        };

        /**
         * @param {!string} value
         * @param {number=} opt_index
         */
        proto.stream.PublishNotify.prototype.addGroups = function (value, opt_index) {
            jspb.Message.addToRepeatedField(this, 3, value, opt_index);
        };

        proto.stream.PublishNotify.prototype.clearGroupsList = function () {
            this.setGroupsList([]);
        };

        /**
         * optional bytes cpProto = 4;
         * @return {!(string|Uint8Array)}
         */
        proto.stream.PublishNotify.prototype.getCpproto = function () {
            return (/** @type {!(string|Uint8Array)} */jspb.Message.getFieldWithDefault(this, 4, "")
            );
        };

        /**
         * optional bytes cpProto = 4;
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {string}
         */
        proto.stream.PublishNotify.prototype.getCpproto_asB64 = function () {
            return (/** @type {string} */jspb.Message.bytesAsB64(this.getCpproto())
            );
        };

        /**
         * optional bytes cpProto = 4;
         * Note that Uint8Array is not supported on all browsers.
         * @see http://caniuse.com/Uint8Array
         * This is a type-conversion wrapper around `getCpproto()`
         * @return {!Uint8Array}
         */
        proto.stream.PublishNotify.prototype.getCpproto_asU8 = function () {
            return (/** @type {!Uint8Array} */jspb.Message.bytesAsU8(this.getCpproto())
            );
        };

        /** @param {!(string|Uint8Array)} value */
        proto.stream.PublishNotify.prototype.setCpproto = function (value) {
            jspb.Message.setProto3BytesField(this, 4, value);
        };

        /**
         * @enum {number}
         */
        proto.stream.SDKHotelCmdID = {
            INVALIDSDKCMD: 0,
            CHECKINCMDID: 1401,
            CHECKINACKCMDID: 1402,
            HEARTBEATCMDID: 1403,
            HEARTBEATACKCMDID: 1404,
            BROADCASTCMDID: 1405,
            BROADCASTACKCMDID: 1406,
            NOTIFYCMDID: 1408,
            CHECKINNOTIFYCMDID: 1410,
            SUBSCRIBECMDID: 1411,
            SUBSCRIBEACKCMDID: 1412,
            PUBLISHCMDID: 1413,
            PUBLISHACKCMDID: 1414,
            PUBLISHNOTIFYCMDID: 1416
        };

        goog.object.extend(exports, proto.stream);
    }, { "google-protobuf": 1 }]
}, {}, [3]);
/* ================ matchvsdefine.js ================= */
function MsCreateRoomInfo(roomName, maxPlayer, mode, canWatch, visibility, roomProperty) {
    // this.roomID       =roomID ;
    this.roomName = roomName;
    this.maxPlayer = maxPlayer;
    this.mode = mode;
    this.canWatch = canWatch;
    this.visibility = visibility;
    this.roomProperty = roomProperty;
    // this.owner        =owner;
    this.toString = function () {
        return "roomName:" + this.roomName + " maxPlayer:" + this.maxPlayer + " mode:" + this.mode + " canWatch:" + this.canWatch + " visibility:" + this.visibility + " roomProperty:" + this.roomProperty;
    };
}
function MsEnum() {}
/**
 *      joinSpecialRoom = 1;		//,param(roomID, userProfile)
 *      joinRoomWithProperty = 2;	//,param(roomProperty, userProfil
 *      joinRandomRoom = 3;			//,param(maxPlayer, userProfile)
 * @type {{NoJoin: number, joinSpecialRoom: number, joinRoomWithProperty: number, joinRandomRoom: number}}
 */
MsEnum.JoinRoomType = { NoJoin: 0, joinSpecialRoom: 1, joinRoomWithProperty: 2, joinRandomRoom: 3 };

MsEnum.CmdId = {
    NoCmd: 0,
    /**/
    loginReq: 1101,
    loginRsp: 1102,
    /**/
    logoutReq: 1105,
    logoutRsp: 1106,
    /**/
    heartBeatReq: 1103,
    /**/
    networkStateReq: 1120,
    networkStateRsp: 1121,
    noticeNetworkStateReq: 1122,
    /**/
    createRoomReq: 1203,
    createRoomRsp: 1204,
    /**/
    getRoomListReq: 1207,
    getRoomListRsp: 1208,
    /**/
    joinRoomReq: 1201,
    joinRoomRsp: 1202,
    noticeUserJoinReq: 1301,
    /**/
    leaveRoomReq: 1205,
    leaveRoomRsp: 1206,
    noticeUserLeaveReq: 1302,
    /**/
    joinOverReq: 1213,
    joinOverRsp: 1214,
    disconnectReq: 1107,
    disconnectRsp: 1108,
    /**/
    kickPlayerReq: 1303,
    kickPlayerRsp: 1304,
    kickPlayerNotify: 1305
};
function MsRoomJoin(joinType, userID, roomID, gameID, maxPlayer, mode, canWatch, userProfile, tags) {
    this.joinType = joinType;
    this.userID = userID;
    this.roomID = roomID;
    this.gameID = gameID;
    this.maxPlayer = maxPlayer;
    this.mode = mode;
    this.canWatch = canWatch;
    this.tags = tags; //k-v map as json object  ex:[{dd:'SB',AA:'dd',re1:123},{cc:'dd',lk:'1qw'}];
    this.userProfile = userProfile;

    // MsRoomJoin() : joinType(0), userID(0), roomID(0), gameID(0), maxPlayer(0), mode(0), canWatch(0) {}
}

function MsJoinOverRsp(status, cpProto) {
    this.status = status;
    this.cpProto = cpProto;
}

/**
 *
 * @param gameID
 * @param roomID
 * @param userID
 * @param bookID
 * @param book_key
 * @param hotelInfo
 * @constructor
 */
function MsCheckIn(gameID, roomID, userID, bookID, book_key, hotelInfo) {
    this.gameID = gameID; // int
    this.roomID = roomID; // unsigned long long
    this.userID = userID; // int
    this.bookID = bookID; // std::string
    this.book_key = book_key; // matchvs::MsString
    this.hotelInfo = hotelInfo; // matchvs::MsString
}

/**
 *  
 * @param roomID
 * @param roomProperty
 * @param ownerID
 * @constructor
 */
function MsRoomInfo(roomID, roomProperty, ownerID) {
    this.roomId = roomID; // string
    this.roomProperty = roomProperty; //
    this.ownerId = ownerID;
}

/**
 * 
 * @param userID
 * @param userProfile
 * @constructor
 */
function MsRoomUserInfo(userID, userProfile) {
    this.userId = userID;
    this.userProfile = userProfile;
}

/**
 * 
 * @param status
 * @param roomId
 * @param userId
 * @param cpProto
 * @constructor
 */
function MsLeaveRoomRsp(status, roomId, userId, cpProto) {
    this.status = status;
    this.roomId = roomId;
    this.userId = userId;
    this.cpProto = cpProto;
}

/**
 *
 * @param status
 * @param groups
 * @constructor
 */
function MsSubscribeEventGroupRsp(status, groups) {
    this.status = status; //number
    this.groups = groups; // array<string>
}

/**
 *
 * @param status
 * @param dstNum
 * @constructor
 */
function MsSendEventGroupRsp(status, dstNum) {
    this.status = status; // number
    this.dstNum = dstNum; // unsigned long long
}
/**
 *
 */
function MsSendEventGroupNotify(srcUid, groups, cpProto) {
    this.srcUid = srcUid; // number
    this.groups = groups; // array<string>
    this.cpProto = cpProto; // string
}

/**
 *
 * @param status
 * @param userID
 * @param token
 * @param name
 * @param avatar
 * @constructor
 */
function MsRegistRsp(status, userID, token, name, avatar) {
    this.status = status;
    this.id = userID;
    this.token = token;
    this.name = name;
    this.avatar = avatar;
}

/**
 *
 * @param userID
 * @param checkins
 * @param players
 * @param maxPlayers
 * @constructor
 */
function MsCheckInNotify(userID, checkins, players, maxPlayers) {
    this.userID = userID; // number
    this.checkins = checkins; // array<number>
    this.players = players; // array<number>
    this.maxPlayers = maxPlayers; // number
}

/**
 *
 * @param srcUserID
 * @param cpProto
 * @constructor
 */
function MsSendEventNotify(srcUserID, cpProto) {
    this.srcUserId = srcUserID; // number
    this.cpProto = cpProto; // string
}

/**
 *
 * @param status
 * @constructor
 */
function MsSendEventRsp(status, sequence) {
    this.status = status; // number
    this.sequence = sequence; // number
}

/**
 *
 * @param gameID
 * @param roomID
 * @param userID
 * @constructor
 */
function MsHeartBeatHotel(gameID, roomID, userID) {
    this.gameID = gameID; // number
    this.roomID = roomID; // number
    this.userID = userID; // number
}

/**
 *
 * @param userId {number}
 * @param srcUserId {number}
 * @param data {string}
 * @constructor
 */
function MsKickPlayerNotify(userId, srcUserId, data) {
    this.UserId = userId;
    this.srcUserId = srcUserId;
    this.cpProto = data;
}

/**
 *
 * @param mStatus
 * @param cmsns
 * @param engine
 * @param platform
 * @param vsopen
 * @param vspay
 * @param vsproduct
 * @param vsuser
 * @constructor
 */
function MsHostListRsp(mStatus, cmsns, engine, platform, vsopen, vspay, vsproduct, vsuser) {
    this.mStatus = mStatus;
    this.cmsns = cmsns;
    this.engine = engine;
    this.mPlatform = platform;
    this.vsopen = vsopen;
    this.vspay = vspay;
    this.vsproduct = vsproduct;
    this.vsuser = vsuser;
}; /* ================ matchvsnetwork.js ================= */
function MatchvsNetWorkCallBack() {
    /**
     *
     * @param buf DataView
     */
    this.onMsg = function (buf) {};
    /**
     *
     * @param errCode int
     * @param errMsg String
     */
    this.onErr = function (errCode, errMsg) {};
}

/**
 * var callback = new MatchvsNetWorkCallBack();
 * @param host String,ex:"127.0.0.1:12345";
 * @param callback MatchvsNetWorkCallBack
 * @constructor
 */
function MatchvsNetWork(host, callback) {
    var socket;
    var mCallBack = callback;
    var mHost = host;
    var bufQueue = [];
    this.send = function (message) {

        if (!window.WebSocket) {
            return;
        }
        if (isIE()) {
            var uint8A = new Uint8Array(message.buffer.byteLength);
            for (var i = 0; i < uint8A.length; i++) {
                uint8A[i] = message.getUint8(i);
            }
            message = uint8A;
        }
        if (socket.readyState === WebSocket.OPEN) {
            //log(message);
            socket.send(message);
        } else {
            bufQueue.push(message);
        }
    };
    this.close = function () {
        if (socket) {
            socket.close();
        }
    };
    if (!window.WebSocket) {
        window.WebSocket = window.MozWebSocket;
    }

    if (window.WebSocket) {
        socket = new WebSocket(host);
        socket.onmessage = function (event) {
            var reader = new FileReader();
            reader.readAsArrayBuffer(event.data);
            //  .
            reader.onload = function (evt) {
                if (evt.target.readyState === FileReader.DONE) {
                    var dataView = new DataView(reader.result);
                    mCallBack.onMsg(dataView);
                } else {
                    mCallBack.onErr(1606, "[err]parse fail");
                }
            };
        };
        socket.onopen = function (event) {
            while (bufQueue.length > 0) {
                socket.send(bufQueue.pop());
            }
            mCallBack.onConnect && mCallBack.onConnect(mHost);
        };
        socket.onclose = function (event) {
            mCallBack.onDisConnect && mCallBack.onDisConnect(mHost);
        };
        socket.onerror = function (event) {
            if (event.type && event.type === "error") {
                return;
            }
            callback.onErr(1606, event);
        };
    } else {
        alert("Not Support the WebSocket");
    }
}

/**
 *   new MatchvsHttp(new function () {
 *       this.onMsg = function (buf) {
 *           alert("[HTTP]rsp:"+buf);
 *       };
 *       this.onErr = function (errCode,errMsg) {
 *           alert("[HTTP]errCode:"+errCode+" msg:"+errMsg);
 *       };
 *   }).get("http://testpay.matchvs.com/wc3/submitOrder.do");
 * @param callback {MatchvsNetWorkCallBack}
 * @constructor
 */
function MatchvsHttp(callback) {
    this.mCallback = callback;
    function send(url, callback, isPost, params) {
        var http = new XMLHttpRequest();
        http.open(isPost ? "POST" : "GET", url, true);
        http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        http.onreadystatechange = function () {
            //Call a function when the state changes.
            if (http.readyState === 4) {
                if (http.status === 200) {
                    callback.onMsg(http.responseText);
                } else {
                    callback.onErr(http.status, http.statusText);
                }
            }
        };
        if (isPost) {
            http.send(params);
        } else {
            http.send(null);
        }
    }

    /**
     * HTTP GET
     * @param url {String} ex:"http://testpay.matchvs.com/wc3/submitOrder.do?key=fa"
     */
    this.get = function (url) {
        send(url, this.mCallback, false, null);
    };
    /**
     * HTTP POST
     * @param url {String} ex:"http://testpay.matchvs.com/wc3/submitOrder.do"
     * @param params {String} ex:"lorem=ipsum&name=binny";
     */
    this.post = function (url, params) {
        send(url, this.mCallback, true, params);
    };
} /* ================ matchvsprotocol.js ================= */
//================== CMD =======================
var MATCHVS_USER_GATEWAY_SPEED_REQ = 1001;
var MATCHVS_USER_GATEWAY_SPEED_RSP = 1002;
var MATCHVS_USER_LOGIN_REQ = 1101;
var MATCHVS_USER_LOGIN_RSP = 1102;
var MATCHVS_USER_HEARTBEAT_REQ = 1103;
var MATCHVS_USER_HEARTBEAT_RSP = 1103;
var MATCHVS_NOTICE_USER_RELOGIN = 1104;
var MATCHVS_USER_LOGOUT_REQ = 1105;
var MATCHVS_USER_LOGOUT_RSP = 1106;
var MATCHVS_NETWORK_STATE_NOTIFY = 1122;
var MATCHVS_ROOM_CREATE_REQ = 1203;
var MATCHVS_ROOM_CREATE_RSP = 1204;
var MATCHVS_ROOM_JOIN_REQ = 1201;
var MATCHVS_ROOM_JOIN_RSP = 1202;
var MATCHVS_ROOM_JOIN_OVER_REQ = 1213;
var MATCHVS_ROOM_JOIN_OVER_RSP = 1214;
var MATCHVS_ROOM_LEAVE_REQ = 1205;
var MATCHVS_ROOM_LEAVE_RSP = 1206;
var MATCHVS_ROOM_NOTICE_USER_JOIN = 1301;
var MATCHVS_ROOM_NOTICE_USER_LEAVE = 1302;
// var MATCHVS_ROOM_NOTICE_USER_STATUS = 1303;
// var MATCHVS_USER_SEND_MSG_REQ = 1305;
// var MATCHVS_SERVER_PUSH_MSG = 1306;
var MATCHVS_ROOM_CHECK_IN_REQ = 1401;
var MATCHVS_ROOM_CHECK_IN_RSP = 1402;
var MATCHVS_HEARTBEAT_HOTEL_REQ = 1403;
var MATCHVS_HEARTBEAT_HOTEL_RSP = 1404;
var MATCHVS_BROADCAST_HOTEL_REQ = 1405;
var MATCHVS_BROADCAST_HOTEL_RSP = 1406;
var MATCHVS_HOTEL_NOTIFY = 1408;
var MATCHVS_ROOM_CHECKIN_NOTIFY = 1410;
// var MATCHVS_SUBSCRIBE_EVENT_GROUP_REQ = 1411;
// var MATCHVS_SUBSCRIBE_EVENT_GROUP_RSP = 1412;
// var MATCHVS_SEND_EVENT_GROUP_REQ = 1413;
// var MATCHVS_SEND_EVENT_GROUP_RSP = 1414;
// var MATCHVS_SEND_EVENT_GROUP_NOTIFY = 1416;


var CMD_GET_ROOM_LIST_REQ = 1207;
var CMD_GET_ROOM_LIST_RSP = 1208;
var CMD_DISCONNECT_REQ = 1107;
var CMD_DISCONNECT_RSP = 1108;
var CMD_KICK_PLAYER_REQ = 1303;
var CMD_KICK_PLAYER_RSP = 1304;
var CMD_KICK_PLAYER_NOTIFY = 1305;
var CMD_SUBSCRIBE_CMDID = 1411;
var CMD_SUBSCRIBE_ACK_CMDID = 1412;
var CMD_PUBLISH_CMDID = 1413;
var CMD_PUBLISH_ACKCMDID = 1414;
var CMD_PUBLISH_NOTIFYCMDID = 1416;

//================== CMD =======================
var FIXED_HEAD_SIZE = 16;
var VERSION = 2;

function Packet() {
    var header; //{MatchvsHeader}
    var payload; //*
    var buf; //{DataView}
}

function MatchvsHeader() {
    this.size = 0;
    this.seq = 0;
    this.cmd = 0;
    this.version = 0;
    this.userID = 0;
    this.toString = function () {
        return " this.size   " + this.size + " this.seq    " + this.seq + " this.cmd    " + this.cmd + " this.version" + this.version + " this.userID " + this.userID;
    };
}

var mPortoBufRootGW;
var mProtoBufRootHotel;
var mProtoBufRootErrCode;

/**
 * Encoder && Decoder
 * @constructor
 */
function MatchvsProtocol() {

    this.seq = 1;
    var mUserID = 0;

    protobuf.load(err, function (err, root) {
        if (err) throw err;
        mProtoBufRootErrCode = root;
    });
    protobuf.load(gateWay, function (err, root) {
        if (err) throw err;
        mPortoBufRootGW = root;
    });
    protobuf.load(sdk, function (err, root) {
        if (err) throw err;
        mProtoBufRootHotel = root;
    });
    /**
     *
     * @param dataArray uint array
     * @param cmd int
     * @returns {DataView}
     */
    this.fillHeader = function (dataArray, cmd) {
        var buffer = new ArrayBuffer(FIXED_HEAD_SIZE + dataArray.length);
        var dataView = new DataView(buffer);
        dataView.setInt32(0, buffer.byteLength, true); //size; +4
        dataView.setInt32(4, this.seq++, true); //seq +4
        dataView.setInt16(8, cmd, true); //cmd; +2
        dataView.setInt16(10, VERSION, true); //version +2
        dataView.setInt32(12, Number(mUserID), true); //userID +4

        var length = dataArray.length;
        //append unsigned int Array to end
        for (var i = 0; i < length; i++) {
            dataView.setUint8(i + FIXED_HEAD_SIZE, dataArray[i]);
        }
        return dataView;
    };
    /**
     *
     * @param msg {DataView}
     * @returns {MatchvsHeader}
     */
    this.parseHeader = function (msg) {
        var dataView = msg;
        var head = new MatchvsHeader();
        head.size = dataView.getInt32(0, true); //size; +4
        head.seq = dataView.getInt32(4, true); //seq +4
        head.cmd = dataView.getInt16(8, true); //cmd; +2
        head.version = dataView.getInt16(10, true); //version +2
        head.userID = dataView.getInt32(12, true); //userID +4
        return head;
    };
    /**
     *
     * @param msg {DataView}
     * @returns {*}
     */
    this.handleMsg = function (msg) {

        var dataView = msg;
        var header = this.parseHeader(msg);
        var ext = new Uint8Array(header.size - FIXED_HEAD_SIZE);
        for (var i = 0; i < ext.length; i++) {
            ext[i] = msg.getUint8(FIXED_HEAD_SIZE + i);
        }
        var packet = new Packet();
        packet.header = header;
        packet.buf = dataView;
        switch (header.cmd) {

            case MATCHVS_USER_LOGIN_RSP:
                packet.payload = mPortoBufRootGW.lookup("stream.LoginRsp").decode(ext);
                break;
            case MATCHVS_ROOM_JOIN_RSP:
                // packet.payload = mPortoBufRootGW.lookup("stream.JoinRoomRsp").decode(ext);
                packet.payload = proto.stream.JoinRoomRsp.deserializeBinary(msg.buffer.slice(FIXED_HEAD_SIZE, msg.buffer.byteLength));

                break;
            case MATCHVS_ROOM_CREATE_RSP:
                packet.payload = proto.stream.CreateRoomRsp.deserializeBinary(msg.buffer.slice(FIXED_HEAD_SIZE, msg.buffer.byteLength));
                break;
            case MATCHVS_ROOM_CHECK_IN_RSP:
                packet.payload = mProtoBufRootHotel.lookup("stream.CheckInAck").decode(ext);
                break;
            case MATCHVS_ROOM_CHECKIN_NOTIFY:
                packet.payload = mProtoBufRootHotel.lookup("stream.CheckInNotify").decode(ext);
                break;
            case MATCHVS_ROOM_LEAVE_RSP:
                packet.payload = mPortoBufRootGW.lookup("stream.LeaveRoomRsp").decode(ext);
                break;
            case MATCHVS_ROOM_JOIN_OVER_RSP:
                packet.payload = mPortoBufRootGW.lookup("stream.JoinOverRsp").decode(ext);
                break;
            case MATCHVS_ROOM_NOTICE_USER_JOIN:
                packet.payload = mPortoBufRootGW.lookup("stream.NoticeJoin").decode(ext);
                break;
            case MATCHVS_ROOM_NOTICE_USER_LEAVE:
                packet.payload = mPortoBufRootGW.lookup("stream.NoticeLeave").decode(ext);
                break;
            case MATCHVS_HEARTBEAT_HOTEL_RSP:
                packet.payload = mProtoBufRootHotel.lookup("stream.HeartbeatAck").decode(ext);
                break;
            case MATCHVS_BROADCAST_HOTEL_RSP:
                packet.payload = mProtoBufRootHotel.lookup("stream.BroadcastAck").decode(ext);
                break;
            case MATCHVS_HOTEL_NOTIFY:
                packet.payload = mProtoBufRootHotel.lookup("stream.Notify").decode(ext);
                break;
            case CMD_SUBSCRIBE_ACK_CMDID:
                //MATCHVS_SUBSCRIBE_EVENT_GROUP_RSP:
                packet.payload = mProtoBufRootHotel.lookup("stream.SubscribeAck").decode(ext);
                break;
            case CMD_PUBLISH_ACKCMDID:
                //MATCHVS_SEND_EVENT_GROUP_RSP:
                packet.payload = mProtoBufRootHotel.lookup("stream.PublishAck").decode(ext);
                break;
            case CMD_PUBLISH_NOTIFYCMDID:
                //SEND_EVENT_GROUP_NOTIFY:
                packet.payload = mProtoBufRootHotel.lookup("stream.PublishNotify").decode(ext);
                break;
            case MATCHVS_USER_GATEWAY_SPEED_RSP:
                //TODO  _SPEED
                var status = dataView.getInt32(4);
                break;
            case MATCHVS_USER_HEARTBEAT_RSP:
                packet.payload = mPortoBufRootGW.lookup("stream.HeartbeatRsp").decode(ext);
                break;
            case MATCHVS_USER_LOGOUT_RSP:
                packet.payload = mPortoBufRootGW.lookup("stream.LogoutRsp").decode(ext);
                break;
            case CMD_GET_ROOM_LIST_RSP:
                packet.payload = mPortoBufRootGW.lookup("stream.GetRoomListRsp").decode(ext);
                break;
            case CMD_DISCONNECT_RSP:
                packet.payload = mPortoBufRootGW.lookup("stream.DisconnectRsp").decode(ext);
                break;
            case CMD_KICK_PLAYER_RSP:
                packet.payload = mPortoBufRootGW.lookup("stream.KickPlayerRsp").decode(ext);
                break;
            case CMD_KICK_PLAYER_NOTIFY:
                packet.payload = mPortoBufRootGW.lookup("stream.KickPlayerNotify").decode(ext);
                break;
            default:
                console.log("[WARN]unknown msg,Head:" + header);
                break;
        }
        return packet;
    };
    this.init = function () {};

    /**
     * 
     * @userID {uint32} value ID
     * @userToken {uint64} value token
     * @gameID {uint32} value ID
     * @gameVersion {uint16} value  
     * @app_key { !Array.<string> } app_key key,
     * @app_secret { !Array.<string>  app_secret secret
     * @deviceID { !Array.<string> } deviceID ID
     * @gateway_id gateway_id
     * @returns {DataView}
     */
    this.login = function (userID, userToken, gameID, gameVersion, app_key, app_secret, deviceID, gateway_id) {
        var toMd5 = format("%s&UserID=%s&GameID=%s&VersionSdk=%d&%s", app_key, userID, gameID, VERSION, app_secret);
        mUserID = userID;
        var md5 = hex_md5(toMd5);
        console.log("[Sign]" + toMd5 + "->" + md5);
        // var WSMessage = mPortoBufRootGW.lookup("stream.LoginReq");
        // var msgLoginReq = WSMessage.create({gameID: gameID, appKey: app_key, deviceID: deviceID, sign: md5});
        // var dataArray = WSMessage.encode(msgLoginReq).finish();

        //TODO replace to static proto buf

        var message = new proto.stream.LoginReq();
        message.setGameid(Number(gameID));
        message.setAppkey(app_key);
        message.setDeviceid(deviceID);
        message.setSign(md5);
        var dataArray = message.serializeBinary();
        //append binary head and proto buffer;
        console.log("[REQ]login...userID:" + userID);
        return this.fillHeader(dataArray, MATCHVS_USER_LOGIN_REQ);
    };
    /**
     * 
     * @userID {uint32} value ID
     * @gameID {uint32} value ID
     * @userToken {uint64} value token
     * @versionSDK {uint16} value sdk
     * @gameVersion {uint16} value  
     * @returns {DataView}
     */
    this.speed = function (userID, gameID, userToken, versionSDK, gameVersion) {

        var buffer = new ArrayBuffer(48 + 1);
        var dataView = new DataView(buffer);
        var _user = Number(userID);
        var _gameID = Number(gameID);
        dataView.setUint32(0, _user, true); //userID
        dataView.setUint32(4, _gameID, true); //gameID
        for (var i = 0; i < 32; i++) {
            dataView.setUint8(8 + i, userToken.charCodeAt(i)); //token
        }
        dataView.setUint16(8 + 32, versionSDK, true); //version sdk
        dataView.setUint16(8 + 32 + 2, gameVersion, true); //game version
        dataView.setUint32(8 + 32 + 2 + 2, 1, true); //echo size
        dataView.setUint8(8 + 32 + 2 + 2 + 4, 0x01); //echo

        var array = new Uint8Array(dataView.byteLength);
        for (var j = 0; j < dataView.byteLength; j++) {
            array[j] = dataView.getUint8(j);
        }
        //append binary head and proto buffer;
        return this.fillHeader(array, MATCHVS_USER_GATEWAY_SPEED_REQ);
    };
    this.roomCreate = function (maxUser, flag, gameID, pRoomInfo, pPlayInfo) {

        var message = new proto.stream.CreateRoom();
        message.setGameid(Number(gameID));

        var pi = new proto.stream.PlayerInfo();
        pi.setUserid(pPlayInfo.userID);
        pi.setUserprofile(stringToUtf8ByteArray(pPlayInfo.userProfile));
        message.setPlayerinfo(pi);

        var roomInfo = new proto.stream.RoomInfo();
        roomInfo.setMaxplayer(Number(pRoomInfo.maxPlayer));
        roomInfo.setCanwatch(pRoomInfo.canWatch);
        roomInfo.setMode(pRoomInfo.mode);
        roomInfo.setVisibility(pRoomInfo.visibility);
        roomInfo.setRoomname(pRoomInfo.roomName);
        roomInfo.setRoomproperty(stringToUtf8ByteArray(pRoomInfo.roomProperty));
        message.setRoominfo(roomInfo);

        var bytes = message.serializeBinary();
        return this.fillHeader(bytes, MATCHVS_ROOM_CREATE_REQ);
    };

    this.joinRoom = function (roomJoin) {
        var message = new proto.stream.JoinRoomReq();
        message.setGameid(Number(roomJoin.gameID));
        message.setJointype(proto.stream.JoinRoomType.JOINRANDOMROOM);
        message.setCpproto(stringToUtf8ByteArray(roomJoin.userProfile));

        var playInfo = new proto.stream.PlayerInfo();
        playInfo.setUserid(roomJoin.userID);
        playInfo.setUserprofile(stringToUtf8ByteArray(roomJoin.userProfile));
        message.setPlayerinfo(playInfo);

        var roomInfo = new proto.stream.RoomInfo();
        roomInfo.setMaxplayer(roomJoin.maxPlayer);
        roomInfo.setCanwatch(roomJoin.canWatch);
        roomInfo.setMode(roomJoin.mode);
        roomInfo.setVisibility(0);
        message.setRoominfo(roomInfo);

        var bytes = message.serializeBinary();
        return this.fillHeader(bytes, MATCHVS_ROOM_JOIN_REQ);
    };

    /**
     * roomID
     * @param roomJoin
     * @returns {DataView}
     */
    this.joinRoomSpecial = function (roomJoin) {
        var message = new proto.stream.JoinRoomReq();
        message.setGameid(Number(roomJoin.gameID));
        message.setJointype(proto.stream.JoinRoomType.JOINSPECIALROOM);
        message.setCpproto(stringToUtf8ByteArray(roomJoin.userProfile));

        var playInfo = new proto.stream.PlayerInfo();
        playInfo.setUserid(roomJoin.userID);
        playInfo.setUserprofile(stringToUtf8ByteArray(roomJoin.userProfile));
        message.setPlayerinfo(playInfo);

        var roomInfo = new proto.stream.RoomInfo();
        roomInfo.setMaxplayer(roomJoin.maxPlayer);
        roomInfo.setCanwatch(roomJoin.canWatch);
        roomInfo.setMode(roomJoin.mode);
        roomInfo.setVisibility(0);
        roomInfo.setRoomid(roomJoin.roomID);
        message.setRoominfo(roomInfo);

        var bytes = message.serializeBinary();
        return this.fillHeader(bytes, MATCHVS_ROOM_JOIN_REQ);
    };

    /**
     * 
     * @param roomJoin {MsRoomJoin}
     * @returns {DataView}
     */
    this.joinRoomWithProperties = function (roomJoin) {
        var message = new proto.stream.JoinRoomReq();
        message.setTagsList(roomJoin.tags);
        message.setJointype(proto.stream.JoinRoomType.JOINROOMWITHPROPERTY);
        message.setCpproto(stringToUtf8ByteArray(roomJoin.userProfile));

        var playInfo = new proto.stream.PlayerInfo();
        playInfo.setUserid(roomJoin.userID);
        playInfo.setUserprofile(stringToUtf8ByteArray(roomJoin.userProfile));
        message.setPlayerinfo(playInfo);

        var roomInfo = new proto.stream.RoomInfo();
        roomInfo.setMaxplayer(roomJoin.maxPlayer);
        roomInfo.setCanwatch(roomJoin.canWatch);
        roomInfo.setMode(roomJoin.mode);
        roomInfo.setVisibility(0);
        roomInfo.setRoomid(roomJoin.roomID);
        message.setRoominfo(roomInfo);

        var bytes = message.serializeBinary();
        return this.fillHeader(bytes, MATCHVS_ROOM_JOIN_REQ);
    };

    this.roomCheckIn = function (bookInfo, roomInfo, userID, gameID) {
        var pkg = new proto.stream.CheckIn();
        pkg.setGameid(Number(gameID));
        pkg.setRoomid(roomInfo.getRoomid());
        pkg.setUserid(Number(userID));
        pkg.setBookid(bookInfo.getBookid());
        pkg.setKey(bookInfo.getBookkey());
        var bytes = pkg.serializeBinary();
        return this.fillHeader(bytes, MATCHVS_ROOM_CHECK_IN_REQ);
    };
    this.getRoomList = function (gameID, filter) {
        var pkg = new proto.stream.GetRoomList();
        var roomFilter = new proto.stream.RoomFilter();
        roomFilter.setCanwatch(filter.canWatch);
        roomFilter.setMaxplayer(filter.maxPlayer);
        roomFilter.setMode(Number(filter.mode));
        roomFilter.setRoomproperty(str2u8array(filter.roomproperty));
        pkg.setGameid(gameID);
        pkg.setRoomfilter(roomFilter);
        var bytes = pkg.serializeBinary();
        return this.fillHeader(bytes, CMD_GET_ROOM_LIST_REQ);
    };
    this.joinOver = function (gameID, roomID, cpproto, userID) {

        var pkg = new proto.stream.JoinOverReq();
        pkg.setGameid(gameID);
        pkg.setRoomid(roomID);
        pkg.setCpproto(cpproto);
        pkg.setUserid(userID);
        var bytes = pkg.serializeBinary();
        return this.fillHeader(bytes, MATCHVS_ROOM_JOIN_OVER_REQ);
    };
    this.leaveRoom = function (gameID, userID, roomID, cpproto) {

        var pkg = new proto.stream.LeaveRoomReq();
        pkg.setGameid(gameID);
        pkg.setUserid(userID);
        pkg.setRoomid(roomID);
        pkg.setCpproto(cpproto);
        var bytes = pkg.serializeBinary();
        return this.fillHeader(bytes, MATCHVS_ROOM_LEAVE_REQ);
    };
}

/**
 * message PlayerInfo
 *{
 *    uint32 userID = 1;
 *    bytes userProfile = 2;
 *}
 * @param userID uint32
 * @param userProfile bytes
 * @constructor
 */
function PlayerInfo(userID, userProfile) {
    this.userID = userID;
    this.userProfile = userProfile;
};

/**
 * message RoomInfo
 *{
 *    uint64 roomID = 1;
 *    string roomName = 2;
 *    uint32 maxPlayer = 3;
 *    int32 mode = 4;
 *    int32 canWatch = 5;
 *    int32 visibility = 6;
 *    bytes roomProperty = 7;
 *    uint32 owner = 8;
 *}
 * @param roomID
 * @param roomName
 * @param maxPlayer
 * @param mode
 * @param canWatch
 * @param visibility
 * @param roomProperty
 * @param owner
 * @constructor
 */
function RoomInfo(roomID, roomName, maxPlayer, mode, canWatch, visibility, roomProperty, owner) {
    this.roomID = roomID;
    this.roomName = roomName;
    this.maxPlayer = maxPlayer;
    this.mode = mode;
    this.canWatch = canWatch;
    this.visibility = visibility;
    this.roomProperty = roomProperty;
    this.owner = owner;
};
/**
 * 
 * @gameID {uint32} value ID
 * @returns {DataView}
 */
MatchvsProtocol.prototype.heartBeat = function (gameID) {

    var WSMessage = mPortoBufRootGW.lookup("stream.HeartbeatReq");
    var msgHeartbeatReq = WSMessage.create({ gameID: gameID });
    var dataArray = WSMessage.encode(msgHeartbeatReq).finish();
    return this.fillHeader(dataArray, MATCHVS_USER_HEARTBEAT_REQ);
};

/**
 * 
 * @param string cpProto
 * @returns {DataView}
 */
MatchvsProtocol.prototype.logout = function () {
    var array = new Uint8Array(0);
    return this.fillHeader(array, MATCHVS_USER_LOGOUT_REQ);
};
/**
 * file describe : this file include some Submodule control of MatchvsProtocol in matchvsprotocol.js
 */

/**
 * 
 * @destType   { number } value : number 0-destUids  1-destUids
 * @destUids   {!Array<number>} value : ID [1,2,3,4,5]
 * @roomID     { number } value : 
 * @msgType    { number } value : 0-+not CPS  1-not+ CPS   2- + CPS
 * @data       { string } value : cp 
 */
MatchvsProtocol.prototype.broadCast = function (roomID, destUids, destType, msgType, data) {
    var broadcast = new proto.stream.Broadcast();
    broadcast.setRoomid(roomID);
    broadcast.setDstuidsList(destUids);
    broadcast.setCpproto(data); //cp 

    // 8  0-3  | destType |msgType  0000|00|00
    var priority = 2;
    var flag = ((priority & 0x0F) << 4) + ((destType & 0x03) << 2) + (msgType & 0x03);
    broadcast.setFlag(flag);
    var bytes = broadcast.serializeBinary();
    return this.fillHeader(bytes, MATCHVS_BROADCAST_HOTEL_REQ);
};

/**
 * groups
 * 
 * @gameID {uint32} value ID
 * @roomID {uint64} value 
 * @confirms {!Array.<string>} value  
 * @cancels {!Array.<string>} value  
 */
MatchvsProtocol.prototype.subscribeEventGroup = function (gameID, roomID, confirms, cancels) {
    var subscribe = new proto.stream.Subscribe();
    subscribe.setRoomid(roomID);
    subscribe.setGameid(gameID);
    subscribe.setCancelsList(cancels);
    subscribe.setConfirmsList(confirms);
    var bytes = subscribe.serializeBinary();
    return this.fillHeader(bytes, CMD_SUBSCRIBE_CMDID);
};

/**
 *
 * @userID { number } value ID
 * @roomID { number } value 
 * @priority { number } value
 * @groups { !Array.<string> } value
 * @cpproto { !Array.<string> } value
 */
MatchvsProtocol.prototype.sendEventGroup = function (userID, roomID, priority, groups, cpproto) {
    var sendevnt = new proto.stream.Publish();
    sendevnt.setRoomid(roomID);
    sendevnt.setPriority(priority);
    sendevnt.setCpproto(stringToUtf8ByteArray(cpproto));
    sendevnt.setGroupsList(groups);

    var bytes = sendevnt.serializeBinary();
    return this.fillHeader(bytes, CMD_PUBLISH_CMDID);
};

/**
 *
 * @userID { number } value ID
 * @gameID { number } value 
 * @roomID { number } value  
 * @userID { !Array.<string> } value
 */
MatchvsProtocol.prototype.hotelHeartBeat = function (gameID, roomID, userID) {
    var heartbeat = new proto.stream.Heartbeat();
    heartbeat.setGameid(gameID);
    heartbeat.setRoomid(roomID);
    heartbeat.setUserid(userID);

    var bytes = heartbeat.serializeBinary();
    return this.fillHeader(bytes, MATCHVS_HEARTBEAT_HOTEL_REQ);
};

MatchvsProtocol.prototype.disConnect = function (userID, gameID, roomId) {
    var paker = new proto.stream.DisconnectReq();
    paker.setGameid(gameID);
    paker.setRoomid(roomId);
    paker.setUserid(userID);
    var bytes = paker.serializeBinary();
    return this.fillHeader(bytes, CMD_DISCONNECT_REQ);
    //TODO 
};

/**
 * 
 * @param userid {number} 
 * @param srcUserId {number} 
 * @param roomid {string} 
 * @param data {string} 
 */
MatchvsProtocol.prototype.kickPlayer = function (userid, srcUserId, roomid, data) {
    var kick = new proto.stream.KickPlayer();
    kick.setRoomid(roomid);
    kick.setSrcuserid(srcUserId);
    kick.setUserid(userid);
    kick.setCpproto(stringToUtf8ByteArray(data));
    var bytes = kick.serializeBinary();
    return this.fillHeader(bytes, CMD_KICK_PLAYER_REQ);
};
/* ================ matchvs.js ================= */
var HEART_BEAT_INTERVAL = 5000; //
var ENGIN_ESTATE = {
    STATE_NONE: 0x0000, //
    STATE_HAVE_INIT: 0x0001, //
    STATE_HAVE_LOGIN: 0x0004, //
    STATE_IN_ROOM: 0x0008 //
};

function MsLoginRsp(status, roomID) {
    this.status = status; //int
    this.roomID = roomID; //unsigned long long
}

function MatchvsEngine() {
    this.mChannel = "MatchVS";
    this.mPlatform = "release";
    this.mLoginStatus = ENGIN_ESTATE.STATE_NONE;
    this.mConfig = MVSConfig(this.mChannel, this.mPlatform);
    this.mAllPlayers = [];
    this.mNetWork;
    this.mHotelNetWork;
    this.mBookInfo;
    this.mHotelHeartBeatTimer;
    this.mProtocol = new MatchvsProtocol();
    var NetWorkCallBackImp = function NetWorkCallBackImp(engine) {
        MSExtend(this, MatchvsNetWork);
        var lastTime = new Date().getTime();
        var timer;
        this.onMsg = function (dataView) {
            var time = new Date().getTime();
            var message = time - lastTime;
            if (message > 10) {}
            lastTime = time;

            var packet = engine.mProtocol.handleMsg(dataView);
            if (packet && packet.header) {
                switch (packet.header.cmd) {
                    case MATCHVS_USER_LOGIN_RSP:
                        if (packet.payload.status === 200) {
                            engine.mLoginStatus |= ENGIN_ESTATE.STATE_HAVE_LOGIN;
                        }
                        var roomID = packet.payload.roomID;
                        engine.mRsp.loginResponse(new MsLoginRsp(packet.payload.status, roomID));
                        break;
                    case MATCHVS_ROOM_JOIN_RSP:
                        if (packet.payload.getStatus() === 200) {
                            engine.mLoginStatus |= ENGIN_ESTATE.STATE_IN_ROOM;
                            engine.mBookInfo = packet.payload.getBookinfo();
                            engine.mRoomInfo = packet.payload.getRoominfo();
                            engine.mHotelNetWork = new MatchvsNetWork("ws://" + engine.mBookInfo.getHoteladdr(), engine.mNetWorkCallBackImp);
                            engine.mNetWorkCallBackImp.onConnect = function (host) {
                                engine.roomCheckIn(engine.mHotelNetWork, engine.mBookInfo, engine.mRoomInfo);
                                engine.mRsp.onConnect && engine.mRsp.onConnect(host);
                            };
                            if (engine.mHotelHeartBeatTimer == null) {
                                engine.mHotelHeartBeatTimer = setInterval(engine.hotelHeartBeat, HEART_BEAT_INTERVAL, engine);
                            }
                        } else {
                            engine.mRsp.errorResponse && engine.mRsp.errorResponse(packet.payload.getStatus(), "Server Response Error");
                        }
                        break;
                    case MATCHVS_ROOM_CREATE_RSP:
                        if (packet.payload.getStatus() === 200) {
                            engine.mLoginStatus |= ENGIN_ESTATE.STATE_IN_ROOM;
                            engine.mBookInfo = packet.payload.getBookinfo();
                            var roomid = packet.payload.getRoomid();
                            var roomInfo = new proto.stream.RoomInfo();
                            roomInfo.setRoomid(roomid);
                            engine.mRoomInfo = roomInfo;
                            engine.mHotelNetWork = new MatchvsNetWork("ws://" + engine.mBookInfo.getHoteladdr(), engine.mNetWorkCallBackImp);
                            engine.mNetWorkCallBackImp.onConnect = function (host) {
                                engine.roomCheckIn(engine.mHotelNetWork, engine.mBookInfo, engine.mRoomInfo);
                                engine.mRsp.errorResponse && engine.mRsp.onConnect(host);
                            };
                            if (engine.mHotelHeartBeatTimer == null) {
                                engine.mHotelHeartBeatTimer = setInterval(engine.hotelHeartBeat, HEART_BEAT_INTERVAL, engine);
                            }
                        } else {
                            engine.mRsp.errorResponse && engine.mRsp.errorResponse(packet.payload.getStatus(), "Server Response Error");
                        }
                        break;
                    case MATCHVS_ROOM_CHECK_IN_RSP:
                        {
                            engine.mAllPlayers = packet.payload.checkins;
                            var roomUserList = [];
                            var num = 0;
                            //
                            for (var i = 0; i < engine.mAllPlayers.length; i++) {
                                if (engine.mAllPlayers[i] !== parseInt(engine.mUserID)) {
                                    //
                                    var roomuser = new MsRoomUserInfo();
                                    roomuser.userId = engine.mAllPlayers[i];
                                    roomuser.userProfile = "";
                                    roomUserList[num++] = roomuser;
                                }
                            }
                            //
                            var maxPlayer = engine.mRoomInfo.getMaxplayer();
                            var roominfo = new MsRoomInfo(engine.mRoomInfo.getRoomid(), "", engine.mRoomInfo.getOwner());
                            engine.mRsp.joinRoomResponse && engine.mRsp.joinRoomResponse(packet.payload.status, roomUserList, roominfo);
                        }break;
                    case MATCHVS_ROOM_CHECKIN_NOTIFY:
                        engine.mAllPlayers = packet.payload.checkins;
                        engine.mRsp.roomCheckInNotify && engine.mRsp.roomCheckInNotify(new MsCheckInNotify(packet.payload.userID, packet.payload.checkins, packet.payload.players, packet.payload.maxPlayers));
                        break;
                    case MATCHVS_ROOM_LEAVE_RSP:
                        var leaveRoomRsp = new MsLeaveRoomRsp(packet.payload.status, packet.payload.roomID, packet.payload.userID, packet.payload.cpProto);
                        engine.mRsp.leaveRoomResponse && engine.mRsp.leaveRoomResponse(leaveRoomRsp);
                        break;
                    case MATCHVS_ROOM_JOIN_OVER_RSP:
                        engine.mRsp.joinOverResponse && engine.mRsp.joinOverResponse(new MsJoinOverRsp(packet.payload.status, utf8ByteArrayToString(packet.payload.cpProto)));
                        break;
                    case MATCHVS_ROOM_NOTICE_USER_JOIN:
                        engine.mRsp.joinRoomNotify && engine.mRsp.joinRoomNotify(new MsRoomUserInfo(packet.payload.user.userID, u8array2str(packet.payload.user.userProfile)));
                        break;
                    case MATCHVS_ROOM_NOTICE_USER_LEAVE:
                        var roomUserInfo = new MsRoomUserInfo(packet.payload.userID, packet.payload.owner);
                        engine.mRsp.leaveRoomNotify && engine.mRsp.leaveRoomNotify(packet.payload.roomID, roomUserInfo);
                        break;
                    case MATCHVS_HEARTBEAT_HOTEL_RSP:
                        //
                        engine.mRsp.hotelHeartBeatRsp && engine.mRsp.hotelHeartBeatRsp(packet.payload.status);
                        break;
                    case MATCHVS_BROADCAST_HOTEL_RSP:

                        engine.mRsp.sendEventResponse && engine.mRsp.sendEventResponse(new MsSendEventRsp(packet.payload.status, packet.header.seq));
                        break;
                    case MATCHVS_HOTEL_NOTIFY:
                        engine.mRsp.sendEventNotify && engine.mRsp.sendEventNotify(new MsSendEventNotify(packet.payload.srcUid, utf8ByteArrayToString(packet.payload.cpProto)));
                        break;
                    case CMD_SUBSCRIBE_ACK_CMDID:
                        //MATCHVS_SUBSCRIBE_EVENT_GROUP_RSP:
                        engine.mRsp.subscribeEventGroupResponse && engine.mRsp.subscribeEventGroupResponse(new MsSubscribeEventGroupRsp(packet.payload.status, packet.payload.groups));
                        break;
                    case CMD_PUBLISH_ACKCMDID:
                        //MATCHVS_SEND_EVENT_GROUP_RSP:
                        engine.mRsp.sendEventGroupResponse && engine.mRsp.sendEventGroupResponse(packet.payload.status);
                        break;
                    case CMD_PUBLISH_NOTIFYCMDID:
                        //SEND_EVENT_GROUP_NOTIFY:
                        engine.mRsp.sendEventGroupNotify && engine.mRsp.sendEventGroupNotify(new MsSendEventGroupNotify(packet.payload.srcUid, packet.payload.groups, utf8ByteArrayToString(packet.payload.cpProto)));
                        break;
                    case MATCHVS_USER_GATEWAY_SPEED_RSP:
                        //TODO 
                        var status = packet.payload.status;
                        var seq = packet.payload.seq;
                        engine.mRsp.gatewaySpeedResponse && engine.mRsp.gatewaySpeedResponse(new gatewaySpeedResponse(status, seq));
                        break;
                    case MATCHVS_USER_HEARTBEAT_RSP:
                        var gameid = packet.payload.gameID;
                        var gsExist = packet.payload.gsExist;
                        //
                        engine.mLoginStatus |= ENGIN_ESTATE.STATE_HAVE_LOGIN;
                        engine.mRsp.heartBeatResponse && engine.mRsp.heartBeatResponse(new MsHeartBeatResponse(gameid, gsExist));
                        break;
                    case MATCHVS_USER_LOGOUT_RSP:
                        engine.mRsp.logoutResponse && engine.mRsp.logoutResponse(packet.payload.status);
                        break;
                    case MATCHVS_NETWORK_STATE_NOTIFY:
                        //TODO 
                        engine.mRsp.networkStateNotify && engine.mRsp.networkStateNotify(packet.payload);
                        break;
                    case CMD_GET_ROOM_LIST_RSP:
                        //TODO 
                        engine.mRsp.getRoomListResponse && engine.mRsp.getRoomListResponse(packet.payload);
                        break;
                    case CMD_DISCONNECT_RSP:
                        engine.mRsp.disConnectResponse && engine.mRsp.disConnectResponse(packet.payload.status);
                        break;
                    case CMD_KICK_PLAYER_RSP:
                        engine.mRsp.kickPlayerResponse && engine.mRsp.kickPlayerResponse(packet.payload.status);
                        break;
                    case CMD_KICK_PLAYER_NOTIFY:
                        if (engine.mHotelHeartBeatTimer != null) {
                            clearInterval(engine.mHotelHeartBeatTimer);
                            engine.mHotelHeartBeatTimer = null;
                            engine.mLoginStatus &= ~ENGIN_ESTATE.STATE_IN_ROOM;
                        }
                        engine.mRsp.kickPlayerNotify && engine.mRsp.kickPlayerNotify(new MsKickPlayerNotify(packet.payload.userID, packet.payload.srcUserID, utf8ByteArrayToString(packet.payload.cpProto)));
                        break;
                    default:

                        break;
                }
            }
        };
        this.onErr = function (errCode, errMsg) {
            engine.mRsp.errorResponse && engine.mRsp.errorResponse(errCode, errMsg);
        };
        this.onConnect = function (host) {
            engine.mRsp.onConnect && engine.mRsp.onConnect(host);
            timer = setInterval(engine.heartBeat, HEART_BEAT_INTERVAL, engine);
        };
        this.onDisConnect = function (host) {
            engine.mRsp.onDisConnect && engine.mRsp.onDisConnect(host);
            if (host.endsWith("7001")) {
                //gateway 
                engine.mLoginStatus = ENGIN_ESTATE.STATE_NONE;
                engine.mLoginStatus |= ENGIN_ESTATE.STATE_HAVE_INIT;
                engine.mLoginStatus |= ENGIN_ESTATE.STATE_HAVE_LOGIN;
                clearInterval(timer);
            }
        };
    };
    this.init = function (pResponse, pChannel, pPlatform, gameID) {
        this.mRsp = pResponse;
        this.mChannel = pChannel;
        this.mPlatform = pPlatform;
        this.mGameID = gameID;
        this.mConfig = MVSConfig(this.mChannel, this.mPlatform);
        this.mProtocol.init();
        this.getHostList();
        return 0;
    };
    /**
     * 
     * @pUserID {uint32} value ID
     * @pToken {uint64} value token
     * @pGameID {uint32} pGameID ID
     * @pGameVersion {uint16} value  
     * @pAppKey { !Array.<string> } app_key key,
     * @pSecretKey pSecretKey secret
     * @pDeviceID { !Array.<string> } deviceID ID
     * @pGatewayID pGatewayID
     */
    this.login = function (pUserID, pToken, pGameID, pGameVersion, pAppKey, pSecretKey, pDeviceID, pGatewayID) {
        if (!(undefined === this.mNetWork || null === this.mNetWork)) {
            this.mNetWork.close();
        }
        this.mNetWorkCallBackImp = new NetWorkCallBackImp(this);
        this.mNetWork = new MatchvsNetWork(this.mConfig.HOST_GATWAY_ADDR, this.mNetWorkCallBackImp);
        this.mUserID = pUserID;
        this.mToken = pToken;
        this.mGameID = pGameID;
        this.mGameVersion = pGameVersion;
        this.mAppKey = pAppKey;
        this.mSecretKey = pSecretKey;
        this.mDeviceID = pDeviceID;
        var buf = this.mProtocol.login(pUserID, pToken, pGameID, pGameVersion, pAppKey, pSecretKey, pDeviceID, pGatewayID);
        this.mNetWork.send(buf);
        return 0;
    };
    /**
     * 
     */

    this.speed = function () {
        if ((this.mLoginStatus & ENGIN_ESTATE.STATE_HAVE_LOGIN) !== ENGIN_ESTATE.STATE_HAVE_LOGIN) {
            return 1; //
        }
        var buf = this.mProtocol.speed(this.mUserID, this.mGameID, this.mToken, VERSION, this.mGameVersion);
        this.mNetWork.send(buf);
        return 0;
    };
    /**
     * int32_t createRoom= function ( MsCreateRoomInfo roomInfo, const MsString userProfile);
     */
    this.roomCreate = function (createRoom, userProfile) {
        if ((this.mLoginStatus & ENGIN_ESTATE.STATE_HAVE_LOGIN) !== ENGIN_ESTATE.STATE_HAVE_LOGIN) {
            return 1; //
        }
        var roomInfo = new RoomInfo(0, createRoom.roomName, createRoom.maxPlayer, createRoom.mode, createRoom.canWatch, createRoom.visibility, createRoom.roomProperty, 0);
        var playInfo = new PlayerInfo(this.mUserID, userProfile);
        this.mNetWork.send(this.mProtocol.roomCreate(createRoom.maxPlayer, 0, this.mGameID, roomInfo, playInfo));
        return 0;
    };
    this.getVersion = function () {
        return "MatchVS-SDK-JS_v1.0.0.beta.20180113.0";
    };

    this.unInit = function () {
        return 0;
    };

    /**
     * getRoomList
     * @param filter {MsRoomFilter}
     */
    this.getRoomList = function (filter) {
        if ((this.mLoginStatus & ENGIN_ESTATE.STATE_HAVE_LOGIN) !== ENGIN_ESTATE.STATE_HAVE_LOGIN) {
            return 1; //
        }
        var buf = this.mProtocol.getRoomList(this.mGameID, filter);
        this.mNetWork.send(buf);
        return 0;
    };
    /**
     * create a connect to room service and check in
     * @param hotelNetWork {MatchvsNetWork} a connection for Hotel
     * @param bookInfo {Object}bookInfo
     * @param roomInfo {Object}roomInfo
     */
    this.roomCheckIn = function (hotelNetWork, bookInfo, roomInfo) {
        if ((this.mLoginStatus & ENGIN_ESTATE.STATE_IN_ROOM) !== ENGIN_ESTATE.STATE_IN_ROOM) {
            return 1;
        }
        var buf = this.mProtocol.roomCheckIn(bookInfo, roomInfo, this.mUserID, this.mGameID);
        hotelNetWork.send(buf);
        return 0;
    };
    /**
     * int joinRandomRoom(int iMaxPlayer, const MsString userProfile);
     */
    this.joinRandomRoom = function (maxPlayer, userProfile) {
        if ((this.mLoginStatus & ENGIN_ESTATE.STATE_HAVE_LOGIN) !== ENGIN_ESTATE.STATE_HAVE_LOGIN) {
            return 1; //
        }
        var roomJoin = new MsRoomJoin(MsEnum.JoinRoomType.joinRandomRoom, this.mUserID, 0, this.mGameID, maxPlayer, 0, 0, userProfile, [{ name: "geliang" }]);
        var buf = this.mProtocol.joinRoom(roomJoin);
        this.mNetWork.send(buf);
        return 0;
    };

    /**
     * 
     * @param maxPlayer {number}
     * @param tags {Array<{key:value}>}
     * @param mode {number}
     * @param userProfile {string}
     * @returns {number}
     */
    this.joinRoomWithProperties = function (tags, maxPlayer, mode, userProfile) {
        if ((this.mLoginStatus & ENGIN_ESTATE.STATE_HAVE_LOGIN) !== ENGIN_ESTATE.STATE_HAVE_LOGIN) {
            return 1;
        }
        var roomJoin = new MsRoomJoin(MsEnum.JoinRoomType.joinRoomWithProperty, this.mUserID, 1, this.mGameID, maxPlayer, mode, 0, userProfile, tags);
        var buf = this.mProtocol.joinRoom(roomJoin);
        this.mNetWork.send(buf);
        return 0;
    };

    /**
     *
     * @param roomID {string}
     * @param maxPlayer {number}
     * @param mode {number}
     * @param userProfile {string}
     * @returns {number}
     */
    this.joinRoomSpecial = function (roomID, maxPlayer, mode, userProfile) {
        if ((this.mLoginStatus & ENGIN_ESTATE.STATE_HAVE_LOGIN) !== ENGIN_ESTATE.STATE_HAVE_LOGIN) {
            return 1;
        }
        var roomid = String(roomID);
        if ("0" === roomid || "" === roomid || " " === roomid) {
            return 1;
        }
        var roomJoin = new MsRoomJoin(MsEnum.JoinRoomType.joinSpecialRoom, this.mUserID, roomID, this.mGameID, maxPlayer, mode, 0, userProfile, [{ name: "MatchVS" }]);
        var buf = this.mProtocol.joinRoomSpecial(roomJoin);
        this.mNetWork.send(buf);
        return 0;
    };

    /**
     * int32_t joinRoom(uint64_t roomID, const MsString userProfile)
     */
    this.joinRoom = function (roomID, userProfile) {
        if ((this.mLoginStatus & ENGIN_ESTATE.STATE_HAVE_LOGIN) !== ENGIN_ESTATE.STATE_HAVE_LOGIN) {
            return 1;
        }
        var maxPlayer = 0;
        var roomJoin = new MsRoomJoin(MsEnum.JoinRoomType, this.mUserID, roomID, this.mGameID, 0, MsEnum.JoinRoomType.joinSpecialRoom, maxPlayer, userProfile, []);
        var buf = this.mProtocol.joinRoom(roomJoin);
        this.mNetWork.send(buf);
        return 0;
    };

    /**
     * int joinOver= function ( MsString cpProto);
     */
    this.joinOver = function (cpProto) {
        if ((this.mLoginStatus & ENGIN_ESTATE.STATE_IN_ROOM) !== ENGIN_ESTATE.STATE_IN_ROOM) {
            return 1;
        }
        var buf = this.mProtocol.joinOver(this.mGameID, this.mRoomInfo.getRoomid(), stringToUtf8ByteArray(cpProto), this.mUserID);
        this.mNetWork.send(buf);
        return 0;
    };
    /**
     *    int leaveRoom= function ( MsString cpProto);
     */
    this.leaveRoom = function (cpProto) {
        if ((this.mLoginStatus & ENGIN_ESTATE.STATE_IN_ROOM) !== ENGIN_ESTATE.STATE_IN_ROOM) {
            return 1;
        }
        var buf = this.mProtocol.leaveRoom(this.mGameID, this.mUserID, this.mRoomInfo.getRoomid(), cpProto);
        if (this.mHotelHeartBeatTimer != null) {
            clearInterval(this.mHotelHeartBeatTimer);
            this.mHotelHeartBeatTimer = null;
            this.mLoginStatus &= ~ENGIN_ESTATE.STATE_IN_ROOM;
        }
        this.mNetWork.send(buf);
        return 0;
    };
    /**
     *
     * @param srcUserid {number} userID
     * @param cpProto {string}
     * @returns {number} 0 1
     */
    this.kickPlayer = function (srcUserid, cpProto) {
        if ((this.mLoginStatus & ENGIN_ESTATE.STATE_IN_ROOM) !== ENGIN_ESTATE.STATE_IN_ROOM) {
            return 1;
        }
        var buf = this.mProtocol.kickPlayer(srcUserid, this.mUserID, this.mRoomInfo.getRoomid(), cpProto);
        this.mNetWork.send(buf);
        return 0;
    };

    /**
     * setFrameSync(int32_t frameRate);
     */
    this.frameRate = function (frameRate) {
        return 0;
    };

    /**
     * int32_t sendFrameEvent= function ( MsString cpProto);
     */
    this.sendFrameEvent = function (cpProto) {
        return 0;
    };
}

function MatchvsResponse() {

    /**
     *
     * @param userInfo {MsRegistRsp}
     */
    this.registerUserResponse = function (userInfo) {};
    /**
     *
     * @param tRsp {MsLoginRsp}
     */
    this.loginResponse = function (loginRsp) {};
    /**
     * MsLogoutRsp
     * @param status {number}
     */
    this.logoutResponse = function (status) {};
    /**
     *
     * @param MsCreateRoomRsp
     */
    this.createRoomResponse = function (rsp) {};
    /**
     *
     * @param rsp {MsRoomListRsp}
     */
    this.getRoomListResponse = function (rsp) {};
    /**
     *
     * @type {CheckInAck}
     */
    this.joinRoomResponse = function (status, roomUserInfoList, roomInfo) {};
    /**
     * message NoticeJoin
     *{
     *    PlayerInfo user = 1;
     *}
     * message PlayerInfo
     *{
     *    uint32 userID = 1;
     *    bytes userProfile = 2;
     *}
     * @param roomUserInfo {NoticeJoin}
     */
    this.joinRoomNotify = function (roomId, roomUserInfo) {};
    /**
     * message NoticeLeave
     *{
     *    uint32 userID = 1;
     *    uint64 roomID = 2;
     *    uint32 owner = 3;
     *}
     * @type rsp {NoticeLeave}
     */
    this.joinOverResponse = function (rsp) {};
    /**
     * message LeaveRoomRsp
     *{
     *    ErrorCode status = 1;//200. | 403. | 404. | 500.
     *    uint64 roomID = 2;
     *    uint32 userID = 3;
     *    bytes cpProto = 4;
     *}
     * @param rsp {LeaveRoomRsp}
     */
    this.leaveRoomResponse = function (rsp) {};
    /**
     * uint64_t roomID, const {MsRoomUserInfo} tRsp
     */
    this.leaveRoomNotify = function (roomId, tRsp) {};
    /**
     * MsKickPlayerRsp
     * @param MsKickPlayerRsp
     */
    this.kickPlayerResponse = function (rsp) {};
    /**
     *
     * @param MsKickPlayerNotify
     */
    this.kickPlayerNotify = function (notify) {};
    /**
     *
     * @param  tRsp {MsSendEventRsp}
     */
    this.sendEventResponse = function (tRsp) {};
    /**
     *
     * @param tRsp {MsSendEventNotify}
     */
    this.sendEventNotify = function (tRsp) {};
    /**
     *
     * @param errCode {Number}
     * @param errMsg {string}
     */
    this.errorResponse = function (errCode, errMsg) {};
    /**
     * status==200 is success.other is fail;
     * @param status {int}
     */
    this.initResponse = function (status) {};
    /**
     *
     * @param int
     */
    this.networkDelay = function (delay) {};
    /**
     *
     * @param notify{MsNetworkStateNotify}
     */
    this.networkStateNotify = function (notify) {};
    /**
     *
     * @param tRsp {MsSubscribeEventGroupRsp}
     */
    this.subscribeEventGroupResponse = function (tRsp) {};
    /**
     *
     * @param tRsp {MsSendEventGroupRsp}
     */
    this.sendEventGroupResponse = function (tRsp) {};
    /**
     *
     * @param  notify {MsSendEventGroupNotify}
     */
    this.sendEventGroupNotify = function (notify) {};
    /**
     *
     * @param rsp {MsSetChannelFrameSyncRsp}
     */
    this.setFrameSyncResponse = function (rsp) {};
    /**
     *
     * @param rsp {MsSendFrameEventRsp}
     */
    this.sendFrameEventResponse = function (rsp) {};
    /**
     *
     * @param data {MsFrameData}
     */
    this.frameUpdate = function (data) {};
    /**
     *
     * @param data {MsHotelHeartBeatRsp}
     */
    this.hotelHeartBeatRsp = function (data) {};

    /**
     *
     * @param rsp
     */
    this.gatewaySpeedResponse = function (rsp) {};

    /**
     *
     * @param rsp
     */
    this.heartBeatResponse = function (rsp) {};

    /**
     *
     * @param rsp
     */
    this.roomCheckInNotify = function (rsp) {};

    /**
     * 
     * @param rep
     */
    this.disConnectResponse = function (rep) {};
}

function MsLogoutRsp(status) {
    this.status = status;
}

function MsHeartBeatResponse(gameid, gsExist) {
    this.gameID = gameid;
    this.gsExist = gsExist;
}

function gatewaySpeedResponse(Status, Seq) {
    this.status = Status;
    this.seq = Seq;
}

/**
 * message RoomFilter
 *{
 *    uint32 maxPlayer = 1;
 *    int32 mode = 2;
 *    int32 canWatch = 3;
 *    bytes roomProperty = 4;
 *}
 * @param maxPlayer {int}
 * @param mode {int}
 * @param canWatch {int}
 * @param roomProperty {String}
 * @constructor
 */
function MsRoomFilter(maxPlayer, mode, canWatch, roomProperty) {
    this.maxPlayer = maxPlayer;
    this.mode = mode;
    this.canWatch = canWatch;
    this.roomProperty = roomProperty;
}

/**
 * 
 * @returns {DataView}
 */
MatchvsEngine.prototype.logout = function () {
    if (this.mHotelHeartBeatTimer != null) {
        clearInterval(this.mHotelHeartBeatTimer);
        this.mHotelHeartBeatTimer = null;
        this.mLoginStatus &= ~ENGIN_ESTATE.STATE_IN_ROOM;
    }
    if ((this.mLoginStatus & ENGIN_ESTATE.STATE_HAVE_LOGIN) !== ENGIN_ESTATE.STATE_HAVE_LOGIN) {
        return 1;
    }
    var buf = this.mProtocol.logout();
    this.mNetWork.send(buf);
    return 0;
};
/**
 * 
 */
MatchvsEngine.prototype.heartBeat = function (Instance) {
    if (Instance.mGameID === undefined || Instance.mGameID === '' || Instance.mGameID === 0) {
        return;
    }
    var buf = Instance.mProtocol.heartBeat(Instance.mGameID);
    Instance.mNetWork.send(buf);
};

/**
 * 
 * @destType    : number 0-destUids  1-destUids
 * @destUids    : ID [1,2,3,4,5]
 * @roomID      : 
 * @msgType     : 0-+not CPS  1-not+ CPS   2- + CPS
 * @data        : cp 
 */
MatchvsEngine.prototype.sendEvent = function (data) {
    if ((this.mLoginStatus & ENGIN_ESTATE.STATE_IN_ROOM) !== ENGIN_ESTATE.STATE_IN_ROOM) {
        return 1;
    }
    var destType = 0;
    var msgType = 0;
    var userids = [];
    var num = 0;
    for (var i = 0; i < this.mAllPlayers.length; i++) {
        if (this.mAllPlayers[i] !== parseInt(this.mUserID)) {
            userids[num++] = this.mAllPlayers[i];
        }
    }
    var buf = this.mProtocol.broadCast(this.mRoomInfo.getRoomid(), userids, destType, msgType, stringToUtf8ByteArray(data));
    this.mHotelNetWork.send(buf);
    // this.mProtocol.seq-1 11
    return { sequence: this.mProtocol.seq - 1, result: 0 };
};

/**
 * groups
 * 
 * @param gameID {uint32} value ID
 * @param roomID {string} value 
 * @param confirms {!Array.<string>} value  
 * @param cancels {!Array.<string>} value  
 */
MatchvsEngine.prototype.subscribeEventGroup = function (confirms, cancels) {
    if ((this.mLoginStatus & ENGIN_ESTATE.STATE_IN_ROOM) !== ENGIN_ESTATE.STATE_IN_ROOM) {
        return 1;
    }
    var buf = this.mProtocol.subscribeEventGroup(this.mGameID, this.mRoomInfo.getRoomid(), confirms, cancels);
    this.mHotelNetWork.send(buf);
};

/**
 * @groups { !Array.<string> } value subscribeEventGroup 
 * @cpproto { !Array.<string> } value 
 */
MatchvsEngine.prototype.sendEventGroup = function (groups, data) {
    if ((this.mLoginStatus & ENGIN_ESTATE.STATE_IN_ROOM) !== ENGIN_ESTATE.STATE_IN_ROOM) {
        return 1;
    }
    var priority = 1; // 
    var buf = this.mProtocol.sendEventGroup(this.mGameID, this.mRoomInfo.getRoomid(), priority, groups, data);
    this.mHotelNetWork.send(buf);
};

/**
 * @gameID { number } value ID
 * @roomID { string } value 
 * @userID { number } value  
 */
MatchvsEngine.prototype.hotelHeartBeat = function (engine) {
    this.mLoginStatus |= ENGIN_ESTATE.STATE_IN_ROOM;
    var buf = engine.mProtocol.hotelHeartBeat(engine.mGameID, engine.mRoomInfo.getRoomid(), engine.mUserID);
    engine.mHotelNetWork.send(buf);
};

MatchvsEngine.prototype.registerUser = function () {
    if ((this.mLoginStatus & ENGIN_ESTATE.STATE_HAVE_INIT) !== ENGIN_ESTATE.STATE_HAVE_INIT) {
        return 1;
    }
    var deviceid = this.mDeviceID;
    var channel = this.mChannel;
    var gameVersion = this.mGameVersion;
    var uri = "/wc3/regit.do";
    var url = this.mConfig.REGISTER_USER_URL + uri + "?mac=0" + "&deviceid=" + deviceid + "&channel=" + channel + "&pid=13" + "&version=" + gameVersion;
    var rep = new MatchvsNetWorkCallBack();
    rep.rsp = this.mRsp.registerUserResponse;
    new MatchvsHttp(rep).get(url);
    rep.onMsg = function (buf) {
        var obj = JSON.parse(buf);
        this.rsp(new MsRegistRsp(obj.code, obj.data.userid, obj.data.token, obj.data.nickname, obj.data.avatar));
    };

    rep.onErr = function (errCode, errMsg) {
        this.rsp(new MsRegistRsp(errCode, 0, "0", errMsg, ""));
    };

    return 0;
};

/**
 * 
 * @returns {number}
 */
MatchvsEngine.prototype.getHostList = function () {
    var gameId = this.mGameID;
    var channel = this.mChannel;
    var platform = this.mPlatform;
    var uri = "/v1/gateway/query";
    var url = "http://sdk.matchvs.com" + uri + "?mac=0" + "&gameid=" + gameId + "&channel=" + channel + "&platform=" + platform;
    var rep = new MatchvsNetWorkCallBack();
    var engine = this;
    new MatchvsHttp(rep).get(url);
    rep.onMsg = function (buf) {
        var obj = JSON.parse(buf);
        if (obj.status === 200) {
            engine.mLoginStatus |= ENGIN_ESTATE.STATE_HAVE_INIT;
            var http = "http://";
            var port = ":7001";
            HttpConf.REGISTER_USER_URL = http + obj.data.vsuser;
            HttpConf.HOST_GATWAY_ADDR = "ws://" + obj.data.engine + port;
            HttpConf.CMSNS_URL = http + obj.data.cmsns;
            HttpConf.VS_OPEN_URL = http + obj.data.vsopen;
            HttpConf.VS_PAY_URL = http + obj.data.vspay;
            HttpConf.VS_PRODUCT_URL = http + obj.data.VS_PRODUCT_URL;
        }
        engine.mRsp.initResponse(obj.status);
    };
    rep.onErr = function (errCode, errMsg) {
        console.error("getHostListErrCode" + errCode + "getHostListErrMsg" + errMsg);
        engine.mRsp.errorResponse(errCode, errMsg);
    };
    return 0;
};
/**
 * 
 * @param roomID 
 */
MatchvsEngine.prototype.disConnect = function (roomID) {
    var buf = engine.mProtocol.disConnect(this.mUserID, this.mGameID, roomID);
    this.mNetWork.send(buf);
};
/* ================ base64.js ================= */
function Base64() {

    // private property
    _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

    // public method for encoding
    this.encode = function (input) {
        var output = "";
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0;
        input = _utf8_encode(input);
        while (i < input.length) {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            enc1 = chr1 >> 2;
            enc2 = (chr1 & 3) << 4 | chr2 >> 4;
            enc3 = (chr2 & 15) << 2 | chr3 >> 6;
            enc4 = chr3 & 63;
            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
                enc4 = 64;
            }
            output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
        }
        return output;
    };

    // public method for decoding
    this.decode = function (input) {
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        while (i < input.length) {
            enc1 = _keyStr.indexOf(input.charAt(i++));
            enc2 = _keyStr.indexOf(input.charAt(i++));
            enc3 = _keyStr.indexOf(input.charAt(i++));
            enc4 = _keyStr.indexOf(input.charAt(i++));
            chr1 = enc1 << 2 | enc2 >> 4;
            chr2 = (enc2 & 15) << 4 | enc3 >> 2;
            chr3 = (enc3 & 3) << 6 | enc4;
            output = output + String.fromCharCode(chr1);
            if (enc3 != 64) {
                output = output + String.fromCharCode(chr2);
            }
            if (enc4 != 64) {
                output = output + String.fromCharCode(chr3);
            }
        }
        output = _utf8_decode(output);
        return output;
    };

    // private method for UTF-8 encoding
    _utf8_encode = function _utf8_encode(string) {
        string = string.replace(/\r\n/g, "\n");
        var utftext = "";
        for (var n = 0; n < string.length; n++) {
            var c = string.charCodeAt(n);
            if (c < 128) {
                utftext += String.fromCharCode(c);
            } else if (c > 127 && c < 2048) {
                utftext += String.fromCharCode(c >> 6 | 192);
                utftext += String.fromCharCode(c & 63 | 128);
            } else {
                utftext += String.fromCharCode(c >> 12 | 224);
                utftext += String.fromCharCode(c >> 6 & 63 | 128);
                utftext += String.fromCharCode(c & 63 | 128);
            }
        }
        return utftext;
    };

    // private method for UTF-8 decoding
    _utf8_decode = function _utf8_decode(utftext) {
        var string = "";
        var i = 0;
        var c = c1 = c2 = 0;
        while (i < utftext.length) {
            c = utftext.charCodeAt(i);
            if (c < 128) {
                string += String.fromCharCode(c);
                i++;
            } else if (c > 191 && c < 224) {
                c2 = utftext.charCodeAt(i + 1);
                string += String.fromCharCode((c & 31) << 6 | c2 & 63);
                i += 2;
            } else {
                c2 = utftext.charCodeAt(i + 1);
                c3 = utftext.charCodeAt(i + 2);
                string += String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
                i += 3;
            }
        }
        return string;
    };
}

module.exports = { MatchvsEngine: MatchvsEngine, MatchvsResponse: MatchvsResponse };

cc._RF.pop();